```python
def heuristics_v2(df: pd.DataFrame, macro_data: pd.Series) -> pd.Series:
    # Adaptive momentum considering both short and long-term trends with exponential smoothing
    short_term_momentum = df['close'].pct_change(periods=5).ewm(span=5, adjust=False).mean()
    long_term_momentum = df['close'].pct_change(periods=30).ewm(span=30, adjust=False).mean()
    adaptive_momentum = 0.7 * short_term_momentum + 0.3 * long_term_momentum

    # Dynamic volatility using the standard deviation of logarithmic returns over the last 14 days with advanced smoothing
    log_returns = np.log(df['close'] / df['close'].shift(1))
    dynamic_volatility = log_returns.rolling(window=14).std().ewm(span=14, adjust=False).mean()

    # Normalized volume to account for varying liquidity conditions
    normalized_volume = (df['volume'] - df['volume'].rolling(window=30).mean()) / df['volume'].rolling(window=30).std()

    # Market sentiment using the ratio of high to low prices as a proxy
    market_sentiment = (df['high'] - df['low']) / df['close']

    # Sector-specific trend factor
    sector_trend = df['close'].pct_change(periods=90).ewm(span=90, adjust=False).mean()

    # RSI (Relative Strength Index) as a technical indicator
    delta = df['close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))

    # Incorporating macroeconomic indicators
    macro_weight = 0.1 * macro_data.ewm(span=30, adjust=False).mean()

    # Dynamically adjust weights based on market conditions using a simple linear model
    momentum_weight = 0.4 + 0.1 * np.sign(adaptive_momentum)
    volatility_weight = 0.2 + 0.1 * np.sign(-dynamic_volatility)
    volume_weight = 0.3 + 0.1 * np.sign(normalized_volume)
    sentiment_weight = 0.1 + 0.1 * np.sign(market_sentiment)

    # Ensure weights sum to 1
    total_weight = momentum_weight + volatility_weight + volume_weight + sentiment_weight + macro_weight
    momentum_weight /= total_weight
    volatility_weight /= total_weight
    volume_weight /= total_weight
    sentiment_weight /= total_weight
    macro_weight /= total_weight

    # Combining the factors into a single alpha factor
    factor_values = (momentum_weight * adaptive_momentum 
                    - volatility_weight * dynamic_volatility 
                    + volume_weight * normalized_volume 
                    + sentiment_weight * market_sentiment 
                    + 0.1 * sector_trend
                    + macro_weight * macro_data)

    return factor_values
```
