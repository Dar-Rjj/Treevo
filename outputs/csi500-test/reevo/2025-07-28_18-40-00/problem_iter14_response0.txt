```python
def heuristics_v2(df: pd.DataFrame) -> pd.Series:
    # Calculate adaptive momentum using logarithmic returns over different time frames
    log_returns = np.log(df['close']).diff()
    short_momentum = log_returns.rolling(window=5).mean()
    medium_momentum = log_returns.rolling(window=10).mean()
    long_momentum = log_returns.rolling(window=30).mean()
    adaptive_momentum = (short_momentum + 2*medium_momentum + 3*long_momentum) / 6

    # Calculate dynamic volatility as the standard deviation of log returns over the last 30 days
    dynamic_volatility = log_returns.rolling(window=30).std()

    # Calculate normalized volume as the ratio of current volume to the 50-day average volume
    avg_volume = df['volume'].rolling(window=50).mean()
    normalized_volume = df['volume'] / avg_volume

    # Calculate trading volume change as the percentage change in volume over the last 10 days
    volume_change = df['volume'].pct_change(periods=10).fillna(0)

    # Calculate market sentiment using the difference between the highest and lowest price, normalized by the close price
    market_sentiment = (df['high'] - df['low']) / df['close']

    # Calculate Chaikin Money Flow (CMF) over a 20-day period for additional market sentiment
    money_flow_multiplier = ((df['close'] - df['low']) - (df['high'] - df['close'])) / (df['high'] - df['low'])
    money_flow_volume = money_flow_multiplier * df['volume']
    cmf = money_flow_volume.rolling(window=20).sum() / df['volume'].rolling(window=20).sum()

    # Calculate the Average Directional Index (ADX) for trend strength
    high_low_diff = df['high'].diff().abs()
    high_close_diff = (df['high'] - df['close'].shift(1)).abs()
    low_close_diff = (df['low'] - df['close'].shift(1)).abs()
    tr = pd.concat([high_low_diff, high_close_diff, low_close_diff], axis=1).max(axis=1)
    atr = tr.rolling(window=14).mean()
    dm_plus = (df['high'] - df['high'].shift(1)).where(lambda x: x > 0, 0)
    dm_minus = (df['low'].shift(1) - df['low']).where(lambda x: x > 0, 0)
    di_plus = 100 * (dm_plus.rolling(window=14).sum() / atr)
    di_minus = 100 * (dm_minus.rolling(window=14).sum() / atr)
    adx = 100 * (di_plus - di_minus).abs() / (di_plus + di_minus)

    # Combine the factors into a single alpha factor with dynamic weighting
    factor_values = (
        0.4 * adaptive_momentum - 
        0.2 * dynamic_volatility + 
        0.1 * normalized_volume + 
        0.1 * volume_change + 
        0.1 * market_sentiment +
        0.1 * cmf +
        0.1 * adx
    )

    return factor_values
```
