```python
def heuristics_v2(df: pd.DataFrame) -> pd.Series:
    # Adaptive momentum considering both short and long-term trends with exponential smoothing
    short_term_momentum = df['close'].pct_change(periods=5).ewm(span=5, adjust=False).mean()
    long_term_momentum = df['close'].pct_change(periods=30).ewm(span=30, adjust=False).mean()
    adaptive_momentum = 0.7 * short_term_momentum + 0.3 * long_term_momentum

    # Dynamic volatility using the standard deviation of logarithmic returns over the last 14 days
    log_returns = np.log(df['close'] / df['close'].shift(1))
    dynamic_volatility = log_returns.rolling(window=14).std().ewm(span=14, adjust=False).mean()

    # Volume growth rate to account for changing liquidity conditions
    volume_growth_rate = (df['volume'] - df['volume'].shift(20)) / df['volume'].shift(20)

    # Market sentiment using the ratio of high to low prices as a proxy
    market_sentiment = (df['high'] - df['low']) / df['close']

    # Price range expansion to capture potential breakout opportunities
    price_range_expansion = (df['high'] - df['low']) / df['close'].rolling(window=20).mean()

    # Money Flow Index (MFI) for additional liquidity indicator
    typical_price = (df['high'] + df['low'] + df['close']) / 3
    money_flow = typical_price * df['volume']
    positive_money_flow = money_flow.where(typical_price > typical_price.shift(1), 0)
    negative_money_flow = money_flow.where(typical_price < typical_price.shift(1), 0)
    mfi = positive_money_flow.rolling(window=14).sum() / (positive_money_flow.rolling(window=14).sum() + negative_money_flow.rolling(window=14).sum())
    
    # Adaptive weights based on recent market conditions
    momentum_weight = 0.4 + 0.1 * adaptive_momentum.rolling(window=10).mean()
    volatility_weight = 0.2 + 0.1 * (1 - dynamic_volatility.rolling(window=10).mean())
    volume_weight = 0.1 + 0.1 * volume_growth_rate.rolling(window=10).mean()
    sentiment_weight = 0.1 + 0.1 * market_sentiment.rolling(window=10).mean()
    price_expansion_weight = 0.1 + 0.1 * price_range_expansion.rolling(window=10).mean()
    mfi_weight = 0.1 + 0.1 * mfi.rolling(window=10).mean()

    # Ensure weights sum to 1
    total_weight = momentum_weight + volatility_weight + volume_weight + sentiment_weight + price_expansion_weight + mfi_weight
    momentum_weight /= total_weight
    volatility_weight /= total_weight
    volume_weight /= total_weight
    sentiment_weight /= total_weight
    price_expansion_weight /= total_weight
    mfi_weight /= total_weight

    # Combining the factors into a single alpha factor
    factor_values = (
        momentum_weight * adaptive_momentum -
        volatility_weight * dynamic_volatility +
        volume_weight * volume_growth_rate +
        sentiment_weight * market_sentiment +
        price_expansion_weight * price_range_expansion +
        mfi_weight * mfi
    )

    return factor_values
```
