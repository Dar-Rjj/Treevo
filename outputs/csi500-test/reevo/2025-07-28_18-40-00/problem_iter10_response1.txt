```python
def heuristics_v2(df: pd.DataFrame) -> pd.Series:
    # Adaptive momentum with exponential smoothing for different time periods
    short_term_momentum = df['close'].pct_change(periods=5).ewm(span=10, adjust=False).mean()
    medium_term_momentum = df['close'].pct_change(periods=15).ewm(span=20, adjust=False).mean()
    long_term_momentum = df['close'].pct_change(periods=30).ewm(span=30, adjust=False).mean()
    
    # Dynamic adaptive momentum combining short, medium, and long-term trends
    adaptive_momentum = 0.4 * short_term_momentum + 0.3 * medium_term_moment + 0.3 * long_term_momentum

    # Dynamic volatility using the standard deviation of logarithmic returns over the last 14 days
    log_returns = np.log(df['close'] / df['close'].shift(1))
    dynamic_volatility = log_returns.rolling(window=14).std()

    # Volume-based liquidity factor without normalization
    avg_volume = df['volume'].rolling(window=50).mean()
    volume_factor = df['volume'] - avg_volume

    # Market sentiment using a simple moving average of the last 10 days close prices
    market_sentiment = df['close'].rolling(window=10).mean() / df['close']

    # Incorporate price range as a factor, representing the difference between high and low prices
    price_range = (df['high'] - df['low']) / df['close']

    # Combining the factors into a single alpha factor
    # Dynamically adjust weights based on recent market conditions
    recent_volatility_increase = (dynamic_volatility > dynamic_volatility.shift(1)).astype(int)
    recent_volume_increase = (df['volume'] > avg_volume).astype(int)
    
    # Adjusting weights based on recent volatility and volume increases
    momentum_weight = 0.5 + 0.1 * recent_volatility_increase
    volatility_weight = 0.2 + 0.1 * recent_volume_increase
    volume_factor_weight = 0.1
    sentiment_weight = 0.1
    price_range_weight = 0.1

    factor_values = (
        momentum_weight * adaptive_momentum 
        - volatility_weight * dynamic_volatility 
        + volume_factor_weight * volume_factor 
        + sentiment_weight * market_sentiment 
        + price_range_weight * price_range
    )

    return factor_values
```
