[
     {
          "algorithm": "The algorithm involves calculating a momentum-based factor that combines the ratio of closing prices to their moving averages with trading volume changes, then applying a custom smoothing technique to generate more stable and interpretable alpha factors.",
          "code": "def heuristics_v2(df):\n    # Calculate 10-day and 30-day moving averages of the close price\n    df['ma10'] = df['close'].rolling(window=10).mean()\n    df['ma30'] = df['close'].rolling(window=30).mean()\n    \n    # Compute the momentum-based factor\n    df['momentum_factor'] = (df['close'] / df[['ma10', 'ma30']].min(axis=1)) * (df['volume'] / df['volume'].shift(1))\n    \n    # Apply a simple smoothing (SMA) to the momentum-based factor\n    df['smoothed_momentum'] = df['momentum_factor'].rolling(window=5).mean()\n    \n    # Prepare the output\n    heuristics_matrix = df['smoothed_momentum']\n    \n    return heuristics_matrix",
          "objective": -0.0225,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates the moving average of the difference between the highest and lowest prices over a specified window, then subtracts the moving average of the closing price over the same period, aiming to capture momentum and volatility.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    high_low_diff = df['high'] - df['low']\n    ma_high_low = high_low_diff.rolling(window=5).mean()\n    ma_close = df['close'].rolling(window=5).mean()\n    heuristics_matrix = ma_high_low - ma_close\n    return heuristics_matrix",
          "objective": -0.02021,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies patterns in market features by calculating the difference between the exponential moving average (EMA) of the close price and the EMA of the volume, then scales this difference by the ratio of the current day's amount to the average amount over a specified period.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    ema_close = df['close'].ewm(span=5).mean()\n    ema_volume = df['volume'].ewm(span=5).mean()\n    avg_amount = df['amount'].rolling(window=5).mean()\n    factor = (ema_close - ema_volume) * (df['amount'] / avg_amount)\n    heuristics_matrix = pd.Series(factor, index=df.index)\n    return heuristics_matrix",
          "objective": -0.01994,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a novel alpha factor by combining price momentum and trading volume changes, where the factor value for each day is computed as the 5-day moving average of the close price's percentage change minus the 5-day moving average of the volume's percentage change.",
          "code": "def heuristics_v2(df):\n    close_pct_change = df['close'].pct_change()\n    volume_pct_change = df['volume'].pct_change()\n    close_mavg = close_pct_change.rolling(window=5).mean()\n    volume_mavg = volume_pct_change.rolling(window=5).mean()\n    heuristics_matrix = close_mavg - volume_mavg\n    return heuristics_matrix",
          "objective": -0.01857,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates the moving average of the daily price range (high - low) and the daily trading volume, then combines these two indicators through a weighted sum to form the final alpha factor.",
          "code": "def heuristics_v2(df):\n    # Calculate the daily price range\n    df['price_range'] = df['high'] - df['low']\n    \n    # Calculate the moving average of the daily price range over a 5-day window\n    df['range_ma'] = df['price_range'].rolling(window=5).mean()\n    \n    # Calculate the moving average of the daily trading volume over a 5-day window\n    df['volume_ma'] = df['volume'].rolling(window=5).mean()\n    \n    # Combine the two factors into one using a simple weighted sum, weights are set arbitrarily for demonstration\n    heuristics_matrix = 0.7 * df['range_ma'] + 0.3 * df['volume_ma']\n    \n    return heuristics_matrix",
          "objective": -0.01694,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates the momentum of each stock based on its closing prices and then computes the volatility-adjusted momentum by dividing the momentum by the standard deviation of daily returns over a recent period, aiming to generate a novel factor that could predict future returns.",
          "code": "def heuristics_v2(df):\n    # Calculate daily returns\n    df['Return'] = df['close'].pct_change()\n    \n    # Calculate momentum as the percentage change in price over the last 20 days\n    df['Momentum'] = df['close'].pct_change(periods=20)\n    \n    # Compute the rolling standard deviation of daily returns over the last 20 days\n    df['Volatility'] = df['Return'].rolling(window=20).std()\n    \n    # Volatility-adjusted Momentum\n    df['HeuristicFactor'] = df['Momentum'] / df['Volatility']\n    \n    heuristics_matrix = df['HeuristicFactor'].dropna()\n    return heuristics_matrix",
          "objective": -0.011,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a novel alpha factor by combining moving averages of different lengths and the relative strength index (RSI) to produce a heuristics score for each date, which is expected to be indicative of future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    short_window = 10\n    long_window = 30\n    rsi_window = 14\n    \n    # Calculate moving averages\n    ma_short = df['close'].rolling(window=short_window).mean()\n    ma_long = df['close'].rolling(window=long_window).mean()\n    \n    # Calculate RSI\n    delta = df['close'].diff(1)\n    gain = delta.where(delta > 0, 0)\n    loss = -delta.where(delta < 0, 0)\n    avg_gain = gain.rolling(window=rsi_window).mean()\n    avg_loss = loss.rolling(window=rsi_window).mean()\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Generate heuristics matrix\n    heuristics_matrix = (ma_short - ma_long) * rsi\n    \n    return heuristics_matrix",
          "objective": -0.01062,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates the moving average of the daily return over a specified window and then computes the difference between this moving average and the daily return to generate alpha factors.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily returns\n    df['daily_return'] = df['close'].pct_change()\n    \n    # Moving average of the daily return\n    df['moving_avg'] = df['daily_return'].rolling(window=10).mean()\n    \n    # Generate the heuristic factor by taking the difference\n    heuristics_matrix = df['daily_return'] - df['moving_avg']\n    \n    # Return only the series of heuristic factors, dropping NaNs\n    return heuristics_matrix",
          "objective": -0.00758,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm involves calculating a novel alpha factor by combining the difference between the daily high and low prices with the ratio of closing price to volume, aiming to capture both volatility and value sentiment.",
          "code": "def heuristics_v2(df):\n    # Calculate the difference between high and low\n    hl_diff = df['high'] - df['low']\n    # Calculate the ratio of close to volume\n    close_volume_ratio = df['close'] / df['volume']\n    # Combine the two for a new heuristic\n    heuristics_matrix = (hl_diff * close_volume_ratio).rename('heuristic')\n    return heuristics_matrix",
          "objective": -0.00641,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a momentum-based alpha factor by first computing the 10-day and 30-day simple moving averages (SMA) of the closing prices, then subtracting the 30-day SMA from the 10-day SMA to indicate potential short-term versus long-term price trends.",
          "code": "def heuristics_v2(df):\n    sma_10 = df['close'].rolling(window=10).mean()\n    sma_30 = df['close'].rolling(window=30).mean()\n    heuristics_matrix = sma_10 - sma_30\n    return heuristics_matrix",
          "objective": -0.00462,
          "other_inf": null
     }
]