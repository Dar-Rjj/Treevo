[
     {
          "algorithm": "The new algorithm calculates a weighted sum of the square root of the ratio between closing and opening prices, the absolute difference between the natural logarithms of the highest and lowest prices, and the cube root of the trading amount over volume.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the square root of the close-to-open price ratio\n    sqrt_close_open_ratio = np.sqrt(df['close'] / df['open'])\n    \n    # Calculate the absolute difference between the natural logarithms of the high and low prices\n    abs_log_high_low_diff = np.abs(np.log(df['high']) - np.log(df['low']))\n    \n    # Calculate the cube root of the trading amount-to-volume ratio\n    cbrt_amount_volume = np.cbrt(df['amount'] / df['volume'])\n    \n    # Define weights for each component\n    w1, w2, w3 = 0.5, 0.3, 0.2\n    \n    # Combine the components into a single alpha factor\n    heuristics_matrix = w1 * sqrt_close_open_ratio + w2 * abs_log_high_low_diff + w3 * cbrt_amount_volume\n    \n    return heuristics_matrix",
          "objective": -0.02838,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of the cube root of the ratio between closing and opening prices, the absolute difference between the natural logarithms of the highest and lowest prices, and the square root of the trading amount over volume.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the cube root of the close-to-open price ratio\n    cbrt_close_open_ratio = np.cbrt(df['close'] / df['open'])\n    \n    # Calculate the absolute difference between the natural logarithms of the high and low prices\n    abs_log_high_low_diff = np.abs(np.log(df['high']) - np.log(df['low']))\n    \n    # Calculate the square root of the trading amount-to-volume ratio\n    sqrt_amount_volume = np.sqrt(df['amount'] / df['volume'])\n    \n    # Define weights for each component\n    w1, w2, w3 = 0.4, 0.4, 0.2\n    \n    # Combine the components into a single alpha factor\n    heuristics_matrix = w1 * cbrt_close_open_ratio + w2 * abs_log_high_low_diff + w3 * sqrt_amount_volume\n    \n    return heuristics_matrix",
          "objective": -0.02705,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor using the 30-day change in closing price, the average true range over the last 20 days, and the ratio of the 15-day average volume to the 120-day average volume.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Momentum signal: 30-day change in closing price\n    momentum = df['close'].pct_change(30)\n    \n    # Volatility: Average True Range (ATR) over the last 20 days\n    tr = df[['high', 'low', 'close']].apply(lambda x: max(x) - min(x), axis=1)\n    atr = tr.rolling(window=20).mean()\n    \n    # Volume-activity ratio: 15-day average volume divided by the 120-day average volume\n    avg_vol_15d = df['volume'].rolling(window=15).mean()\n    avg_vol_120d = df['volume'].rolling(window=120).mean()\n    vol_activity_ratio = avg_vol_15d / avg_vol_120d\n    \n    # Combine the calculated features into a single factor\n    heuristics_matrix = (momentum - atr) * vol_activity_ratio\n    \n    return heuristics_matrix",
          "objective": -0.02265,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor using the 20-day change in closing price, the average true range over the last 30 days, and the ratio of the 10-day average volume to the 90-day average volume.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Momentum signal: 20-day change in closing price\n    momentum = df['close'].pct_change(20)\n    \n    # Volatility: Average True Range (ATR) over the last 30 days\n    tr = df[['high', 'low', 'close']].apply(lambda x: max(x) - min(x), axis=1)\n    atr = tr.rolling(window=30).mean()\n    \n    # Volume-activity ratio: 10-day average volume divided by the 90-day average volume\n    avg_vol_10d = df['volume'].rolling(window=10).mean()\n    avg_vol_90d = df['volume'].rolling(window=90).mean()\n    vol_activity_ratio = avg_vol_10d / avg_vol_90d\n    \n    # Combine the calculated features into a single factor\n    heuristics_matrix = (momentum - atr) * vol_activity_ratio\n    \n    return heuristics_matrix",
          "objective": -0.0225,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of the ratio between closing and opening prices, the difference between the highest and lowest price, and the log of the trading amount over volume, to generate a unique alpha factor.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the close-to-open price ratio\n    close_open_ratio = df['close'] / df['open']\n    \n    # Calculate the high-low price spread\n    high_low_spread = df['high'] - df['low']\n    \n    # Calculate the natural logarithm of the trading amount-to-volume ratio\n    log_amount_volume = np.log(df['amount'] / df['volume'])\n    \n    # Define weights for each component\n    w1, w2, w3 = 0.4, 0.3, 0.3\n    \n    # Combine the components into a single alpha factor\n    heuristics_matrix = w1 * close_open_ratio + w2 * high_low_spread + w3 * log_amount_volume\n    \n    return heuristics_matrix",
          "objective": -0.02244,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a factor based on the weighted sum of the distance between the closing price and its 20-day exponential moving average, the ratio of days with positive to negative volume changes adjusted for the mean of the last 30 days' volume, and the standard deviation of daily price changes over the last 20 days.",
          "code": "def heuristics_v2(df):\n    df['ema_20'] = df['close'].ewm(span=20, adjust=False).mean()\n    df['distance_to_ema'] = abs(df['close'] - df['ema_20'])\n    df['positive_volume_days'] = (df['volume'].pct_change() > 0).rolling(window=30).sum()\n    df['negative_volume_days'] = (df['volume'].pct_change() < 0).rolling(window=30).sum()\n    df['volume_ratio_pos_neg_vol_mean_adjusted'] = df['positive_volume_days'] / (df['negative_volume_days'] + 1e-8) / df['volume'].rolling(window=30).mean()\n    df['price_std_dev'] = (df['high'] - df['low']).rolling(window=20).std()\n    df['composite_factor'] = (df['distance_to_ema'] * 0.4 + \n                              df['volume_ratio_pos_neg_vol_mean_adjusted'] * 0.3 + \n                              df['price_std_dev'] * 0.3)\n    heuristics_matrix = df['composite_factor'].copy()\n    return heuristics_matrix",
          "objective": -0.01839,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the mean of the open, high, low, and close prices, then subtracts the 30-day exponential moving average of the volume from it to generate a novel alpha factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    price_mean = df[['open', 'high', 'low', 'close']].mean(axis=1)\n    vol_30ema = df['volume'].ewm(span=30, adjust=False).mean()\n    heuristics_matrix = price_mean - vol_30ema\n    return heuristics_matrix",
          "objective": -0.01733,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a custom momentum indicator by incorporating the weighted average of the rate of change over different time periods, and then applies an exponential moving average to smooth the combined rate of change, resulting in a heuristics matrix.",
          "code": "def heuristics_v2(df):\n    def calculate_momentum(series, short_window, long_window):\n        short_roc = series.pct_change(short_window)\n        long_roc = series.pct_change(long_window)\n        combined_roc = (short_roc * 0.6 + long_roc * 0.4)\n        smoothed_roc = combined_roc.ewm(span=5, adjust=False).mean()\n        return smoothed_roc\n\n    heuristics_matrix = (calculate_momentum(df['close'], 5, 20) \n                        + calculate_momentum(df['volume'], 5, 20)) / 2\n    return heuristics_matrix",
          "objective": -0.01721,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the weighted average of the open, high, low, and close prices with weights 0.1, 0.3, 0.2, and 0.4, respectively, then adds the 5-day moving average of the volume to it to generate a novel alpha factor.",
          "code": "def heuristics_v2(df):\n    price_weighted_avg = df['open']*0.1 + df['high']*0.3 + df['low']*0.2 + df['close']*0.4\n    vol_5ma = df['volume'].rolling(window=5).mean()\n    heuristics_matrix = price_weighted_avg + vol_5ma\n    return heuristics_matrix",
          "objective": -0.01694,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the median of the open, high, low, and close prices, then subtracts the 20-day exponential moving average of the volume from it to generate a novel alpha factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    price_median = df[['open', 'high', 'low', 'close']].median(axis=1)\n    vol_20ema = df['volume'].ewm(span=20, adjust=False).mean()\n    heuristics_matrix = price_median - vol_20ema\n    return heuristics_matrix",
          "objective": -0.01688,
          "other_inf": null
     }
]