[
     {
          "algorithm": "The new algorithm calculates a weighted sum of the square root of the close-to-open price ratio, the natural logarithm difference between the highest and lowest prices, and the square root of the sum of trading amount and volume.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the square root of the close-to-open price ratio\n    sqrt_close_open_ratio = (df['close'] / df['open']) ** 0.5\n    \n    # Calculate the natural logarithm difference between the high and low prices\n    log_high_low_diff = np.log(df['high']) - np.log(df['low'])\n    \n    # Calculate the square root of the sum of trading amount and volume\n    sqrt_amount_volume = (df['amount'] + df['volume']) ** 0.5\n    \n    # Define weights for each component\n    w1, w2, w3 = 0.5, 0.3, 0.2\n    \n    # Combine the components into a single alpha factor\n    heuristics_matrix = w1 * sqrt_close_open_ratio + w2 * log_high_low_diff + w3 * sqrt_amount_volume\n    \n    return heuristics_matrix",
          "objective": -0.04478,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of the exponential moving average (EMA) of the return, the EMA of the ratio between the highest and lowest prices, and the EMA of the trading amount.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the daily return\n    returns = df['close'].pct_change()\n    \n    # Exponential Moving Average (EMA) of the return\n    ema_returns = returns.ewm(span=20).mean()\n    \n    # EMA of the ratio between the highest and lowest prices\n    high_low_ratio = df['high'] / df['low']\n    ema_high_low_ratio = high_low_ratio.ewm(span=20).mean()\n    \n    # EMA of the trading amount\n    ema_amount = df['amount'].ewm(span=20).mean()\n    \n    # Define weights for each component\n    w1, w2, w3 = 0.4, 0.4, 0.2\n    \n    # Combine the components into a single alpha factor\n    heuristics_matrix = w1 * ema_returns + w2 * ema_high_low_ratio + w3 * ema_amount\n    \n    return heuristics_matrix",
          "objective": -0.04457,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of the logarithm of the close-to-open price ratio, the reciprocal of the natural logarithms difference between the highest and lowest prices, and the cube root of the product of trading amount and volume.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the logarithm of the close-to-open price ratio\n    log_close_open_ratio = np.log(df['close'] / df['open'])\n    \n    # Calculate the reciprocal of the natural logarithms difference between the high and low prices\n    inv_log_high_low_diff = 1 / (np.abs(np.log(df['high']) - np.log(df['low'])))\n    \n    # Calculate the cube root of the product of trading amount and volume\n    cbrt_amount_volume = (df['amount'] * df['volume']) ** (1/3)\n    \n    # Define weights for each component\n    w1, w2, w3 = 0.4, 0.4, 0.2\n    \n    # Combine the components into a single alpha factor\n    heuristics_matrix = w1 * log_close_open_ratio + w2 * inv_log_high_low_diff + w3 * cbrt_amount_volume\n    \n    return heuristics_matrix",
          "objective": -0.03381,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm modifies the original by introducing a sine transformation to the close-to-open price ratio, applying a logarithmic scale adjustment to the high-low price difference, and incorporating a cubic root of the trading amount over volume, with adjusted weights for each component.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Apply sine transformation to the cube root of the close-to-open price ratio\n    sin_cbrt_close_open_ratio = np.sin(np.cbrt(df['close'] / df['open']))\n    \n    # Apply a logarithmic scale adjustment to the absolute difference between high and low prices\n    log_adj_high_low_diff = np.log1p(np.abs(df['high'] - df['low']))\n    \n    # Calculate the cubic root of the trading amount-to-volume ratio\n    cbrt_amount_volume = np.cbrt(df['amount'] / df['volume'])\n    \n    # Define new weights for each component\n    w1, w2, w3 = 0.5, 0.3, 0.2\n    \n    # Combine the components into a single alpha factor\n    heuristics_matrix = w1 * sin_cbrt_close_open_ratio + w2 * log_adj_high_low_diff + w3 * cbrt_amount_volume\n    \n    return heuristics_matrix",
          "objective": -0.02955,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of the exponential of the ratio between closing and opening prices, the cube of the absolute difference between the highest and lowest prices, and the trading volume over amount.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the exponential of the close-to-open price ratio\n    exp_close_open_ratio = np.exp(df['close'] / df['open'])\n    \n    # Calculate the cube of the absolute difference between the high and low prices\n    cube_high_low_diff = np.cbrt(np.abs(df['high'] - df['low']))\n    \n    # Calculate the trading volume-to-amount ratio\n    volume_amount_ratio = df['volume'] / df['amount']\n    \n    # Define weights for each component\n    w1, w2, w3 = 0.4, 0.4, 0.2\n    \n    # Combine the components into a single alpha factor\n    heuristics_matrix = w1 * exp_close_open_ratio + w2 * cube_high_low_diff + w3 * volume_amount_ratio\n    \n    return heuristics_matrix",
          "objective": -0.02908,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of the exponential of the close-to-open price ratio, the square of the absolute difference between the natural logarithms of the highest and lowest prices, and the fourth root of the trading amount over volume.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the exponential of the close-to-open price ratio\n    exp_close_open_ratio = np.exp(df['close'] / df['open'])\n    \n    # Calculate the square of the absolute difference between the natural logarithms of the high and low prices\n    sq_abs_log_high_low_diff = (np.abs(np.log(df['high']) - np.log(df['low']))) ** 2\n    \n    # Calculate the fourth root of the trading amount-to-volume ratio\n    fourth_rt_amount_volume = (df['amount'] / df['volume']) ** (1/4)\n    \n    # Define weights for each component\n    w1, w2, w3 = 0.5, 0.3, 0.2\n    \n    # Combine the components into a single alpha factor\n    heuristics_matrix = w1 * exp_close_open_ratio + w2 * sq_abs_log_high_low_diff + w3 * fourth_rt_amount_volume\n    \n    return heuristics_matrix",
          "objective": -0.02901,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted geometric mean of the ratio between closing and opening prices, the relative high-low price spread (normalized by the opening price), and the log of the trading amount over volume, to generate a unique and interpretable alpha factor.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the close-to-open price ratio\n    close_open_ratio = df['close'] / df['open']\n    \n    # Calculate the high-low price spread normalized by the opening price\n    high_low_spread_normalized = (df['high'] - df['low']) / df['open']\n    \n    # Calculate the natural logarithm of the trading amount-to-volume ratio\n    log_amount_volume = np.log(df['amount'] / df['volume'])\n    \n    # Define weights for each component\n    w1, w2, w3 = 0.4, 0.3, 0.3\n    \n    # Combine the components into a single alpha factor using a weighted geometric mean\n    heuristics_matrix = np.power(close_open_ratio, w1) * np.power(high_low_spread_normalized, w2) * np.power(np.exp(log_amount_volume), w3)\n    \n    return heuristics_matrix",
          "objective": -0.029,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of the square of the ratio between closing and opening prices, the mean absolute difference between the natural logarithms of the highest and lowest prices over a rolling window, and the cube root of the trading amount over volume.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the square of the close-to-open price ratio\n    square_close_open_ratio = (df['close'] / df['open']) ** 2\n    \n    # Calculate the mean absolute difference between the natural logarithms of the high and low prices over a 5-day rolling window\n    abs_log_high_low_diff = np.abs(np.log(df['high']) - np.log(df['low']))\n    mean_abs_log_high_low_diff = abs_log_high_low_diff.rolling(window=5).mean()\n    \n    # Calculate the cube root of the trading amount-to-volume ratio\n    cbrt_amount_volume = np.cbrt(df['amount'] / df['volume'])\n    \n    # Define weights for each component\n    w1, w2, w3 = 0.4, 0.4, 0.2\n    \n    # Combine the components into a single alpha factor\n    heuristics_matrix = w1 * square_close_open_ratio + w2 * mean_abs_log_high_low_diff + w3 * cbrt_amount_volume\n    \n    return heuristics_matrix",
          "objective": -0.02852,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of the square root of the ratio between closing and opening prices, the absolute difference between the natural logarithms of the highest and lowest prices, and the cube root of the trading amount over volume.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the square root of the close-to-open price ratio\n    sqrt_close_open_ratio = np.sqrt(df['close'] / df['open'])\n    \n    # Calculate the absolute difference between the natural logarithms of the high and low prices\n    abs_log_high_low_diff = np.abs(np.log(df['high']) - np.log(df['low']))\n    \n    # Calculate the cube root of the trading amount-to-volume ratio\n    cbrt_amount_volume = np.cbrt(df['amount'] / df['volume'])\n    \n    # Define weights for each component\n    w1, w2, w3 = 0.5, 0.3, 0.2\n    \n    # Combine the components into a single alpha factor\n    heuristics_matrix = w1 * sqrt_close_open_ratio + w2 * abs_log_high_low_diff + w3 * cbrt_amount_volume\n    \n    return heuristics_matrix",
          "objective": -0.02838,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of the cube root of the ratio between closing and opening prices, the square of the absolute difference between the natural logarithms of the highest and lowest prices, and the natural logarithm of the trading amount over volume.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the cube root of the close-to-open price ratio\n    cbrt_close_open_ratio = np.cbrt(df['close'] / df['open'])\n    \n    # Calculate the square of the absolute difference between the natural logarithms of the high and low prices\n    sq_abs_log_high_low_diff = np.square(np.abs(np.log(df['high']) - np.log(df['low'])))\n    \n    # Calculate the natural logarithm of the trading amount-to-volume ratio\n    log_amount_volume = np.log(df['amount'] / df['volume'])\n    \n    # Define weights for each component\n    w1, w2, w3 = 0.4, 0.4, 0.2\n    \n    # Combine the components into a single alpha factor\n    heuristics_matrix = w1 * cbrt_close_open_ratio + w2 * sq_abs_log_high_low_diff + w3 * log_amount_volume\n    \n    return heuristics_matrix",
          "objective": -0.02777,
          "other_inf": null
     }
]