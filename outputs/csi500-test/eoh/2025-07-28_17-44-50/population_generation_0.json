[
     {
          "algorithm": "The algorithm involves calculating a unique combination of price and volume indicators to generate alpha factors that aim to predict future stock returns, following steps such as extracting momentum signals, volatility measurements, and volume-activity ratios.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Momentum signal: 10-day change in closing price\n    momentum = df['close'].pct_change(10)\n    \n    # Volatility: Standard deviation of daily return over the last 30 days\n    volatility = df['close'].pct_change().rolling(window=30).std()\n    \n    # Volume-activity ratio: Average trading volume for the last 5 days divided by the 60-day average volume\n    avg_vol_5d = df['volume'].rolling(window=5).mean()\n    avg_vol_60d = df['volume'].rolling(window=60).mean()\n    vol_activity_ratio = avg_vol_5d / avg_vol_60d\n    \n    # Combine the calculated features into a single factor\n    heuristics_matrix = (momentum - volatility) * vol_activity_ratio\n    \n    return heuristics_matrix",
          "objective": -0.01667,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates the average of the open, high, low, and close prices, then subtracts the 20-day moving average of the volume from it to generate a novel alpha factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    price_avg = df[['open', 'high', 'low', 'close']].mean(axis=1)\n    vol_20ma = df['volume'].rolling(window=20).mean()\n    heuristics_matrix = price_avg - vol_20ma\n    return heuristics_matrix",
          "objective": -0.01565,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a custom momentum indicator by combining the rate of change over different time periods and then applies a smoothing technique to enhance its predictive power, resulting in a heuristics matrix that captures novel patterns in stock returns.",
          "code": "def heuristics_v2(df):\n    def calculate_momentum(series, short_window, long_window):\n        short_roc = series.pct_change(short_window)\n        long_roc = series.pct_change(long_window)\n        combined_roc = (short_roc + long_roc) / 2\n        smoothed_roc = combined_roc.rolling(window=5).mean()\n        return smoothed_roc\n\n    heuristics_matrix = (calculate_momentum(df['close'], 5, 20) \n                        + calculate_momentum(df['volume'], 5, 20)) / 2\n    return heuristics_matrix",
          "objective": -0.01297,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a composite factor by combining momentum, volatility, and trading volume signals to predict future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate price return over the last 5 days\n    df['momentum'] = df['close'].pct_change(periods=5)\n    \n    # Calculate average daily return over the last 10 days\n    df['avg_return_10d'] = df['close'].pct_change().rolling(window=10).mean()\n    \n    # Calculate standard deviation of returns over the last 10 days as a measure of volatility\n    df['volatility'] = df['close'].pct_change().rolling(window=10).std()\n    \n    # Calculate the ratio of current volume to the 30-day average volume\n    df['volume_ratio'] = df['volume'] / df['volume'].rolling(window=30).mean()\n    \n    # Composite factor: weighted sum of momentum, inverse of volatility, and volume ratio\n    df['composite_factor'] = (df['momentum'] + \n                              1/df['volatility'] + \n                              df['volume_ratio'])\n    \n    heuristics_matrix = df['composite_factor'].copy()\n    \n    return heuristics_matrix",
          "objective": -0.01214,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a momentum-based alpha factor by considering the difference between the average of the last 5 days' closing prices and the average of the previous 10 days' closing prices, then adjusts this difference by the ratio of the average volume over the past 20 days to the total amount traded in the most recent day.",
          "code": "def heuristics_v2(df):\n    # Calculate the averages\n    avg_close_5d = df['close'].rolling(window=5).mean()\n    avg_close_10d_prior = df['close'].shift(5).rolling(window=10).mean()\n    avg_volume_20d = df['volume'].rolling(window=20).mean()\n    \n    # Compute the momentum indicator\n    momentum_indicator = (avg_close_5d - avg_close_10d_prior) / (df['amount'] / avg_volume_20d)\n    \n    heuristics_matrix = momentum_indicator\n    return heuristics_matrix",
          "objective": -0.01055,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm involves calculating a composite factor by combining momentum, volatility, and trading volume indicators from the input DataFrame to generate a unique time series predictive of future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    momentum = df['close'].pct_change(periods=10)\n    volatility = df['close'].rolling(window=30).std()\n    volume_sma_ratio = df['volume'] / df['volume'].rolling(window=20).mean()\n    heuristics_matrix = (momentum + 1/volatility + volume_sma_ratio) / 3\n    return heuristics_matrix",
          "objective": -0.01033,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm constructs a novel heuristic factor by computing the difference between the average of the 5-day high and low prices, then subtracting the 20-day moving average of the closing price to generate a factor that aims to predict future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    avg_high_low = (df['high'].rolling(window=5).mean() + df['low'].rolling(window=5).mean()) / 2\n    ma_close_20 = df['close'].rolling(window=20).mean()\n    heuristics_matrix = avg_high_low - ma_close_20\n    return heuristics_matrix",
          "objective": -0.00885,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a momentum-like factor by comparing the current close price to the average of the last 10 days' closing prices and then applies a smoothing technique using exponential weighting for stabilization.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    df['close_10_avg'] = df['close'].rolling(window=10).mean()\n    df['momentum'] = (df['close'] - df['close_10_avg']) / df['close_10_avg']\n    df['smoothed_momentum'] = df['momentum'].ewm(span=5, adjust=False).mean()\n    heuristics_matrix = df['smoothed_momentum'].dropna()\n    return heuristics_matrix",
          "objective": -0.00847,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm constructs a novel alpha factor by computing the difference between the 10-day and 30-day moving averages of the closing prices, then multiplying this difference by the ratio of the 5-day average volume to the 20-day average volume.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    close_10 = df['close'].rolling(window=10).mean()\n    close_30 = df['close'].rolling(window=30).mean()\n    volume_5 = df['volume'].rolling(window=5).mean()\n    volume_20 = df['volume'].rolling(window=20).mean()\n    \n    price_diff = close_10 - close_30\n    volume_ratio = volume_5 / volume_20\n    \n    heuristics_matrix = price_diff * volume_ratio\n    return heuristics_matrix",
          "objective": -0.00613,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a unique factor by analyzing the weighted differences between moving averages of different spans, aiming to capture momentum and mean-reversion tendencies within the data.",
          "code": "def heuristics_v2(df):\n    short_window = 5\n    medium_window = 20\n    long_window = 60\n    df['short_ma'] = df['close'].rolling(window=short_window).mean()\n    df['medium_ma'] = df['close'].rolling(window=medium_window).mean()\n    df['long_ma'] = df['close'].rolling(window=long_window).mean()\n    heuristics_matrix = (df['short_ma'] - df['medium_ma']) * 0.5 + (df['medium_ma'] - df['long_ma']) * 0.3 + (df['short_ma'] - df['long_ma']) * 0.2\n    return heuristics_matrix",
          "objective": -0.00479,
          "other_inf": null
     }
]