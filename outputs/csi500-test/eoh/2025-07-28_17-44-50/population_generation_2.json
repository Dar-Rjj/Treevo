[
     {
          "algorithm": "The new algorithm calculates a weighted sum of the exponential of the close-to-open price ratio, the square of the absolute difference between the natural logarithms of the highest and lowest prices, and the fourth root of the trading amount over volume.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the exponential of the close-to-open price ratio\n    exp_close_open_ratio = np.exp(df['close'] / df['open'])\n    \n    # Calculate the square of the absolute difference between the natural logarithms of the high and low prices\n    sq_abs_log_high_low_diff = (np.abs(np.log(df['high']) - np.log(df['low']))) ** 2\n    \n    # Calculate the fourth root of the trading amount-to-volume ratio\n    fourth_rt_amount_volume = (df['amount'] / df['volume']) ** (1/4)\n    \n    # Define weights for each component\n    w1, w2, w3 = 0.5, 0.3, 0.2\n    \n    # Combine the components into a single alpha factor\n    heuristics_matrix = w1 * exp_close_open_ratio + w2 * sq_abs_log_high_low_diff + w3 * fourth_rt_amount_volume\n    \n    return heuristics_matrix",
          "objective": -0.02901,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted geometric mean of the ratio between closing and opening prices, the relative high-low price spread (normalized by the opening price), and the log of the trading amount over volume, to generate a unique and interpretable alpha factor.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the close-to-open price ratio\n    close_open_ratio = df['close'] / df['open']\n    \n    # Calculate the high-low price spread normalized by the opening price\n    high_low_spread_normalized = (df['high'] - df['low']) / df['open']\n    \n    # Calculate the natural logarithm of the trading amount-to-volume ratio\n    log_amount_volume = np.log(df['amount'] / df['volume'])\n    \n    # Define weights for each component\n    w1, w2, w3 = 0.4, 0.3, 0.3\n    \n    # Combine the components into a single alpha factor using a weighted geometric mean\n    heuristics_matrix = np.power(close_open_ratio, w1) * np.power(high_low_spread_normalized, w2) * np.power(np.exp(log_amount_volume), w3)\n    \n    return heuristics_matrix",
          "objective": -0.029,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of the square root of the ratio between closing and opening prices, the absolute difference between the natural logarithms of the highest and lowest prices, and the cube root of the trading amount over volume.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the square root of the close-to-open price ratio\n    sqrt_close_open_ratio = np.sqrt(df['close'] / df['open'])\n    \n    # Calculate the absolute difference between the natural logarithms of the high and low prices\n    abs_log_high_low_diff = np.abs(np.log(df['high']) - np.log(df['low']))\n    \n    # Calculate the cube root of the trading amount-to-volume ratio\n    cbrt_amount_volume = np.cbrt(df['amount'] / df['volume'])\n    \n    # Define weights for each component\n    w1, w2, w3 = 0.5, 0.3, 0.2\n    \n    # Combine the components into a single alpha factor\n    heuristics_matrix = w1 * sqrt_close_open_ratio + w2 * abs_log_high_low_diff + w3 * cbrt_amount_volume\n    \n    return heuristics_matrix",
          "objective": -0.02838,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of the cube root of the ratio between closing and opening prices, the square of the absolute difference between the natural logarithms of the highest and lowest prices, and the natural logarithm of the trading amount over volume.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the cube root of the close-to-open price ratio\n    cbrt_close_open_ratio = np.cbrt(df['close'] / df['open'])\n    \n    # Calculate the square of the absolute difference between the natural logarithms of the high and low prices\n    sq_abs_log_high_low_diff = np.square(np.abs(np.log(df['high']) - np.log(df['low'])))\n    \n    # Calculate the natural logarithm of the trading amount-to-volume ratio\n    log_amount_volume = np.log(df['amount'] / df['volume'])\n    \n    # Define weights for each component\n    w1, w2, w3 = 0.4, 0.4, 0.2\n    \n    # Combine the components into a single alpha factor\n    heuristics_matrix = w1 * cbrt_close_open_ratio + w2 * sq_abs_log_high_low_diff + w3 * log_amount_volume\n    \n    return heuristics_matrix",
          "objective": -0.02777,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted geometric mean of the ratio between closing and opening prices, the relative high-low price spread (normalized by the closing price), and the square root of the trading amount over volume, with updated weights for each component.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the close-to-open price ratio\n    close_open_ratio = df['close'] / df['open']\n    \n    # Calculate the high-low price spread normalized by the closing price\n    high_low_spread_normalized = (df['high'] - df['low']) / df['close']\n    \n    # Calculate the square root of the trading amount-to-volume ratio\n    sqrt_amount_volume = np.sqrt(df['amount'] / df['volume'])\n    \n    # Define weights for each component\n    w1, w2, w3 = 0.5, 0.2, 0.3\n    \n    # Combine the components into a single alpha factor using a weighted geometric mean\n    heuristics_matrix = np.power(close_open_ratio, w1) * np.power(high_low_spread_normalized, w2) * np.power(sqrt_amount_volume, w3)\n    \n    return heuristics_matrix",
          "objective": -0.02766,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of the cube root of the ratio between closing and opening prices, the absolute difference between the natural logarithms of the highest and lowest prices, and the square root of the trading amount over volume.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the cube root of the close-to-open price ratio\n    cbrt_close_open_ratio = np.cbrt(df['close'] / df['open'])\n    \n    # Calculate the absolute difference between the natural logarithms of the high and low prices\n    abs_log_high_low_diff = np.abs(np.log(df['high']) - np.log(df['low']))\n    \n    # Calculate the square root of the trading amount-to-volume ratio\n    sqrt_amount_volume = np.sqrt(df['amount'] / df['volume'])\n    \n    # Define weights for each component\n    w1, w2, w3 = 0.4, 0.4, 0.2\n    \n    # Combine the components into a single alpha factor\n    heuristics_matrix = w1 * cbrt_close_open_ratio + w2 * abs_log_high_low_diff + w3 * sqrt_amount_volume\n    \n    return heuristics_matrix",
          "objective": -0.02705,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of the close-to-open price ratio, the average of high and low prices minus the closing price, and the square root of the trading amount over volume, to generate a unique alpha factor.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the close-to-open price ratio\n    close_open_ratio = df['close'] / df['open']\n    \n    # Calculate the difference between the average of high and low prices and the closing price\n    avg_high_low_close_diff = (df['high'] + df['low'])/2 - df['close']\n    \n    # Calculate the square root of the trading amount-to-volume ratio\n    sqrt_amount_volume = np.sqrt(df['amount'] / df['volume'])\n    \n    # Define weights for each component\n    w1, w2, w3 = 0.5, 0.25, 0.25\n    \n    # Combine the components into a single alpha factor\n    heuristics_matrix = w1 * close_open_ratio + w2 * avg_high_low_close_diff + w3 * sqrt_amount_volume\n    \n    return heuristics_matrix",
          "objective": -0.02548,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor using the 20-day change in closing price, the average true range over the last 10 days, and the ratio of the 30-day average volume to the 90-day average volume.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Momentum signal: 20-day change in closing price\n    momentum = df['close'].pct_change(20)\n    \n    # Volatility: Average True Range (ATR) over the last 10 days\n    tr = df[['high', 'low', 'close']].apply(lambda x: max(x) - min(x), axis=1)\n    atr = tr.rolling(window=10).mean()\n    \n    # Volume-activity ratio: 30-day average volume divided by the 90-day average volume\n    avg_vol_30d = df['volume'].rolling(window=30).mean()\n    avg_vol_90d = df['volume'].rolling(window=90).mean()\n    vol_activity_ratio = avg_vol_30d / avg_vol_90d\n    \n    # Combine the calculated features into a single factor\n    heuristics_matrix = (momentum - atr) * vol_activity_ratio\n    \n    return heuristics_matrix",
          "objective": -0.0229,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor using the 30-day change in closing price, the average true range over the last 20 days, and the ratio of the 15-day average volume to the 120-day average volume.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Momentum signal: 30-day change in closing price\n    momentum = df['close'].pct_change(30)\n    \n    # Volatility: Average True Range (ATR) over the last 20 days\n    tr = df[['high', 'low', 'close']].apply(lambda x: max(x) - min(x), axis=1)\n    atr = tr.rolling(window=20).mean()\n    \n    # Volume-activity ratio: 15-day average volume divided by the 120-day average volume\n    avg_vol_15d = df['volume'].rolling(window=15).mean()\n    avg_vol_120d = df['volume'].rolling(window=120).mean()\n    vol_activity_ratio = avg_vol_15d / avg_vol_120d\n    \n    # Combine the calculated features into a single factor\n    heuristics_matrix = (momentum - atr) * vol_activity_ratio\n    \n    return heuristics_matrix",
          "objective": -0.02265,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor using the 20-day change in closing price, the average true range over the last 30 days, and the ratio of the 10-day average volume to the 90-day average volume.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Momentum signal: 20-day change in closing price\n    momentum = df['close'].pct_change(20)\n    \n    # Volatility: Average True Range (ATR) over the last 30 days\n    tr = df[['high', 'low', 'close']].apply(lambda x: max(x) - min(x), axis=1)\n    atr = tr.rolling(window=30).mean()\n    \n    # Volume-activity ratio: 10-day average volume divided by the 90-day average volume\n    avg_vol_10d = df['volume'].rolling(window=10).mean()\n    avg_vol_90d = df['volume'].rolling(window=90).mean()\n    vol_activity_ratio = avg_vol_10d / avg_vol_90d\n    \n    # Combine the calculated features into a single factor\n    heuristics_matrix = (momentum - atr) * vol_activity_ratio\n    \n    return heuristics_matrix",
          "objective": -0.0225,
          "other_inf": null
     }
]