[
     {
          "algorithm": "The new algorithm calculates a weighted sum of the square root of the close-to-open price ratio, the natural logarithm difference between the highest and lowest prices, and the square root of the sum of trading amount and volume.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the square root of the close-to-open price ratio\n    sqrt_close_open_ratio = (df['close'] / df['open']) ** 0.5\n    \n    # Calculate the natural logarithm difference between the high and low prices\n    log_high_low_diff = np.log(df['high']) - np.log(df['low'])\n    \n    # Calculate the square root of the sum of trading amount and volume\n    sqrt_amount_volume = (df['amount'] + df['volume']) ** 0.5\n    \n    # Define weights for each component\n    w1, w2, w3 = 0.5, 0.3, 0.2\n    \n    # Combine the components into a single alpha factor\n    heuristics_matrix = w1 * sqrt_close_open_ratio + w2 * log_high_low_diff + w3 * sqrt_amount_volume\n    \n    return heuristics_matrix",
          "objective": -0.04478,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of the exponential moving average (EMA) of the return, the EMA of the ratio between the highest and lowest prices, and the EMA of the trading amount.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the daily return\n    returns = df['close'].pct_change()\n    \n    # Exponential Moving Average (EMA) of the return\n    ema_returns = returns.ewm(span=20).mean()\n    \n    # EMA of the ratio between the highest and lowest prices\n    high_low_ratio = df['high'] / df['low']\n    ema_high_low_ratio = high_low_ratio.ewm(span=20).mean()\n    \n    # EMA of the trading amount\n    ema_amount = df['amount'].ewm(span=20).mean()\n    \n    # Define weights for each component\n    w1, w2, w3 = 0.4, 0.4, 0.2\n    \n    # Combine the components into a single alpha factor\n    heuristics_matrix = w1 * ema_returns + w2 * ema_high_low_ratio + w3 * ema_amount\n    \n    return heuristics_matrix",
          "objective": -0.04457,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a factor based on the exponential of the close-to-open price ratio, the square root of the absolute difference between high and low prices, and the natural logarithm of the trading amount divided by the cube root of volume, with specific weights assigned to each component.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the exponential of the close-to-open price ratio\n    exp_close_open_ratio = np.exp(df['close'] / df['open'])\n    \n    # Calculate the square root of the absolute difference between high and low prices\n    sqrt_high_low_diff = np.sqrt(np.abs(df['high'] - df['low']))\n    \n    # Calculate the natural logarithm of the trading amount divided by the cube root of volume\n    log_amount_cbrt_volume = np.log(df['amount'] / (df['volume'] ** (1/3)))\n    \n    # Define weights for each component\n    w1, w2, w3 = 0.4, 0.3, 0.3\n    \n    # Combine the components into a single alpha factor\n    heuristics_matrix = w1 * exp_close_open_ratio + w2 * sqrt_high_low_diff + w3 * log_amount_cbrt_volume\n    \n    return heuristics_matrix",
          "objective": -0.03731,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a factor based on the square of the close-to-open price ratio, the cube root of the absolute difference between high and low prices, and the logarithm base 10 of the trading amount divided by the square root of volume, with updated weights for each component.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the square of the close-to-open price ratio\n    square_close_open_ratio = (df['close'] / df['open']) ** 2\n    \n    # Calculate the cube root of the absolute difference between high and low prices\n    cbrt_high_low_diff = np.cbrt(np.abs(df['high'] - df['low']))\n    \n    # Calculate the logarithm base 10 of the trading amount divided by the square root of volume\n    log10_amount_sqrt_volume = np.log10(df['amount'] / np.sqrt(df['volume']))\n    \n    # Define weights for each component\n    w1, w2, w3 = 0.5, 0.2, 0.3\n    \n    # Combine the components into a single alpha factor\n    heuristics_matrix = w1 * square_close_open_ratio + w2 * cbrt_high_low_diff + w3 * log10_amount_sqrt_volume\n    \n    return heuristics_matrix",
          "objective": -0.03603,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of the logarithm of the close-to-open price ratio, the reciprocal of the natural logarithms difference between the highest and lowest prices, and the cube root of the product of trading amount and volume.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the logarithm of the close-to-open price ratio\n    log_close_open_ratio = np.log(df['close'] / df['open'])\n    \n    # Calculate the reciprocal of the natural logarithms difference between the high and low prices\n    inv_log_high_low_diff = 1 / (np.abs(np.log(df['high']) - np.log(df['low'])))\n    \n    # Calculate the cube root of the product of trading amount and volume\n    cbrt_amount_volume = (df['amount'] * df['volume']) ** (1/3)\n    \n    # Define weights for each component\n    w1, w2, w3 = 0.4, 0.4, 0.2\n    \n    # Combine the components into a single alpha factor\n    heuristics_matrix = w1 * log_close_open_ratio + w2 * inv_log_high_low_diff + w3 * cbrt_amount_volume\n    \n    return heuristics_matrix",
          "objective": -0.03381,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a factor based on the square of the ratio between closing and opening prices, the square root of the difference between the highest and lowest prices, and the logarithm of the trading volume, with unique weights for each component.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the square of the close-to-open price ratio\n    sq_close_open_ratio = (df['close'] / df['open']) ** 2\n    \n    # Calculate the square root of the absolute difference between the high and low prices\n    sqrt_high_low_diff = np.sqrt(np.abs(df['high'] - df['low']))\n    \n    # Calculate the logarithm of the trading volume\n    log_volume = np.log(df['volume'])\n    \n    # Define weights for each component\n    w1, w2, w3 = 0.6, 0.3, 0.1\n    \n    # Combine the components into a single alpha factor\n    heuristics_matrix = w1 * sq_close_open_ratio + w2 * sqrt_high_low_diff + w3 * log_volume\n    \n    return heuristics_matrix",
          "objective": -0.03342,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a weighted sum of the exponential moving average of the close-to-open price ratio, the square of the natural logarithms difference between the highest and lowest prices, and the square root of the product of trading amount and volume.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the exponential moving average of the close-to-open price ratio with a span of 5\n    ema_close_open_ratio = df['close'] / df['open'].ewm(span=5, adjust=False).mean()\n    \n    # Calculate the square of the natural logarithms difference between the high and low prices\n    sqr_log_high_low_diff = (np.log(df['high']) - np.log(df['low'])) ** 2\n    \n    # Calculate the square root of the product of trading amount and volume\n    sqrt_amount_volume = np.sqrt(df['amount'] * df['volume'])\n    \n    # Define weights for each component\n    w1, w2, w3 = 0.5, 0.3, 0.2\n    \n    # Combine the components into a single alpha factor\n    heuristics_matrix = w1 * ema_close_open_ratio + w2 * sqr_log_high_low_diff + w3 * sqrt_amount_volume\n    \n    return heuristics_matrix",
          "objective": -0.03331,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of the cube root of the close-to-open price ratio, the natural logarithm difference between the closing and opening prices, and the cube root of the product of trading amount and volume.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the cube root of the close-to-open price ratio\n    cbrt_close_open_ratio = (df['close'] / df['open']) ** (1/3)\n    \n    # Calculate the natural logarithm difference between the closing and opening prices\n    log_close_open_diff = np.log(df['close']) - np.log(df['open'])\n    \n    # Calculate the cube root of the product of trading amount and volume\n    cbrt_amount_volume = (df['amount'] * df['volume']) ** (1/3)\n    \n    # Define weights for each component\n    w1, w2, w3 = 0.4, 0.4, 0.2\n    \n    # Combine the components into a single alpha factor\n    heuristics_matrix = w1 * cbrt_close_open_ratio + w2 * log_close_open_diff + w3 * cbrt_amount_volume\n    \n    return heuristics_matrix",
          "objective": -0.03305,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm modifies the original by introducing a sine transformation to the close-to-open price ratio, applying a logarithmic scale adjustment to the high-low price difference, and incorporating a cubic root of the trading amount over volume, with adjusted weights for each component.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Apply sine transformation to the cube root of the close-to-open price ratio\n    sin_cbrt_close_open_ratio = np.sin(np.cbrt(df['close'] / df['open']))\n    \n    # Apply a logarithmic scale adjustment to the absolute difference between high and low prices\n    log_adj_high_low_diff = np.log1p(np.abs(df['high'] - df['low']))\n    \n    # Calculate the cubic root of the trading amount-to-volume ratio\n    cbrt_amount_volume = np.cbrt(df['amount'] / df['volume'])\n    \n    # Define new weights for each component\n    w1, w2, w3 = 0.5, 0.3, 0.2\n    \n    # Combine the components into a single alpha factor\n    heuristics_matrix = w1 * sin_cbrt_close_open_ratio + w2 * log_adj_high_low_diff + w3 * cbrt_amount_volume\n    \n    return heuristics_matrix",
          "objective": -0.02955,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of the exponential of the ratio between closing and opening prices, the cube of the absolute difference between the highest and lowest prices, and the trading volume over amount.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the exponential of the close-to-open price ratio\n    exp_close_open_ratio = np.exp(df['close'] / df['open'])\n    \n    # Calculate the cube of the absolute difference between the high and low prices\n    cube_high_low_diff = np.cbrt(np.abs(df['high'] - df['low']))\n    \n    # Calculate the trading volume-to-amount ratio\n    volume_amount_ratio = df['volume'] / df['amount']\n    \n    # Define weights for each component\n    w1, w2, w3 = 0.4, 0.4, 0.2\n    \n    # Combine the components into a single alpha factor\n    heuristics_matrix = w1 * exp_close_open_ratio + w2 * cube_high_low_diff + w3 * volume_amount_ratio\n    \n    return heuristics_matrix",
          "objective": -0.02908,
          "other_inf": null
     }
]