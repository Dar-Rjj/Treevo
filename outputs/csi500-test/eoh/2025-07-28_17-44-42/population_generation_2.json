[
     {
          "algorithm": "The new algorithm calculates a weighted sum of the market features, using the momentum and volume as weights, but applies an exponential moving average to smooth the factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    momentum = df['close'].pct_change()\n    weight_close = 2 * (momentum * df['volume'])\n    smoothed_factor = (df['open'] + df['high'] + df['low'] + (df['close'] * weight_close) + df['amount']) / 5\n    heuristics_matrix = smoothed_factor.ewm(span=10, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.04389,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of the market features using volatility and volume as weights, then applies an exponential moving average for smoothing.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    volatility = df['close'].pct_change().rolling(window=10).std()\n    weight_close = 2 * (volatility * df['volume'])\n    smoothed_factor = (df['open'] + df['high'] + df['low'] + (df['close'] * weight_close) + df['amount']) / 5\n    heuristics_matrix = smoothed_factor.ewm(span=10, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.04342,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of the market features, using the momentum and volume as weights, then applies a simple moving average to smooth the factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    momentum = df['close'].pct_change()\n    weight_close = 2 * (momentum * df['volume'])\n    smoothed_factor = (df['open'] + df['high'] + df['low'] + (df['close'] * weight_close) + df['amount']) / 5\n    heuristics_matrix = smoothed_factor.rolling(window=10).mean()\n    return heuristics_matrix",
          "objective": -0.04303,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates an alpha factor by combining the 30-day moving average of the daily price momentum (close minus open) with the 60-period exponential moving average of the trading amount, and the 10-day rate of change in the closing price.",
          "code": "def heuristics_v2(df):\n    price_momentum = df['close'] - df['open']\n    ma_price_momentum_30 = price_momentum.rolling(window=30).mean()\n    ema_amount_60 = df['amount'].ewm(span=60, adjust=False).mean()\n    close_roc_10 = df['close'].pct_change(periods=10)\n    \n    heuristics_matrix = ma_price_momentum_30 + ema_amount_60 + close_roc_10\n    return heuristics_matrix",
          "objective": -0.04122,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a novel alpha factor by evaluating the interaction between the 20-day average of the price range (high minus low) and the 10-day moving average of the trading volume, then further smoothed by a 7-period moving average.",
          "code": "def heuristics_v2(df):\n    price_range = df['high'] - df['low']\n    avg_price_range_20 = price_range.rolling(window=20).mean()\n    avg_volume_10 = df['volume'].rolling(window=10).mean()\n    heuristics_matrix = (avg_price_range_20 * avg_volume_10).rolling(window=7).mean()\n    return heuristics_matrix",
          "objective": -0.03975,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of market features with adjusted momentum and volatility, employing unique weights and an extended smoothing period to generate distinct alpha factors.",
          "code": "def heuristics_v2(df):\n    momentum = df['close'].pct_change()\n    volatility = df['close'].rolling(window=40).std()  # Changed window from 30 to 40\n    weight_close = 4 * (momentum / volatility)  # Increased weight from 3 to 4\n    smoothed_factor = (df['open'] * 1.5 + df['high'] * 1.5 + df['low'] * 1.5 + (df['close'] * weight_close) + (df['volume'] * 2.5 * df['amount'])) / 9  # Adjusted weights and divisor\n    heuristics_matrix = smoothed_factor.ewm(span=20, adjust=False).mean()  # Changed span from 15 to 20\n    return heuristics_matrix",
          "objective": -0.02939,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm involves calculating a weighted sum of the market features adjusted by their momentum and volatility with altered weights, then applying an exponential moving average smoothing technique with a different span, where the weight for the closing price is now based on its relation to both the 30-day momentum and 50-day volatility, and the final smoothed factor uses a 20-day EMA.",
          "code": "def heuristics_v2(df):\n    momentum = df['close'].pct_change(periods=30)\n    volatility = df['close'].rolling(window=50).std()\n    weight_close = 1.2 * (momentum / volatility)\n    smoothed_factor = (df['open'] + df['high'] + df['low'] + (df['close'] * weight_close) + (df['volume'] * df['amount'])) / 6\n    heuristics_matrix = smoothed_factor.ewm(span=20, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.02938,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm involves calculating a weighted sum of the market features adjusted by their momentum and volatility, with a different set of weights and an extended smoothing window, to generate more robust and interpretable alpha factors.",
          "code": "def heuristics_v2(df):\n    momentum = df['close'].pct_change()\n    volatility = df['close'].rolling(window=30).std()  # Changed window from 20 to 30\n    weight_close = 3 * (momentum / volatility)  # Increased weight from 2 to 3\n    smoothed_factor = (df['open'] + df['high'] + df['low'] + (df['close'] * weight_close) + (df['volume'] * 2 * df['amount'])) / 7  # Adjusted weights and divisor\n    heuristics_matrix = smoothed_factor.ewm(span=15, adjust=False).mean()  # Changed span from 10 to 15\n    return heuristics_matrix",
          "objective": -0.02828,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm involves calculating a weighted sum of the market features adjusted by their momentum and volatility with altered weights, then applying an exponential moving average smoothing technique with a different span to generate more robust and interpretable alpha factors.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    momentum = df['close'].pct_change()\n    volatility = df['close'].rolling(window=25).std()\n    weight_close = 1.5 * (momentum / volatility)\n    smoothed_factor = (df['open'] + df['high'] + df['low'] + (df['close'] * weight_close) + (df['volume'] * df['amount'])) / 6\n    heuristics_matrix = smoothed_factor.ewm(span=15, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.02827,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm involves calculating a weighted sum of the market features adjusted by their momentum and volatility, then applying a smoothing technique to generate more robust and interpretable alpha factors.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    momentum = df['close'].pct_change()\n    volatility = df['close'].rolling(window=20).std()\n    weight_close = 2 * (momentum / volatility)\n    smoothed_factor = (df['open'] + df['high'] + df['low'] + (df['close'] * weight_close) + (df['volume'] * df['amount'])) / 5\n    heuristics_matrix = smoothed_factor.ewm(span=10, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.02732,
          "other_inf": null
     }
]