[
     {
          "algorithm": "The new algorithm calculates a novel alpha factor by evaluating the interaction between the 20-day average of the price range (high minus low) and the 10-day moving average of the trading volume, then further smoothed by a 7-period moving average.",
          "code": "def heuristics_v2(df):\n    price_range = df['high'] - df['low']\n    avg_price_range_20 = price_range.rolling(window=20).mean()\n    avg_volume_10 = df['volume'].rolling(window=10).mean()\n    heuristics_matrix = (avg_price_range_20 * avg_volume_10).rolling(window=7).mean()\n    return heuristics_matrix",
          "objective": -0.03975,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm involves calculating a weighted sum of the market features adjusted by their momentum and volatility, with a different set of weights and an extended smoothing window, to generate more robust and interpretable alpha factors.",
          "code": "def heuristics_v2(df):\n    momentum = df['close'].pct_change()\n    volatility = df['close'].rolling(window=30).std()  # Changed window from 20 to 30\n    weight_close = 3 * (momentum / volatility)  # Increased weight from 2 to 3\n    smoothed_factor = (df['open'] + df['high'] + df['low'] + (df['close'] * weight_close) + (df['volume'] * 2 * df['amount'])) / 7  # Adjusted weights and divisor\n    heuristics_matrix = smoothed_factor.ewm(span=15, adjust=False).mean()  # Changed span from 10 to 15\n    return heuristics_matrix",
          "objective": -0.02828,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm involves calculating a weighted sum of the market features adjusted by their momentum and volatility with altered weights, then applying an exponential moving average smoothing technique with a different span to generate more robust and interpretable alpha factors.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    momentum = df['close'].pct_change()\n    volatility = df['close'].rolling(window=25).std()\n    weight_close = 1.5 * (momentum / volatility)\n    smoothed_factor = (df['open'] + df['high'] + df['low'] + (df['close'] * weight_close) + (df['volume'] * df['amount'])) / 6\n    heuristics_matrix = smoothed_factor.ewm(span=15, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.02827,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm involves calculating a weighted sum of the market features adjusted by their momentum and volatility, then applying a smoothing technique to generate more robust and interpretable alpha factors.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    momentum = df['close'].pct_change()\n    volatility = df['close'].rolling(window=20).std()\n    weight_close = 2 * (momentum / volatility)\n    smoothed_factor = (df['open'] + df['high'] + df['low'] + (df['close'] * weight_close) + (df['volume'] * df['amount'])) / 5\n    heuristics_matrix = smoothed_factor.ewm(span=10, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.02732,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a novel alpha factor by assessing the interaction between price range (high minus low) and trading amount over a 10-day period, further smoothed by a 5-period moving average.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    price_range = df['high'] - df['low']\n    avg_price_range_10 = price_range.rolling(window=10).mean()\n    avg_amount_10 = df['amount'].rolling(window=10).mean()\n    heuristics_matrix = (avg_price_range_10 * avg_amount_10).rolling(window=5).mean()\n    return heuristics_matrix",
          "objective": -0.02671,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the factor by combining the ratio of the 50-day moving average of closing prices to the 200-day moving average, with the 100-day exponential moving average of the daily price range, and the 20-day change in trading volume.",
          "code": "def heuristics_v2(df):\n    ma_close_50 = df['close'].rolling(window=50).mean()\n    ma_close_200 = df['close'].rolling(window=200).mean()\n    ema_price_range_100 = ((df['high'] - df['low']).ewm(span=100, adjust=False).mean())\n    volume_change_20 = df['volume'].pct_change(periods=20)\n    \n    heuristics_matrix = (ma_close_50 / ma_close_200) + ema_price_range_100 + volume_change_20\n    return heuristics_matrix",
          "objective": -0.02455,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a factor by combining the ratio of the 14-day moving average of closing prices to the 200-day moving average, with the 30-day exponential moving average of the daily price range (high minus low), and the 5-day change in trading volume.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    ma_close_14 = df['close'].rolling(window=14).mean()\n    ma_close_200 = df['close'].rolling(window=200).mean()\n    ema_price_range_30 = ((df['high'] - df['low']).ewm(span=30, adjust=False).mean())\n    volume_change_5 = df['volume'].pct_change(periods=5)\n    \n    heuristics_matrix = (ma_close_14 / ma_close_200) + ema_price_range_30 + volume_change_5\n    return heuristics_matrix",
          "objective": -0.02443,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a factor by combining the ratio of the 20-day moving average of closing prices to the 100-day moving average, with the 50-day exponential moving average of the daily price range (high minus low), and the 10-day change in trading volume.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    ma_close_20 = df['close'].rolling(window=20).mean()\n    ma_close_100 = df['close'].rolling(window=100).mean()\n    ema_price_range_50 = ((df['high'] - df['low']).ewm(span=50, adjust=False).mean())\n    volume_change_10 = df['volume'].pct_change(periods=10)\n    \n    heuristics_matrix = (ma_close_20 / ma_close_100) + ema_price_range_50 + volume_change_10\n    return heuristics_matrix",
          "objective": -0.02247,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of the moving averages and momentum indicators, but now also incorporates volume data to better capture market sentiment, enhancing the predictive power of the heuristics matrix.}\n\n```python\ndef heuristics_v2(df):\n    def calculate_moving_average(series, window):\n        return series.rolling(window=window).mean()\n    \n    def calculate_momentum(series, window):\n        return series / series.shift(window) - 1\n    \n    # Calculate short and long-term moving averages for close prices\n    df['short_MA'] = calculate_moving_average(df['close'], window=5)\n    df['long_MA'] = calculate_moving_average(df['close'], window=20)\n    \n    # Calculate momentum for close prices over 5 and 20 days\n    df['momentum_5d'] = calculate_momentum(df['close'], window=5)\n    df['momentum_20d'] = calculate_momentum(df['close'], window=20)\n    \n    # Calculate the change in volume over 5 and 20 days\n    df['volume_change_5d'] = calculate_momentum(df['volume'], window=5)\n    df['volume_change_20d'] = calculate_momentum(df['volume'], window=20)\n    \n    # Weights for the linear combination (example values)\n    weights = {'short_MA': 0.3, 'long_MA': -0.2, 'momentum_5d': 0.4, 'momentum_20d': 0.6, 'volume_change_5d': 0.1, 'volume_change_20d': 0.1",
          "code": "def heuristics_v2(df):\n    def calculate_moving_average(series, window):\n        return series.rolling(window=window).mean()\n    \n    def calculate_momentum(series, window):\n        return series / series.shift(window) - 1\n    \n    # Calculate short and long-term moving averages for close prices\n    df['short_MA'] = calculate_moving_average(df['close'], window=5)\n    df['long_MA'] = calculate_moving_average(df['close'], window=20)\n    \n    # Calculate momentum for close prices over 5 and 20 days\n    df['momentum_5d'] = calculate_momentum(df['close'], window=5)\n    df['momentum_20d'] = calculate_momentum(df['close'], window=20)\n    \n    # Calculate the change in volume over 5 and 20 days\n    df['volume_change_5d'] = calculate_momentum(df['volume'], window=5)\n    df['volume_change_20d'] = calculate_momentum(df['volume'], window=20)\n    \n    # Weights for the linear combination (example values)\n    weights = {'short_MA': 0.3, 'long_MA': -0.2, 'momentum_5d': 0.4, 'momentum_20d': 0.6, 'volume_change_5d': 0.1, 'volume_change_20d': 0.1}\n    \n    # Generate the heuristics factor\n    heuristics_series = df.apply(lambda row: sum(row[col] * weights[col] for col in weights.keys()), axis=1)\n    \n    heuristics_matrix = heuristics_series.to_frame(name='heuristics_value')\n    \n    return heuristics_matrix",
          "objective": -0.02139,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies potential alpha factors by calculating the weighted sum of technical indicators, such as moving averages and price momentum, over different time horizons, to generate a heuristics matrix that aims to predict future stock returns.}\n\n```python\ndef heuristics_v2(df):\n    def calculate_moving_average(series, window):\n        return series.rolling(window=window).mean()\n    \n    def calculate_momentum(series, window):\n        return series / series.shift(window) - 1\n    \n    # Calculate short and long-term moving averages for close prices\n    df['short_MA'] = calculate_moving_average(df['close'], window=5)\n    df['long_MA'] = calculate_moving_average(df['close'], window=20)\n    \n    # Calculate momentum for close prices over 5 and 20 days\n    df['momentum_5d'] = calculate_momentum(df['close'], window=5)\n    df['momentum_20d'] = calculate_momentum(df['close'], window=20)\n    \n    # Weights for the linear combination (example values)\n    weights = {'short_MA': 0.3, 'long_MA': -0.2, 'momentum_5d': 0.4, 'momentum_20d': 0.6",
          "code": "def heuristics_v2(df):\n    def calculate_moving_average(series, window):\n        return series.rolling(window=window).mean()\n    \n    def calculate_momentum(series, window):\n        return series / series.shift(window) - 1\n    \n    # Calculate short and long-term moving averages for close prices\n    df['short_MA'] = calculate_moving_average(df['close'], window=5)\n    df['long_MA'] = calculate_moving_average(df['close'], window=20)\n    \n    # Calculate momentum for close prices over 5 and 20 days\n    df['momentum_5d'] = calculate_momentum(df['close'], window=5)\n    df['momentum_20d'] = calculate_momentum(df['close'], window=20)\n    \n    # Weights for the linear combination (example values)\n    weights = {'short_MA': 0.3, 'long_MA': -0.2, 'momentum_5d': 0.4, 'momentum_20d': 0.6}\n    \n    # Generate the heuristics factor\n    heuristics_series = df.apply(lambda row: sum(row[col] * weights[col] for col in weights.keys()), axis=1)\n    \n    heuristics_matrix = heuristics_series.to_frame(name='heuristics_value')\n    \n    return heuristics_matrix",
          "objective": -0.02122,
          "other_inf": null
     }
]