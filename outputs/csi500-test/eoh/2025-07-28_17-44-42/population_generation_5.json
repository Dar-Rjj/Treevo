[
     {
          "algorithm": "The new algorithm adjusts the RSI period to 9, uses a volume-weighted price instead of just the close price, and applies a 50-day moving average for smoothing.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=9).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=9).mean()\n    rsi = 100 - (100 / (1 + (gain / loss)))\n    weight_close = 1 / (rsi * df['volume'])\n    vwp = (df['open'] + df['high'] + df['low'] + df['close']) / 4\n    smoothed_factor = (vwp * weight_close + df['amount']) / 2\n    heuristics_matrix = smoothed_factor.rolling(window=50).mean()\n    return heuristics_matrix",
          "objective": -0.04577,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a weighted sum of market features, where weights are based on the relative strength index (RSI) and volume, and then applies a simple moving average for smoothing.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rsi = 100 - (100 / (1 + (gain / loss)))\n    weight_close = 1 / (rsi * df['volume'])\n    smoothed_factor = (df['open'] + df['high'] + df['low'] + (df['close'] * weight_close) + df['amount']) / 5\n    heuristics_matrix = smoothed_factor.rolling(window=20).mean()\n    return heuristics_matrix",
          "objective": -0.04516,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of market features, where weights are based on the inverse of the product of volatility and volume, then applies a simple moving average for smoothing.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    momentum = df['close'].pct_change()\n    volatility = df['close'].rolling(window=25).std()\n    weight_close = 1 / (volatility * df['volume'])\n    smoothed_factor = (df['open'] + df['high'] + df['low'] + (df['close'] * weight_close) + df['amount']) / 5\n    heuristics_matrix = smoothed_factor.rolling(window=20).mean()\n    return heuristics_matrix",
          "objective": -0.04503,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of the market features, using the momentum and volume as weights, but applies a different weighting scheme and uses a longer span for the exponential moving average.",
          "code": "def heuristics_v2(df):\n    momentum = df['close'].pct_change()\n    weight_close = 3 * (momentum * df['volume'])\n    smoothed_factor = (df['open'] + df['high'] + df['low'] + (df['close'] * weight_close) + df['amount']) / 5\n    heuristics_matrix = smoothed_factor.ewm(span=20, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.04482,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of the market features, using the momentum and volume as weights, adjusted by the standard deviation of returns over the last 14 days, and applies a 20-day span for the exponential moving average.",
          "code": "def heuristics_v2(df):\n    momentum = df['close'].pct_change()\n    weight_close = 4 * (momentum * df['volume'])\n    adjustment_factor = df['close'].pct_change().rolling(window=14).std()\n    smoothed_factor = (df['open'] + df['high'] + df['low'] + (df['close'] * weight_close) + df['amount'] + adjustment_factor) / 6\n    heuristics_matrix = smoothed_factor.ewm(span=20, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.04481,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of the market features, using the momentum and volume as weights but incorporates an adjustment factor based on the average true range over the last 14 days, and applies a 20-day span for the exponential moving average.",
          "code": "def heuristics_v2(df):\n    momentum = df['close'].pct_change()\n    weight_close = 4 * (momentum * df['volume'])\n    adjustment_factor = df['high'].rolling(window=14).max() - df['low'].rolling(window=14).min()\n    smoothed_factor = (df['open'] + df['high'] + df['low'] + (df['close'] * weight_close) + df['amount'] + adjustment_factor) / 6\n    heuristics_matrix = smoothed_factor.ewm(span=20, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.04475,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of the market features, using the momentum and volume as weights but incorporates an adjustment factor based on the standard deviation of the close prices over the last 10 days, and applies a 30-day span for the exponential moving average.",
          "code": "def heuristics_v2(df):\n    momentum = df['close'].pct_change()\n    weight_close = 5 * (momentum * df['volume'])\n    adjustment_factor = df['close'].rolling(window=10).std()\n    smoothed_factor = (df['open'] + df['high'] + df['low'] + (df['close'] * weight_close) + df['amount'] + adjustment_factor) / 6\n    heuristics_matrix = smoothed_factor.ewm(span=30, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.04471,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of market features, where weights are based on the inverse of the product of volatility and volume, then applies an exponential moving average for smoothing.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    momentum = df['close'].pct_change()\n    volatility = df['close'].rolling(window=30).std()\n    weight_close = 1 / (volatility * df['volume'])\n    smoothed_factor = (df['open'] + df['high'] + df['low'] + (df['close'] * weight_close) + df['amount']) / 5\n    heuristics_matrix = smoothed_factor.ewm(span=20, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.04466,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a weighted sum of market features, where weights are based on the ratio of the exponential moving average (EMA) of returns to the absolute deviation of returns, and then applies a simple moving average for smoothing.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    ema_returns = df['close'].pct_change().ewm(span=14, adjust=False).mean()\n    abs_deviation = df['close'].pct_change().abs().rolling(window=14).mean()\n    weight_close = ema_returns / abs_deviation\n    smoothed_factor = (df['open'] + df['high'] + df['low'] + (df['close'] * weight_close) + df['amount']) / 5\n    heuristics_matrix = smoothed_factor.rolling(window=20).mean()\n    return heuristics_matrix",
          "objective": -0.04465,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of market features, where weights are based on the inverse of the product of volatility and volume, then applies an exponential moving average for smoothing.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    momentum = df['close'].pct_change()\n    volatility = df['close'].rolling(window=25).std()\n    weight_close = 1 / (volatility * df['volume'])\n    smoothed_factor = (df['open'] + df['high'] + df['low'] + (df['close'] * weight_close) + df['amount']) / 5\n    heuristics_matrix = smoothed_factor.ewm(span=20).mean()\n    return heuristics_matrix",
          "objective": -0.04464,
          "other_inf": null
     }
]