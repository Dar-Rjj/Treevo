[
     {
          "algorithm": "The algorithm involves calculating a weighted sum of the market features adjusted by their momentum and volatility, then applying a smoothing technique to generate more robust and interpretable alpha factors.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    momentum = df['close'].pct_change()\n    volatility = df['close'].rolling(window=20).std()\n    weight_close = 2 * (momentum / volatility)\n    smoothed_factor = (df['open'] + df['high'] + df['low'] + (df['close'] * weight_close) + (df['volume'] * df['amount'])) / 5\n    heuristics_matrix = smoothed_factor.ewm(span=10, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.02732,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies potential alpha factors by calculating the weighted sum of technical indicators, such as moving averages and price momentum, over different time horizons, to generate a heuristics matrix that aims to predict future stock returns.}\n\n```python\ndef heuristics_v2(df):\n    def calculate_moving_average(series, window):\n        return series.rolling(window=window).mean()\n    \n    def calculate_momentum(series, window):\n        return series / series.shift(window) - 1\n    \n    # Calculate short and long-term moving averages for close prices\n    df['short_MA'] = calculate_moving_average(df['close'], window=5)\n    df['long_MA'] = calculate_moving_average(df['close'], window=20)\n    \n    # Calculate momentum for close prices over 5 and 20 days\n    df['momentum_5d'] = calculate_momentum(df['close'], window=5)\n    df['momentum_20d'] = calculate_momentum(df['close'], window=20)\n    \n    # Weights for the linear combination (example values)\n    weights = {'short_MA': 0.3, 'long_MA': -0.2, 'momentum_5d': 0.4, 'momentum_20d': 0.6",
          "code": "def heuristics_v2(df):\n    def calculate_moving_average(series, window):\n        return series.rolling(window=window).mean()\n    \n    def calculate_momentum(series, window):\n        return series / series.shift(window) - 1\n    \n    # Calculate short and long-term moving averages for close prices\n    df['short_MA'] = calculate_moving_average(df['close'], window=5)\n    df['long_MA'] = calculate_moving_average(df['close'], window=20)\n    \n    # Calculate momentum for close prices over 5 and 20 days\n    df['momentum_5d'] = calculate_momentum(df['close'], window=5)\n    df['momentum_20d'] = calculate_momentum(df['close'], window=20)\n    \n    # Weights for the linear combination (example values)\n    weights = {'short_MA': 0.3, 'long_MA': -0.2, 'momentum_5d': 0.4, 'momentum_20d': 0.6}\n    \n    # Generate the heuristics factor\n    heuristics_series = df.apply(lambda row: sum(row[col] * weights[col] for col in weights.keys()), axis=1)\n    \n    heuristics_matrix = heuristics_series.to_frame(name='heuristics_value')\n    \n    return heuristics_matrix",
          "objective": -0.02122,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a composite factor by considering the weighted sum of price momentum, volatility, and trading volume changes over different time horizons.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def calculate_momentum(df, window):\n        return df['close'].pct_change(window)\n\n    def calculate_volatility(df, window):\n        return df['close'].pct_change().rolling(window=window).std()\n\n    def calculate_volume_change(df, window):\n        return df['volume'].pct_change(window)\n    \n    momentum_10 = calculate_momentum(df, 10)\n    momentum_30 = calculate_momentum(df, 30)\n    volatility_10 = calculate_volatility(df, 10)\n    volume_change_5 = calculate_volume_change(df, 5)\n    \n    heuristics_matrix = 0.4 * momentum_10 + 0.3 * momentum_30 - 0.2 * volatility_10 + 0.1 * volume_change_5\n    return heuristics_matrix",
          "objective": -0.01828,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a custom factor by first calculating the difference between the highest and lowest price over a 30-day window, then dividing this difference by the 30-day average closing price, and finally subtracting the 30-day moving average of volume from this result to generate interpretable alpha factors.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    high_low_diff = df['high'].rolling(window=30).max() - df['low'].rolling(window=30).min()\n    avg_close = df['close'].rolling(window=30).mean()\n    mov_avg_volume = df['volume'].rolling(window=30).mean()\n    heuristics_matrix = (high_low_diff / avg_close) - mov_avg_volume\n    return heuristics_matrix",
          "objective": -0.01803,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a set of heuristic alpha factors, including momentum, volatility, and a custom indicator, by analyzing the historical price and volume data to predict future stock returns.",
          "code": "def heuristics_v2(df):\n    momentum = df['close'].pct_change(periods=20)\n    daily_volatility = df['close'].pct_change().rolling(window=10).std()\n    volume_trend = df['volume'].pct_change(periods=30)\n    custom_indicator = (df['close'] - df['open']) / df['open']\n    \n    heuristics_matrix = momentum + daily_volatility + volume_trend + custom_indicator\n    return heuristics_matrix",
          "objective": -0.01773,
          "other_inf": null
     },
     {
          "algorithm": "A novel algorithm that combines momentum, volatility, and volume indicators to generate a composite alpha factor, involving the steps of calculating return ratios, volatility measures, and trading volume signals, then aggregating these into a single heuristic score for each date.",
          "code": "def heuristics_v2(df):\n    # Calculate daily returns\n    daily_returns = df['close'].pct_change()\n    \n    # Momentum indicator: 10-day return\n    momentum_10d = df['close'].pct_change(10)\n    \n    # Volatility: Standard deviation of daily returns over last 30 days\n    volatility_30d = daily_returns.rolling(window=30).std()\n    \n    # Volume signal: Ratio of current day's volume to the average volume over the past 30 days\n    avg_volume_30d = df['volume'].rolling(window=30).mean()\n    volume_ratio = df['volume'] / avg_volume_30d\n    \n    # Composite heuristic score\n    heuristics_matrix = 0.4 * momentum_10d + 0.3 * (1 / volatility_30d) + 0.3 * volume_ratio\n    \n    return heuristics_matrix",
          "objective": -0.01735,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies patterns in the relationship between trading volume and price changes, then constructs a heuristics matrix by applying a rolling window approach to calculate the weighted sum of recent volume-price interactions.",
          "code": "def heuristics_v2(df):\n    def volume_price_interaction(row):\n        return (row['close'] - row['open']) * row['volume']\n\n    df['interaction'] = df.apply(volume_price_interaction, axis=1)\n    interaction_weights = [0.1, 0.2, 0.3, 0.4, 0.5]\n    heuristics_matrix = df['interaction'].rolling(window=len(interaction_weights)).apply(lambda x: sum(x[-i] * w for i, w in enumerate(interaction_weights, 1)), raw=True)\n    \n    return heuristics_matrix",
          "objective": -0.01291,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm extracts a momentum and volatility-based alpha factor from the input DataFrame by calculating the difference between the 5-period and 20-period moving averages of closing prices, then multiplying this difference by the 10-period standard deviation of daily log returns.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    close_prices = df['close']\n    ma_5 = close_prices.rolling(window=5).mean()\n    ma_20 = close_prices.rolling(window=20).mean()\n    log_returns = np.log(close_prices / close_prices.shift(1))\n    std_10 = log_returns.rolling(window=10).std()\n    heuristics_matrix = (ma_5 - ma_20) * std_10\n    return heuristics_matrix",
          "objective": -0.01208,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm, named Heuristic Alpha Mining, integrates historical price momentum and volatility, alongside trading volume activity, to predict future stock returns by calculating a weighted score for each day.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily return\n    df['daily_return'] = df['close'].pct_change()\n    \n    # Calculate rolling mean and standard deviation of daily returns over 20 days\n    df['rolling_mean'] = df['daily_return'].rolling(window=20).mean()\n    df['rolling_std'] = df['daily_return'].rolling(window=20).std()\n    \n    # Calculate the change in volume\n    df['volume_change'] = df['volume'].pct_change()\n    \n    # Heuristic factor: Combine rolling mean, inverse of rolling std, and volume change\n    df['heuristic_factor'] = (df['rolling_mean'] + (1 / df['rolling_std'])) * df['volume_change']\n    \n    # Prepare the output series\n    heuristics_matrix = df['heuristic_factor'].dropna()\n    \n    return heuristics_matrix",
          "objective": -0.00706,
          "other_inf": null
     },
     {
          "algorithm": "A novel algorithm for alpha factor generation that calculates a composite score based on weighted moving averages and price momentum, using the last 5 and 20 days of market data to predict future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    short_window = 5\n    long_window = 20\n    # Calculate short and long moving averages for close prices\n    short_mavg = df['close'].rolling(window=short_window).mean()\n    long_mavg = df['close'].rolling(window=long_window).mean()\n    # Momentum: difference between today's closing price and the average of the last 20 days' closing prices\n    momentum = df['close'] - long_mavg\n    # Composite score calculation (simplified example)\n    heuristics_matrix = (short_mavg - long_mavg) + momentum\n    return heuristics_matrix",
          "objective": -0.00591,
          "other_inf": null
     }
]