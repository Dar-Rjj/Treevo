[
     {
          "algorithm": "The new algorithm computes a weighted sum of market features, where weights are based on the relative strength index (RSI) and volume, and then applies a simple moving average for smoothing.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rsi = 100 - (100 / (1 + (gain / loss)))\n    weight_close = 1 / (rsi * df['volume'])\n    smoothed_factor = (df['open'] + df['high'] + df['low'] + (df['close'] * weight_close) + df['amount']) / 5\n    heuristics_matrix = smoothed_factor.rolling(window=20).mean()\n    return heuristics_matrix",
          "objective": -0.04516,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of market features, where weights are based on the inverse of the product of volatility and volume, then applies a simple moving average for smoothing.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    momentum = df['close'].pct_change()\n    volatility = df['close'].rolling(window=25).std()\n    weight_close = 1 / (volatility * df['volume'])\n    smoothed_factor = (df['open'] + df['high'] + df['low'] + (df['close'] * weight_close) + df['amount']) / 5\n    heuristics_matrix = smoothed_factor.rolling(window=20).mean()\n    return heuristics_matrix",
          "objective": -0.04503,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of the market features, using the momentum and volume as weights, but applies a different weighting scheme and uses a longer span for the exponential moving average.",
          "code": "def heuristics_v2(df):\n    momentum = df['close'].pct_change()\n    weight_close = 3 * (momentum * df['volume'])\n    smoothed_factor = (df['open'] + df['high'] + df['low'] + (df['close'] * weight_close) + df['amount']) / 5\n    heuristics_matrix = smoothed_factor.ewm(span=20, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.04482,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of market features, where weights are based on the inverse of the product of volatility and volume, then applies an exponential moving average for smoothing.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    momentum = df['close'].pct_change()\n    volatility = df['close'].rolling(window=30).std()\n    weight_close = 1 / (volatility * df['volume'])\n    smoothed_factor = (df['open'] + df['high'] + df['low'] + (df['close'] * weight_close) + df['amount']) / 5\n    heuristics_matrix = smoothed_factor.ewm(span=20, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.04466,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of market features, where weights are based on the inverse of the product of volatility and volume, then applies an exponential moving average for smoothing.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    momentum = df['close'].pct_change()\n    volatility = df['close'].rolling(window=25).std()\n    weight_close = 1 / (volatility * df['volume'])\n    smoothed_factor = (df['open'] + df['high'] + df['low'] + (df['close'] * weight_close) + df['amount']) / 5\n    heuristics_matrix = smoothed_factor.ewm(span=20).mean()\n    return heuristics_matrix",
          "objective": -0.04464,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a weighted sum of market features, where weights are determined by the inverse of volatility and volume, then combines this with a rolling mean of momentum, and finally applies an exponential moving average for smoothing.",
          "code": "def heuristics_v2(df):\n    momentum = df['close'].pct_change().rolling(window=25).mean()\n    volatility = df['close'].rolling(window=25).std()\n    weight_close = 1 / (volatility * df['volume'])\n    smoothed_factor = (df['open'] + df['high'] + df['low'] + (df['close'] * weight_close) + df['amount']) / 5 + momentum\n    heuristics_matrix = smoothed_factor.ewm(span=20, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.04458,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a weighted sum of market features, where weights are determined by the inverse of volatility and volume, and then applies an exponential moving average for smoothing.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    momentum = df['close'].pct_change()\n    volatility = df['close'].rolling(window=25).std()\n    weight_close = 1 / (volatility * df['volume'])\n    smoothed_factor = (df['open'] + df['high'] + df['low'] + (df['close'] * weight_close) + df['amount']) / 5\n    heuristics_matrix = smoothed_factor.ewm(span=20, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.04456,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of market features, where weights are based on the inverse of volatility and adjusted volume, then integrates a rolling mean of momentum with a longer window, and finally applies an exponential moving average for smoothing.",
          "code": "def heuristics_v2(df):\n    momentum = df['close'].pct_change().rolling(window=50).mean()\n    volatility = df['close'].rolling(window=50).std()\n    weight_close = 1 / (volatility * df['volume']**0.5)\n    smoothed_factor = (df['open'] + df['high'] + df['low'] + (df['close'] * weight_close) + df['amount']) / 5 + momentum\n    heuristics_matrix = smoothed_factor.ewm(span=30, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.04429,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of the market features, using the momentum and volume as weights, incorporates a lagged close price for added stability, and applies an exponential moving average to smooth the resulting factor.",
          "code": "def heuristics_v2(df):\n    momentum = df['close'].pct_change()\n    weight_close = 2 * (momentum * df['volume'])\n    lagged_close = df['close'].shift(1)\n    smoothed_factor = (df['open'] + df['high'] + df['low'] + (lagged_close * weight_close) + df['amount']) / 5\n    heuristics_matrix = smoothed_factor.ewm(span=10, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.04394,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of the market features, using the momentum and volume as weights, but applies an exponential moving average to smooth the factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    momentum = df['close'].pct_change()\n    weight_close = 2 * (momentum * df['volume'])\n    smoothed_factor = (df['open'] + df['high'] + df['low'] + (df['close'] * weight_close) + df['amount']) / 5\n    heuristics_matrix = smoothed_factor.ewm(span=10, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.04389,
          "other_inf": null
     }
]