[
     {
          "algorithm": "The algorithm creates a composite factor by combining momentum, volatility, and liquidity indicators, leveraging historical price and volume data to infer potential future stock performance.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    df['momentum'] = (df['close'] - df['close'].shift(10)) / df['close'].shift(10)\n    df['volatility'] = df['high'] - df['low']\n    df['liquidity'] = df['volume'] / df['amount']\n    heuristics_matrix = (df['momentum'] + df['volatility'] + df['liquidity']) / 3\n    return heuristics_matrix",
          "objective": -0.01963,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm constructs a novel heuristic factor by calculating the difference between the average of the last 5 days' closing prices and the average of the last 20 days' volume, aiming to capture momentum and liquidity dynamics.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    close_avg_5 = df['close'].rolling(window=5).mean()\n    volume_avg_20 = df['volume'].rolling(window=20).mean()\n    heuristics_matrix = close_avg_5 - volume_avg_20\n    return heuristics_matrix",
          "objective": -0.01565,
          "other_inf": null
     },
     {
          "algorithm": "A novel algorithm to generate alpha factors by calculating the moving average convergence divergence (MACD) of the closing price and the volume, then combining these with a momentum factor derived from the difference between the high and low prices over a specified period, and finally creating a weighted sum of these factors to produce a unique heuristics matrix.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Compute MACD for close prices\n    ema_12_close = df['close'].ewm(span=12, adjust=False).mean()\n    ema_26_close = df['close'].ewm(span=26, adjust=False).mean()\n    macd_close = ema_12_close - ema_26_close\n    signal_close = macd_close.ewm(span=9, adjust=False).mean()\n\n    # Compute MACD for volumes\n    ema_12_volume = df['volume'].ewm(span=12, adjust=False).mean()\n    ema_26_volume = df['volume'].ewm(span=26, adjust=False).mean()\n    macd_volume = ema_12_volume - ema_26_volume\n    signal_volume = macd_volume.ewm(span=9, adjust=False).mean()\n\n    # Momentum factor\n    momentum = (df['high'] - df['low']).rolling(window=10).mean()\n\n    # Combining factors\n    combined_factor = 2 * macd_close - signal_close + 1.5 * (macd_volume - signal_volume) + momentum\n    \n    heuristics_matrix = pd.Series(combined_factor, index=df.index)\n    return heuristics_matrix",
          "objective": -0.01317,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm, named HeuristicAlpha, integrates trend-following, mean-reversion, and volume-surprise signals to generate a composite alpha factor by computing the weighted sum of these three signals.",
          "code": "def heuristics_v2(df):\n    # Trend-following signal: difference between 5-day and 20-day moving average of close prices\n    trend_signal = df['close'].rolling(window=5).mean() - df['close'].rolling(window=20).mean()\n    \n    # Mean reversion signal: 10-day rate of change\n    mean_reversion_signal = (df['close'] - df['close'].shift(10)) / df['close'].shift(10)\n    \n    # Volume surprise signal: difference between today's volume and 30-day average volume\n    volume_surprise_signal = df['volume'] - df['volume'].rolling(window=30).mean()\n    \n    # Composite alpha factor as the simple average of the above signals\n    heuristics_matrix = (trend_signal + mean_reversion_signal + volume_surprise_signal) / 3\n    \n    return heuristics_matrix",
          "objective": -0.01093,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm extracts and combines key financial indicators using a set of heuristic rules to generate an interpretable alpha factor, which is then returned as a series representing the factor values for each date.",
          "code": "def heuristics_v2(df):\n    # Heuristic 1: Price Momentum - measures the momentum of the closing price\n    price_momentum = df['close'].pct_change()\n    \n    # Heuristic 2: Volume Spike - identifies days with unusually high trading volume\n    avg_volume = df['volume'].rolling(window=20).mean()\n    volume_spike = (df['volume'] - avg_volume) / avg_volume\n    \n    # Heuristic 3: Price Volatility - calculates the standard deviation of daily returns\n    daily_returns = df['close'].pct_change()\n    price_volatility = daily_returns.rolling(window=20).std()\n    \n    # Combine heuristics into a single factor value per day\n    heuristics_matrix = 0.5 * price_momentum + 0.3 * volume_spike - 0.2 * price_volatility\n\n    return heuristics_matrix",
          "objective": -0.00935,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a factor based on the weighted moving average of price changes, where the weights are determined by volume, and then applies a momentum adjustment to enhance predictive power.",
          "code": "def heuristics_v2(df):\n    # Compute daily price change\n    df['price_change'] = df['close'].diff()\n    # Weighted price change using volume as weight\n    df['weighted_change'] = df['price_change'] * df['volume']\n    # Moving average of the weighted price change\n    df['moving_avg_change'] = df['weighted_change'].rolling(window=10).mean()\n    # Momentum calculation (change in moving average)\n    df['momentum'] = df['moving_avg_change'].diff(periods=5)\n    # Factor value is the momentum adjusted by recent volume\n    df['factor'] = df['momentum'] * df['volume'].rolling(window=5).mean()\n    heuristics_matrix = df['factor'].copy()\n    return heuristics_matrix",
          "objective": -0.0086,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a momentum-based heuristic factor by first determining the 5-day and 20-day simple moving averages (SMA) of the closing prices, then subtracts the 20-day SMA from the 5-day SMA to generate an indicator of short-term versus long-term trends.",
          "code": "def heuristics_v2(df):\n    sma_5 = df['close'].rolling(window=5).mean()\n    sma_20 = df['close'].rolling(window=20).mean()\n    heuristics_matrix = sma_5 - sma_20\n    return heuristics_matrix",
          "objective": -0.00836,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies patterns in historical price and volume data to generate a novel alpha factor by computing the weighted difference between the average of the past 5 days' closing prices and the current day's volume, with weights assigned based on the standard deviation of each feature.",
          "code": "def heuristics_v2(df):\n    # Calculate the average of the last 5 days' close prices\n    avg_close = df['close'].rolling(window=5).mean()\n    # Calculate the standard deviation of the close prices and volume over the last 5 days\n    std_close = df['close'].rolling(window=5).std()\n    std_volume = df['volume'].rolling(window=5).std()\n    # Compute the heuristic score as a weighted difference\n    heuristics_matrix = (avg_close / std_close) - (df['volume'] / std_volume)\n    return heuristics_matrix",
          "objective": -0.00824,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm leverages a combination of technical indicators and rolling window statistics to generate a set of heuristics, which are then linearly combined to form a final alpha factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Generating heuristics based on simple moving average crossovers and volume changes\n    sma_10 = df['close'].rolling(window=10).mean()\n    sma_30 = df['close'].rolling(window=30).mean()\n    crossover_signal = (sma_10 - sma_30) / sma_30\n    \n    volume_change = (df['volume'] - df['volume'].shift(1)) / df['volume'].shift(1)\n    \n    # Simple heuristic combining the signals\n    heuristics_matrix = 0.5 * crossover_signal + 0.5 * volume_change\n    return heuristics_matrix",
          "objective": -0.00768,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a composite factor by calculating the moving average convergence divergence (MACD) of the closing prices and combining it with the rate of change (ROC) of the trading volume, without normalizing the data.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate MACD\n    ema12 = df['close'].ewm(span=12, adjust=False).mean()\n    ema26 = df['close'].ewm(span=26, adjust=False).mean()\n    macd = ema12 - ema26\n    signal = macd.ewm(span=9, adjust=False).mean()\n    \n    # Calculate ROC for volume\n    roc_volume = (df['volume'] - df['volume'].shift(1)) / df['volume'].shift(1)\n    \n    # Combine MACD with ROC of Volume\n    heuristics_matrix = macd - signal + roc_volume\n    \n    return heuristics_matrix",
          "objective": -0.00567,
          "other_inf": null
     }
]