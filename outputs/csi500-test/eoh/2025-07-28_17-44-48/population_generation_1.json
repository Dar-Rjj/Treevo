[
     {
          "algorithm": "The algorithm computes a unique factor for each date by aggregating weighted differences between high and low prices, adjusted by volume, to predict future stock returns.",
          "code": "def heuristics_v2(df):\n    def compute_factor(row):\n        return (row['high'] - row['low']) * row['volume']\n    heuristics_matrix = df.apply(compute_factor, axis=1)\n    return heuristics_matrix",
          "objective": -0.03517,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm, named AlphaInsight, computes a factor by integrating the momentum of price changes with the volatility and trading volume, aiming to capture both trend-following and mean-reverting signals.",
          "code": "def heuristics_v2(df):\n    # Calculate the difference between high and low prices as a measure of volatility\n    price_volatility = df['high'] - df['low']\n    \n    # Calculate the difference between closing and opening prices to gauge daily momentum\n    daily_momentum = df['close'] - df['open']\n    \n    # Integrate the components into a single factor\n    heuristics_matrix = (price_volatility + daily_momentum) * df['volume']\n    \n    return heuristics_matrix",
          "objective": -0.03067,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by dividing the exponential moving average of the daily trading range (high - low) with the simple moving average of the closing price, to capture a ratio-based relationship between volatility and trend.",
          "code": "def heuristics_v2(df):\n    ema_window = 10\n    sma_window = 30\n    trading_range = df['high'] - df['low']\n    ema_trading_range = trading_range.ewm(span=ema_window, adjust=False).mean()\n    sma_close = df['close'].rolling(window=sma_window).mean()\n    heuristics_matrix = ema_trading_range / sma_close\n    return heuristics_matrix",
          "objective": -0.02444,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a factor for each date by aggregating the weighted average of the open and close prices, adjusted by the logarithm of the volume, to predict future stock returns.",
          "code": "import numpy as np\n\ndef heuristics_v2(df):\n    def compute_factor(row):\n        return (row['open'] + row['close']) / 2 * np.log(row['volume'] + 1)\n    heuristics_matrix = df.apply(compute_factor, axis=1)\n    return heuristics_matrix",
          "objective": -0.02234,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm generates a heuristics_matrix by combining the weighted moving average of closing prices with the money flow index (MFI) to identify potential alpha factors.",
          "code": "def heuristics_v2(df):\n    wma = df['close'].rolling(window=14).mean()\n    typical_price = (df['high'] + df['low'] + df['close']) / 3\n    raw_money_flow = typical_price * df['volume']\n    positive_flow = raw_money_flow.where(typical_price > typical_price.shift(1), 0)\n    negative_flow = raw_money_flow.where(typical_price < typical_price.shift(1), 0)\n    money_ratio = positive_flow.rolling(window=14).sum() / negative_flow.rolling(window=14).sum()\n    mfi = 100 - (100 / (1 + money_ratio))\n    heuristics_matrix = wma * mfi\n    return heuristics_matrix",
          "objective": -0.02125,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by combining the rate of change in trading volume, using a 5-period span for smoothing, with a weighted average true range over 20 periods, giving more weight to recent volatility.",
          "code": "def heuristics_v2(df):\n    # Calculate the rate of change in volume\n    roc_volume = df['volume'].pct_change().ewm(span=5, adjust=False).mean()\n    \n    # Calculate the true range\n    tr = df['high'] - df['low']\n    \n    # Calculate the weighted average true range\n    atr = tr.ewm(span=20, adjust=False).mean()\n    \n    # Combine the smoothed rate of change in volume and the weighted average true range\n    heuristics_matrix = roc_volume + atr\n    \n    return heuristics_matrix",
          "objective": -0.02094,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm generates a heuristics_matrix by combining the weighted moving average of closing prices with the relative strength index (RSI) to identify potential alpha factors.",
          "code": "def heuristics_v2(df):\n    wma = df['close'].rolling(window=14).mean()\n    delta = df['close'].diff(1)\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    heuristics_matrix = wma * rsi\n    return heuristics_matrix",
          "objective": -0.02079,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by combining the rate of change in trading volume with a weighted average true range, giving more weight to recent volatility.",
          "code": "def heuristics_v2(df):\n    # Calculate the rate of change in volume\n    roc_volume = df['volume'].pct_change()\n    \n    # Calculate the true range\n    tr = df['high'] - df['low']\n    \n    # Calculate the weighted average true range\n    atr = tr.ewm(span=14, adjust=False).mean()\n    \n    # Combine the rate of change in volume and the weighted average true range\n    heuristics_matrix = roc_volume + atr\n    \n    return heuristics_matrix",
          "objective": -0.02064,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm generates a heuristics_matrix by combining the exponential moving average of closing prices with a modified RSI, which uses a 20-period window for smoothing gains and losses to identify potential alpha factors.",
          "code": "def heuristics_v2(df):\n    ema = df['close'].ewm(span=14, adjust=False).mean()\n    delta = df['close'].diff(1)\n    gain = (delta.where(delta > 0, 0)).rolling(window=20).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=20).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    heuristics_matrix = ema * rsi\n    return heuristics_matrix",
          "objective": -0.02063,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm generates a heuristics_matrix by integrating the weighted moving average of closing prices with the Stochastic Oscillator to identify potential alpha factors.",
          "code": "def heuristics_v2(df):\n    wma = df['close'].rolling(window=14).mean()\n    lowest_low = df['low'].rolling(window=14).min()\n    highest_high = df['high'].rolling(window=14).max()\n    k_percent = 100 * (df['close'] - lowest_low) / (highest_high - lowest_low)\n    heuristics_matrix = wma * k_percent\n    return heuristics_matrix",
          "objective": -0.0205,
          "other_inf": null
     }
]