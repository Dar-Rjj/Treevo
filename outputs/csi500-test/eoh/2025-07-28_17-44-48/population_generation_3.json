[
     {
          "algorithm": "The new algorithm computes a factor for each date by calculating the difference between the high and low prices, then dividing this difference by the average of the open and close prices, adjusted by the exponential of the normalized volume (volume/mean(volume)).",
          "code": "import numpy as np\n\ndef heuristics_v2(df):\n    def compute_factor(row):\n        avg_price = (row['open'] + row['close']) / 2\n        return (row['high'] - row['low']) / avg_price * np.exp(row['volume'] / df['volume'].mean())\n    heuristics_matrix = df.apply(compute_factor, axis=1)\n    return heuristics_matrix",
          "objective": -0.04764,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a factor for each date by aggregating the weighted average of the open and high prices, adjusted by the square root of the volume, to predict future stock returns.",
          "code": "import numpy as np\n\ndef heuristics_v2(df):\n    def compute_factor(row):\n        return (row['open'] + row['high']) / 2 * np.sqrt(row['volume'])\n    heuristics_matrix = df.apply(compute_factor, axis=1)\n    return heuristics_matrix",
          "objective": -0.04094,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a factor for each date by calculating the difference between the high and low prices, then dividing this difference by the sum of the open and close prices, adjusted by the square root of the normalized volume (volume/mean(volume)).",
          "code": "import numpy as np\n\ndef heuristics_v2(df):\n    def compute_factor(row):\n        price_sum = row['open'] + row['close']\n        return (row['high'] - row['low']) / price_sum * np.sqrt(row['volume'] / df['volume'].mean())\n    heuristics_matrix = df.apply(compute_factor, axis=1)\n    return heuristics_matrix",
          "objective": -0.03939,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a factor for each date by aggregating the difference between the high and low prices, adjusted by the square root of the volume.",
          "code": "import numpy as np\n\ndef heuristics_v2(df):\n    def compute_factor(row):\n        return (row['high'] - row['low']) * np.sqrt(row['volume'] + 1)\n    heuristics_matrix = df.apply(compute_factor, axis=1)\n    return heuristics_matrix",
          "objective": -0.03602,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a unique factor for each date by aggregating weighted differences between high and low prices, adjusted by volume, to predict future stock returns.",
          "code": "def heuristics_v2(df):\n    def compute_factor(row):\n        return (row['high'] - row['low']) * row['volume']\n    heuristics_matrix = df.apply(compute_factor, axis=1)\n    return heuristics_matrix",
          "objective": -0.03517,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor for each date using the weighted average of the low and close prices, adjusted by the cube root of the volume, to predict future stock returns.",
          "code": "import numpy as np\n\ndef heuristics_v2(df):\n    def compute_factor(row):\n        return (row['low'] + row['close']) / 2 * np.cbrt(row['volume'])\n    heuristics_matrix = df.apply(compute_factor, axis=1)\n    return heuristics_matrix",
          "objective": -0.03334,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a factor for each date by aggregating the weighted average of the open, high, and low prices, adjusted by the cube root of the volume, to predict future stock returns.",
          "code": "import numpy as np\n\ndef heuristics_v2(df):\n    def compute_factor(row):\n        return (row['open'] + row['high'] + row['low']) / 3 * np.cbrt(row['volume'])\n    heuristics_matrix = df.apply(compute_factor, axis=1)\n    return heuristics_matrix",
          "objective": -0.03333,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm, named AlphaInsight, computes a factor by integrating the momentum of price changes with the volatility and trading volume, aiming to capture both trend-following and mean-reverting signals.",
          "code": "def heuristics_v2(df):\n    # Calculate the difference between high and low prices as a measure of volatility\n    price_volatility = df['high'] - df['low']\n    \n    # Calculate the difference between closing and opening prices to gauge daily momentum\n    daily_momentum = df['close'] - df['open']\n    \n    # Integrate the components into a single factor\n    heuristics_matrix = (price_volatility + daily_momentum) * df['volume']\n    \n    return heuristics_matrix",
          "objective": -0.03067,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a factor for each date by aggregating the weighted differences between the high and low prices, adjusted by both volume and the closing price, to predict future stock returns.",
          "code": "def heuristics_v2(df):\n    def compute_factor(row):\n        return (row['high'] - row['low']) * row['volume'] * row['close']\n    heuristics_matrix = df.apply(compute_factor, axis=1)\n    return heuristics_matrix",
          "objective": -0.02747,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by dividing the exponential moving average of the daily trading range (high - low) with the exponential moving average of the closing price, but uses different window sizes for EMA calculations: 20 for the trading range and 50 for the closing price.",
          "code": "def heuristics_v2(df):\n    ema_window_trading_range = 20\n    ema_window_close = 50\n    trading_range = df['high'] - df['low']\n    ema_trading_range = trading_range.ewm(span=ema_window_trading_range, adjust=False).mean()\n    ema_close = df['close'].ewm(span=ema_window_close, adjust=False).mean()\n    heuristics_matrix = ema_trading_range / ema_close\n    return heuristics_matrix",
          "objective": -0.02699,
          "other_inf": null
     }
]