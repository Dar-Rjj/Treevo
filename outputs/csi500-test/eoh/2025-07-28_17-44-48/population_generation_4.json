[
     {
          "algorithm": "The new algorithm computes a factor for each date by calculating the difference between the high and low prices, then dividing this difference by the average of the open and close prices, adjusted by the exponential of the normalized volume (volume/mean(volume)).",
          "code": "import numpy as np\n\ndef heuristics_v2(df):\n    def compute_factor(row):\n        avg_price = (row['open'] + row['close']) / 2\n        return (row['high'] - row['low']) / avg_price * np.exp(row['volume'] / df['volume'].mean())\n    heuristics_matrix = df.apply(compute_factor, axis=1)\n    return heuristics_matrix",
          "objective": -0.04764,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a factor for each date by calculating the ratio of the close price to the average of open and low prices, then multiplying this ratio by the square root of the amount traded.",
          "code": "import numpy as np\n\ndef heuristics_v2(df):\n    def compute_factor(row):\n        return (row['close'] / ((row['open'] + row['low']) / 2)) * np.sqrt(row['amount'])\n    heuristics_matrix = df.apply(compute_factor, axis=1)\n    return heuristics_matrix",
          "objective": -0.04499,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor for each date using the weighted average of the high and close prices, adjusted by the square root of the volume, to predict future stock returns.",
          "code": "import numpy as np\n\ndef heuristics_v2(df):\n    def compute_factor(row):\n        return (row['high'] + row['close']) / 2 * np.sqrt(row['volume'])\n    heuristics_matrix = df.apply(compute_factor, axis=1)\n    return heuristics_matrix",
          "objective": -0.04095,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a factor for each date by aggregating the weighted average of the open and high prices, adjusted by the square root of the volume, to predict future stock returns.",
          "code": "import numpy as np\n\ndef heuristics_v2(df):\n    def compute_factor(row):\n        return (row['open'] + row['high']) / 2 * np.sqrt(row['volume'])\n    heuristics_matrix = df.apply(compute_factor, axis=1)\n    return heuristics_matrix",
          "objective": -0.04094,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a factor for each date by calculating the difference between the high and low prices, then dividing this difference by the sum of the open and close prices, adjusted by the square root of the normalized volume (volume/mean(volume)).",
          "code": "import numpy as np\n\ndef heuristics_v2(df):\n    def compute_factor(row):\n        price_sum = row['open'] + row['close']\n        return (row['high'] - row['low']) / price_sum * np.sqrt(row['volume'] / df['volume'].mean())\n    heuristics_matrix = df.apply(compute_factor, axis=1)\n    return heuristics_matrix",
          "objective": -0.03939,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a factor for each date by calculating the ratio of the close price to the open price, then multiplying this ratio by the logarithm (base 10) of the amount traded.",
          "code": "import numpy as np\n\ndef heuristics_v2(df):\n    def compute_factor(row):\n        return (row['close'] / row['open']) * np.log10(row['amount'])\n    heuristics_matrix = df.apply(compute_factor, axis=1)\n    return heuristics_matrix",
          "objective": -0.03709,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a factor for each date by aggregating the difference between the high and low prices, adjusted by the square root of the volume.",
          "code": "import numpy as np\n\ndef heuristics_v2(df):\n    def compute_factor(row):\n        return (row['high'] - row['low']) * np.sqrt(row['volume'] + 1)\n    heuristics_matrix = df.apply(compute_factor, axis=1)\n    return heuristics_matrix",
          "objective": -0.03602,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a unique factor for each date by aggregating weighted differences between high and low prices, adjusted by volume, to predict future stock returns.",
          "code": "def heuristics_v2(df):\n    def compute_factor(row):\n        return (row['high'] - row['low']) * row['volume']\n    heuristics_matrix = df.apply(compute_factor, axis=1)\n    return heuristics_matrix",
          "objective": -0.03517,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor for each date using the weighted average of the low and close prices, adjusted by the cube root of the volume, to predict future stock returns.",
          "code": "import numpy as np\n\ndef heuristics_v2(df):\n    def compute_factor(row):\n        return (row['low'] + row['close']) / 2 * np.cbrt(row['volume'])\n    heuristics_matrix = df.apply(compute_factor, axis=1)\n    return heuristics_matrix",
          "objective": -0.03334,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a factor for each date by aggregating the weighted average of the open, high, and low prices, adjusted by the cube root of the volume, to predict future stock returns.",
          "code": "import numpy as np\n\ndef heuristics_v2(df):\n    def compute_factor(row):\n        return (row['open'] + row['high'] + row['low']) / 3 * np.cbrt(row['volume'])\n    heuristics_matrix = df.apply(compute_factor, axis=1)\n    return heuristics_matrix",
          "objective": -0.03333,
          "other_inf": null
     }
]