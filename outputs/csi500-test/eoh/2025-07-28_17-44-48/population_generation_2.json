[
     {
          "algorithm": "The new algorithm computes a factor for each date by calculating the difference between the high and low prices, then dividing this difference by the average of the open and close prices, adjusted by the exponential of the normalized volume (volume/mean(volume)).",
          "code": "import numpy as np\n\ndef heuristics_v2(df):\n    def compute_factor(row):\n        avg_price = (row['open'] + row['close']) / 2\n        return (row['high'] - row['low']) / avg_price * np.exp(row['volume'] / df['volume'].mean())\n    heuristics_matrix = df.apply(compute_factor, axis=1)\n    return heuristics_matrix",
          "objective": -0.04764,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a factor for each date by aggregating the weighted average of the open and high prices, adjusted by the square root of the volume, to predict future stock returns.",
          "code": "import numpy as np\n\ndef heuristics_v2(df):\n    def compute_factor(row):\n        return (row['open'] + row['high']) / 2 * np.sqrt(row['volume'])\n    heuristics_matrix = df.apply(compute_factor, axis=1)\n    return heuristics_matrix",
          "objective": -0.04094,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a factor for each date by calculating the difference between the high and low prices, then dividing this difference by the sum of the open and close prices, adjusted by the square root of the normalized volume (volume/mean(volume)).",
          "code": "import numpy as np\n\ndef heuristics_v2(df):\n    def compute_factor(row):\n        price_sum = row['open'] + row['close']\n        return (row['high'] - row['low']) / price_sum * np.sqrt(row['volume'] / df['volume'].mean())\n    heuristics_matrix = df.apply(compute_factor, axis=1)\n    return heuristics_matrix",
          "objective": -0.03939,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a factor for each date by aggregating the difference between the high and low prices, adjusted by the square root of the volume.",
          "code": "import numpy as np\n\ndef heuristics_v2(df):\n    def compute_factor(row):\n        return (row['high'] - row['low']) * np.sqrt(row['volume'] + 1)\n    heuristics_matrix = df.apply(compute_factor, axis=1)\n    return heuristics_matrix",
          "objective": -0.03602,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a unique factor for each date by aggregating weighted differences between high and low prices, adjusted by volume, to predict future stock returns.",
          "code": "def heuristics_v2(df):\n    def compute_factor(row):\n        return (row['high'] - row['low']) * row['volume']\n    heuristics_matrix = df.apply(compute_factor, axis=1)\n    return heuristics_matrix",
          "objective": -0.03517,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm, named AlphaInsight, computes a factor by integrating the momentum of price changes with the volatility and trading volume, aiming to capture both trend-following and mean-reverting signals.",
          "code": "def heuristics_v2(df):\n    # Calculate the difference between high and low prices as a measure of volatility\n    price_volatility = df['high'] - df['low']\n    \n    # Calculate the difference between closing and opening prices to gauge daily momentum\n    daily_momentum = df['close'] - df['open']\n    \n    # Integrate the components into a single factor\n    heuristics_matrix = (price_volatility + daily_momentum) * df['volume']\n    \n    return heuristics_matrix",
          "objective": -0.03067,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by dividing the exponential moving average of the daily trading range (high - low) with the exponential moving average of the closing price, to capture a ratio-based relationship between volatility and trend using entirely exponential smoothing.",
          "code": "def heuristics_v2(df):\n    ema_window_trading_range = 10\n    ema_window_close = 30\n    trading_range = df['high'] - df['low']\n    ema_trading_range = trading_range.ewm(span=ema_window_trading_range, adjust=False).mean()\n    ema_close = df['close'].ewm(span=ema_window_close, adjust=False).mean()\n    heuristics_matrix = ema_trading_range / ema_close\n    return heuristics_matrix",
          "objective": -0.02497,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by dividing the exponential moving average of the daily trading range (high - low) with the simple moving average of the closing price, to capture a ratio-based relationship between volatility and trend.",
          "code": "def heuristics_v2(df):\n    ema_window = 10\n    sma_window = 30\n    trading_range = df['high'] - df['low']\n    ema_trading_range = trading_range.ewm(span=ema_window, adjust=False).mean()\n    sma_close = df['close'].rolling(window=sma_window).mean()\n    heuristics_matrix = ema_trading_range / sma_close\n    return heuristics_matrix",
          "objective": -0.02444,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a factor for each date by aggregating the weighted average of the open and close prices, adjusted by the logarithm of the volume, to predict future stock returns.",
          "code": "import numpy as np\n\ndef heuristics_v2(df):\n    def compute_factor(row):\n        return (row['open'] + row['close']) / 2 * np.log(row['volume'] + 1)\n    heuristics_matrix = df.apply(compute_factor, axis=1)\n    return heuristics_matrix",
          "objective": -0.02234,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a factor for each date by calculating the difference between the high and low prices, then dividing this difference by the close price, and multiplying it by the square root of the volume.",
          "code": "import numpy as np\n\ndef heuristics_v2(df):\n    def compute_factor(row):\n        return (row['high'] - row['low']) / row['close'] * np.sqrt(row['volume'])\n    heuristics_matrix = df.apply(compute_factor, axis=1)\n    return heuristics_matrix",
          "objective": -0.02221,
          "other_inf": null
     }
]