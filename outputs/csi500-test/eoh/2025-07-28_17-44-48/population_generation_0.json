[
     {
          "algorithm": "The algorithm computes a unique factor for each date by aggregating weighted differences between high and low prices, adjusted by volume, to predict future stock returns.",
          "code": "def heuristics_v2(df):\n    def compute_factor(row):\n        return (row['high'] - row['low']) * row['volume']\n    heuristics_matrix = df.apply(compute_factor, axis=1)\n    return heuristics_matrix",
          "objective": -0.03517,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm, named AlphaHeuristics, involves calculating a composite score for each date based on weighted moving averages of price and volume changes, aiming to identify potential momentum and reversal signals.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the difference between high and low prices\n    price_diff = df['high'] - df['low']\n    \n    # Calculate the percentage change in closing price\n    close_pct_change = df['close'].pct_change()\n    \n    # Calculate the ratio of amount to volume to infer investor sentiment\n    amount_vol_ratio = df['amount'] / df['volume']\n    \n    # Combine the calculated features into a single heuristic factor\n    heuristics_matrix = (price_diff + close_pct_change + amount_vol_ratio) / 3\n    \n    return heuristics_matrix",
          "objective": -0.01991,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm extracts a novel alpha factor by calculating the rolling median of the close price minus the rolling minimum of the low price over a 20-day window, aiming to capture potential upward momentum.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    heuristics_matrix = (df['close'].rolling(window=20).median() - df['low'].rolling(window=20).min()).dropna()\n    return heuristics_matrix",
          "objective": -0.01706,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm involves creating a composite factor by combining momentum, volatility, and trading volume patterns, where each element is calculated through a rolling window approach to capture recent market behaviors.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Momentum: Simple moving average of the last 5 days' close prices\n    momentum = df['close'].rolling(window=5).mean()\n    \n    # Volatility: Standard deviation of daily returns over the last 10 days\n    daily_returns = (df['close'] / df['close'].shift(1)) - 1\n    volatility = daily_returns.rolling(window=10).std()\n    \n    # Volume Trend: Moving average of the last 5 days' volume\n    volume_trend = df['volume'].rolling(window=5).mean()\n    \n    # Combine factors into a single score; for simplicity, we use a linear combination\n    heuristics_matrix = (momentum + 1/volatility + volume_trend)\n    \n    return heuristics_matrix",
          "objective": -0.01687,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies potential alpha factors by calculating the moving average convergence divergence (MACD) and its signal line, then applying a custom heuristic to combine these with price momentum, resulting in a unique heuristics_matrix.",
          "code": "def heuristics_v2(df):\n    short_ema = df['close'].ewm(span=12, adjust=False).mean()\n    long_ema = df['close'].ewm(span=26, adjust=False).mean()\n    macd_line = short_ema - long_ema\n    signal_line = macd_line.ewm(span=9, adjust=False).mean()\n    momentum = df['close'] - df['close'].shift(10)\n    heuristics_matrix = (macd_line - signal_line) * momentum\n    return heuristics_matrix",
          "objective": -0.01544,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm leverages the momentum and volatility of stock prices to generate a factor that combines the rate of change in closing prices with their relative standard deviation over a specific period.",
          "code": "def heuristics_v2(df):\n    def calc_momentum(data, window):\n        return data.pct_change(window)\n\n    def calc_volatility(data, window):\n        return data.rolling(window).std()\n\n    momentum = calc_momentum(df['close'], 20)\n    volatility = calc_volatility(df['close'], 20)\n    heuristics_matrix = (momentum / volatility).dropna()\n    \n    return heuristics_matrix",
          "objective": -0.01308,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a composite factor by combining moving averages and volume-weighted price changes, capturing both momentum and liquidity effects.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate short-term and long-term moving averages\n    short_ma = df['close'].rolling(window=10).mean()\n    long_ma = df['close'].rolling(window=50).mean()\n    \n    # Calculate the difference between the short and long moving averages\n    ma_diff = short_ma - long_ma\n    \n    # Calculate the volume-weighted price change\n    vw_price_change = (df['close'] - df['open']) * df['volume']\n    \n    # Combine the moving average difference and the volume-weighted price change\n    heuristics_matrix = ma_diff + vw_price_change\n    \n    return heuristics_matrix",
          "objective": -0.01091,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a momentum-based alpha factor by calculating the average return over the past 20 days and then adjusting it with the ratio of today's volume to the average volume over the last 20 days.",
          "code": "def heuristics_v2(df):\n    # Calculate the daily return\n    df['return'] = df['close'].pct_change()\n    \n    # Calculate 20-day average return\n    avg_return_20 = df['return'].rolling(window=20).mean()\n    \n    # Calculate 20-day average volume\n    avg_volume_20 = df['volume'].rolling(window=20).mean()\n    \n    # Calculate the volume ratio (today's volume / 20-day average volume)\n    volume_ratio = df['volume'] / avg_volume_20\n    \n    # Compute the heuristic factor\n    heuristics_matrix = avg_return_20 * volume_ratio\n    \n    return heuristics_matrix",
          "objective": -0.00957,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a composite factor by taking the difference between the average of the highest and lowest prices over a short-term window and the average of the closing price over a long-term window, aiming to capture momentum and mean reversion tendencies.",
          "code": "def heuristics_v2(df):\n    short_window = 5\n    long_window = 20\n    high_low_avg = (df['high'].rolling(window=short_window).mean() + df['low'].rolling(window=short_window).mean()) / 2\n    close_long_avg = df['close'].rolling(window=long_window).mean()\n    heuristics_matrix = high_low_avg - close_long_avg\n    return heuristics_matrix",
          "objective": -0.00885,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm, named Trend Momentum Heuristics, calculates the difference between the 20-day moving average of closing prices and the 5-day moving average of opening prices to capture short-term momentum and trend signals.",
          "code": "def heuristics_v2(df):\n    df['close_20_ma'] = df['close'].rolling(window=20).mean()\n    df['open_5_ma'] = df['open'].rolling(window=5).mean()\n    heuristics_matrix = df['close_20_ma'] - df['open_5_ma']\n    return heuristics_matrix",
          "objective": -0.00828,
          "other_inf": null
     }
]