```python
import pandas as pd
import numpy as np
from scipy.optimize import minimize

def heuristics_v2(df, dynamic_window_optimizer=True, weight_optimizer=True):
    # Define the lookback periods
    sma_lookback = 20
    vol_adj_lookback = 10
    momentum_lookback = 5
    price_change_lookback = 3
    sentiment_lookback = 10
    
    # Calculate Simple Moving Average (SMA) of Close Prices
    df['SMA'] = df['close'].rolling(window=sma_lookback).mean()
    
    # Compute Volume-Adjusted Volatility
    df['High-Low'] = df['high'] - df['low']
    df['Vol-Adj-High-Low'] = df['High-Low'] * df['volume']
    df['Vol-Adj-Vol'] = df['Vol-Adj-High-Low'].rolling(window=vol_adj_lookback).mean()
    
    # Compute Price Momentum
    df['Momentum'] = (df['close'] - df['SMA']) / df['close'].rolling(window=momentum_lookback).mean()
    
    # Incorporate Additional Price Change Metrics
    df['Price-Change'] = df['close'].pct_change(price_change_lookback)
    df['High-Low-Range'] = df['high'] - df['low']
    
    # Integrate Market Sentiment
    df['Net-Return'] = df['close'].pct_change(sentiment_lookback)
    df['Positive-Return'] = df['Net-Return'].apply(lambda x: x if x > 0 else 0)
    df['Negative-Return'] = df['Net-Return'].apply(lambda x: x if x < 0 else 0)
    df['Sentiment-Score'] = df['Positive-Return'] - df['Negative-Return']
    
    # Dynamically Adjust Lookback Periods
    if dynamic_window_optimizer:
        def evaluate_sharpe_ratio(params):
            sma_lb, vol_adj_lb, mom_lb, pc_lb, sent_lb = map(int, params)
            df['SMA'] = df['close'].rolling(window=sma_lb).mean()
            df['Vol-Adj-Vol'] = (df['high'] - df['low']) * df['volume']
            df['Vol-Adj-Vol'] = df['Vol-Adj-Vol'].rolling(window=vol_adj_lb).mean()
            df['Momentum'] = (df['close'] - df['SMA']) / df['close'].rolling(window=mom_lb).mean()
            df['Price-Change'] = df['close'].pct_change(pc_lb)
            df['Sentiment-Score'] = (df['close'].pct_change(sent_lb) > 0).astype(float)
            factor = df[['Momentum', 'Vol-Adj-Vol', 'Price-Change', 'Sentiment-Score']].dropna().sum(axis=1)
            returns = df['close'].pct_change()
            excess_returns = returns - returns.rolling(window=252).mean()
            sharpe = excess_returns.dropna().mean() / excess_returns.dropna().std()
            return -sharpe
        
        initial_guess = [sma_lookback, vol_adj_lookback, momentum_lookback, price_change_lookback, sentiment_lookback]
        bounds = [(5, 50), (5, 50), (5, 50), (5, 50), (5, 50)]
        result = minimize(evaluate_sharpe_ratio, initial_guess, method='L-BFGS-B', bounds=bounds)
        sma_lookback, vol_adj_lookback, momentum_lookback, price_change_lookback, sentiment_lookback = map(int, result.x)
    
    # Optimize Component Weights
    if weight_optimizer:
        def objective_function(weights):
            factor = (weights[0] * df['Momentum'] + 
                      weights[1] * df['Vol-Adj-Vol'] + 
                      weights[2] * df['Price-Change'] + 
                      weights[3] * df['Sentiment-Score']).dropna()
            returns = df['close'].pct_change()
            excess_returns = returns - returns.rolling(window=252).mean()
            sharpe = excess_returns[factor.index].dropna().mean() / excess_returns[factor.index].dropna().std()
            return -sharpe
        
        constraints = ({'type': 'eq', 'fun': lambda weights: np.sum(weights) - 1})
        bounds = [(0, 1)] * 4
        initial_guess = [0.25, 0.25, 0.25, 0.25]
        result = minimize(objective_function, initial_guess
