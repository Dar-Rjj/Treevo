```python
import pandas as pd

def heuristics_v2(df):
    # Calculate moving averages
    short_term_ma = df['close'].rolling(window=5).mean()
    long_term_ma = df['close'].rolling(window=100).mean()
    
    # Compute the difference between short-term and long-term moving averages
    ma_diff = short_term_ma - long_term_ma
    
    # Calculate the rate of change (ROC) for close prices over 14 days
    roc_14 = df['close'].pct_change(periods=14)
    
    # Calculate the average true range (ATR) over a period of 14 days
    tr = df[['high', 'low']].diff(axis=1).iloc[:, 1].abs()
    atr = tr.rolling(window=14).mean()
    
    # Calculate the on-balance volume (OBV)
    obv = ((df['close'] > df['close'].shift(1)) * df['volume']).cumsum() - ((df['close'] < df['close'].shift(1)) * df['volume']).cumsum()
    
    # Compute the money flow index (MFI) using high, low, close, and volume
    typical_price = (df['high'] + df['low'] + df['close']) / 3
    raw_money_flow = typical_price * df['volume']
    positive_money_flow = raw_money_flow.where(typical_price > typical_price.shift(1), 0)
    negative_money_flow = raw_money_flow.where(typical_price < typical_price.shift(1), 0)
    money_ratio = positive_money_flow.rolling(window=14).sum() / negative_money_flow.rolling(window=14).sum()
    mfi = 100 - 100 / (1 + money_ratio)
    
    # Calculate standard deviation of daily returns over a period of 30 days
    daily_returns = df['close'].pct_change()
    std_dev = daily_returns.rolling(window=30).std()
    
    # Analyze the spread between high and low prices (daily range)
    daily_range = df['high'] - df['low']
    
    # Calculate the relative strength index (RSI) to measure overbought/oversold levels
    rs_gain = daily_returns[daily_returns > 0].rolling(window=14).mean()
    rs_loss = -daily_returns[daily_returns < 0].rolling(window=14).mean()
    rsi = 100 - (100 / (1 + (rs_gain / rs_loss)))
    
    # Compute the Chande momentum oscillator (CMO)
    cmo = ((rs_gain - rs_loss) / (rs_gain + rs_loss)) * 100
    
    # Use the Bollinger Bands to assess volatility and potential breakout points
    bb_mean = df['close'].rolling(window=20).mean()
    bb_std = df['close'].rolling(window=20).std()
    upper_band = bb_mean + 2 * bb_std
    lower_band = bb_mean - 2 * bb_std
    bb_width = (upper_band - lower_band) / bb_mean
    
    # Apply the MACD (Moving Average Convergence Divergence) to identify trends
    ema_12 = df['close'].ewm(span=12, adjust=False).mean()
    ema_26 = df['close'].ewm(span=26, adjust=False).mean()
    macd = ema_12 - ema_26
    signal = macd.ewm(span=9, adjust=False).mean()
    macd_hist = macd - signal
    
    # Create a composite score by summing or averaging selected alpha factors
    composite_score = (ma_diff + roc_14 + atr + obv + mfi + std_dev + daily_range + rsi + cmo + bb_width + macd_hist) / 11
    
    return composite_score
```
