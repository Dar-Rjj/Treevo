```python
import pandas as pd
import numpy as np

def heuristics_v2(df):
    # Calculate Simple Moving Average (SMA) of Closing Prices
    sma_close = df['close'].rolling(window=20).mean()
    
    # Calculate Exponential Moving Average (EMA) of Closing Prices
    ema_close = df['close'].ewm(span=20, adjust=False).mean()
    
    # Determine the Difference Between EMA and SMA
    diff_ema_sma = ema_close - sma_close
    
    # Compute Daily Return
    daily_return = df['close'].pct_change()
    
    # Calculate the Sum of Positive Daily Returns Over a Fixed Period
    sum_positive_returns = daily_return.rolling(window=20).apply(lambda x: x[x > 0].sum(), raw=False)
    
    # Calculate the Sum of Negative Daily Returns Over a Fixed Period
    sum_negative_returns = daily_return.rolling(window=20).apply(lambda x: x[x < 0].sum(), raw=False)
    
    # Determine the Ratio of Positive to Negative Returns
    ratio_pos_neg_returns = sum_positive_returns / sum_negative_returns.abs()
    
    # Calculate the Change in Volume Compared to the Previous Day
    volume_change = df['volume'].diff()
    
    # Identify Days with Significant Volume Changes (e.g., More Than 20% Increase)
    significant_volume_change = (df['volume'] / df['volume'].shift(1) - 1) > 0.20
    
    # Count the Number of Such High-Volume Change Days Within a Fixed Period
    count_high_volume_days = significant_volume_change.rolling(window=20).sum()
    
    # Calculate the Product of the Difference Between EMA and SMA and the Volume Change
    product_diff_ema_sma_vol_change = diff_ema_sma * volume_change
    
    # Determine the Weighted Sum of Daily Returns, Where Weights Are Based on the Volume
    weighted_sum_daily_returns = (daily_return * df['volume']).rolling(window=20).sum() / df['volume'].rolling(window=20).sum()
    
    # Calculate the Range (High - Low) for Each Day
    range_daily = df['high'] - df['low']
    
    # Compute the Ratio of the Range to the Closing Price
    range_to_close_ratio = range_daily / df['close']
    
    # Identify Days with Unusually High Ranges (e.g., More Than 2 Standard Deviations from the Mean)
    high_range_days = range_to_close_ratio > range_to_close_ratio.mean() + 2 * range_to_close_ratio.std()
    
    # Calculate the Gap (open_t - close_{t-1})
    gap = df['open'] - df['close'].shift(1)
    
    # Determine the Direction of the Gap (Positive or Negative)
    gap_direction = np.sign(gap)
    
    # Count the Number of Consecutive Days with Gaps in the Same Direction
    consecutive_gap_days = (gap_direction == gap_direction.shift(1)).rolling(window=20).sum()
    
    # Calculate Daily Price Change
    daily_price_change = df['close'] - df['close'].shift(1)
    
    # Sum of Daily Price Changes Over 20 Days
    sum_daily_price_changes = daily_price_change.rolling(window=20).sum()
    
    # Calculate Volume Weighted Average Price (VWAP)
    vwap = (df[['high', 'low', 'close']].mean(axis=1) * df['volume']).cumsum() / df['volume'].cumsum()
    
    # PMI Score
    pmi_score = sum_daily_price_changes * vwap
    
    # Calculate Intraday Return
    intraday_return = (df['close'] - df['open']) / df['open']
    
    # Calculate Intraday Volatility
    intraday_volatility = (df['high'] - df['low']) / df['close']
    
    # Adjust Intraday Return
    adjusted_intraday_return = intraday_return * (intraday_volatility + volume_change + df['amount'].diff())
    
    # Calculate Close-to-Open Return
    close_to_open_return = (df['close'] - df['open']) / df['open']
    
    # Volume Weighted Close-to-Open Return
    volume_weighted_close_to_open_return = close_to_open_return * df['volume']
    
    # Calculate Daily Log Return
    daily_log_return = np.log(df['close'] / df['close'].shift(1))
    
    # Cumulative Sum of Daily Log Returns
    cumulative_sum_log_returns = daily_log_return.rolling(window=20).sum()
    
    # Calculate 20-Day Momentum
    momentum_20_day = df['close'] / df['close'].shift(2
