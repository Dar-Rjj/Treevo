```python
import pandas as pd
import numpy as np

def heuristics_v2(df):
    # Calculate Daily Range
    daily_range = df['high'] - df['low']
    
    # Calculate Open-to-Close Movement
    open_to_close_movement = df['close'] - df['open']
    
    # Adjust for Volume
    volume_adjusted_breakout_strength = daily_range * np.sqrt(df['volume']) + open_to_close_movement
    
    # Calculate 5-day Momentum
    close_5d_ma = df['close'].rolling(window=5).mean()
    momentum = (df['close'] > close_5d_ma).astype(int) * 2 - 1  # 1 if current > 5-day MA, -1 otherwise
    
    # Combine Indicators
    combined_indicator = volume_adjusted_breakout_strength * momentum + open_to_close_movement
    
    # Filter for Strong Moves
    strong_move_threshold = combined_indicator.quantile(0.75)
    strong_move = (combined_indicator > strong_move_threshold).astype(int)
    
    # Calculate Simple Moving Averages (SMA)
    sma_short_term = df['close'].rolling(window=5).mean()
    sma_long_term = df['close'].rolling(window=20).mean()
    
    # Trend-Following Signal
    trend_signal = sma_short_term - sma_long_term
    
    # Analyze Past Returns
    daily_return = df['close'].pct_change()
    weekly_return = df['close'].pct_change(periods=5)
    monthly_return = df['close'].pct_change(periods=21)
    weighted_sum_returns = (daily_return + weekly_return + monthly_return) / 3
    
    # Measure Overnight Sentiment
    overnight_sentiment = df['open'] - df['close'].shift(1)
    
    # Evaluate Volume-Based Factors
    obv = (np.sign(df['close'].diff()) * df['volume']).cumsum()
    obv_factor = obv.diff() * (df['close'] - df['close'].shift(1))
    
    # Calculate Volume-Adjusted High-Low Spread
    high_low_spread = (df['high'] - df['low']) * df['volume']
    
    # Calculate Volume-Weighted Momentum
    volume_weighted_momentum = (df['close'] - df['close'].shift(1)) * df['volume']
    
    # Calculate Price Change Ratio
    price_change_ratio = df['close'] / df['open']
    
    # Incorporate Enhanced Price Reversion
    ten_day_high = df['high'].rolling(window=10).max()
    ten_day_low = df['low'].rolling(window=10).min()
    proximity_to_high = (ten_day_high - df['close'])
    proximity_to_low = (df['close'] - ten_day_low)
    min_proximity = np.minimum(proximity_to_high, proximity_to_low)
    inverted_proximity = 1 / (min_proximity + 1e-6)  # Avoid division by zero
    std_dev_20d = df['close'].pct_change().rolling(window=20).std()
    enhanced_price_reversion = inverted_proximity / (std_dev_20d + 1e-6)  # Avoid division by zero
    
    # Calculate Moving Sum of High-Low Price Spreads
    moving_sum_high_low_spread = (df['high'] - df['low']).rolling(window=20).sum()
    
    # Calculate Spread Momentum
    spread_momentum = moving_sum_high_low_spread - moving_sum_high_low_spread.shift(1)
    
    # Combine Indicators
    weighted_sum_indicators = 0.4 * volume_adjusted_breakout_strength + 0.3 * spread_momentum + 0.3 * volume_weighted_momentum
    
    # Synthesize Final Alpha Factor
    alpha_factor = (strong_move + 
                    trend_signal + 
                    weighted_sum_returns + 
                    overnight_sentiment + 
                    obv_factor + 
                    high_low_spread + 
                    volume_weighted_momentum) * price_change_ratio * enhanced_price_reversion
    
    return alpha_factor
```
