```python
import pandas as pd
import numpy as np

def heuristics_v2(df):
    # Calculate daily return
    df['daily_return'] = (df['close'] - df['open']) / df['open']
    
    # Define a factor for daily log return
    df['log_return'] = np.log(df['close'] / df['open'])
    
    # Compute the 5-day moving average of the daily return
    df['5_day_ma'] = df['daily_return'].rolling(window=5).mean()
    
    # Calculate the difference between the current day's return and its 5-day moving average
    df['return_diff_5day_ma'] = df['daily_return'] - df['5_day_ma']
    
    # Create a factor that measures the acceleration of returns
    df['acceleration'] = df['5_day_ma'].diff()
    
    # Compute the standard deviation of the past 10 days' daily returns to measure recent volatility
    df['volatility'] = df['daily_return'].rolling(window=10).std()
    
    # Calculate the ratio of the current day's return to the recent volatility
    df['return_to_volatility_ratio'] = df['daily_return'] / df['volatility']
    
    # Create a factor as the ratio of todayâ€™s volume over the average volume of the last 10 days, multiplied by the daily return
    df['volume_ratio'] = df['volume'] / df['volume'].rolling(window=10).mean()
    df['volume_weighted_return'] = df['volume_ratio'] * df['daily_return']
    
    # Introduce a threshold for the volume ratio to create a binary indicator when the volume is significantly higher than the average
    df['high_volume_flag'] = (df['volume_ratio'] > 1.5).astype(int)
    
    # Compute the percentage range as (high - low) / close
    df['percentage_range'] = (df['high'] - df['low']) / df['close']
    
    # Combine the percentage range with the daily return to form a new factor
    df['range_return_factor'] = df['percentage_range'] * df['daily_return']
    
    # Create a factor that considers the interaction between the percentage range and the 5-day moving average of the daily return
    df['range_ma_interaction'] = df['percentage_range'] * df['5_day_ma']
    
    # Identify days where the volume is above the 90th percentile of the past 30 days
    df['high_volume_flag_percentile'] = (df['volume'] > df['volume'].rolling(window=30).quantile(0.9)).astype(int)
    
    # For those days, flag them and create a binary factor
    df['high_volume_binary'] = df['high_volume_flag_percentile'] * np.sign(df['daily_return'])
    
    # Determine if there is a gap up or down (open - previous close)
    df['gap'] = df['open'] - df['close'].shift(1)
    
    # Create a factor based on the magnitude and direction of these gaps, combined with the next day's return
    df['gap_factor'] = df['gap'] * df['daily_return'].shift(-1)
    
    # Extend the factor to include the impact of consecutive gaps over a 5-day period
    df['consecutive_gap_factor'] = df['gap'].rolling(window=5).sum() * df['daily_return'].shift(-1)
    
    # Select the final alpha factor
    alpha_factor = df['consecutive_gap_factor']
    
    return alpha_factor
```
