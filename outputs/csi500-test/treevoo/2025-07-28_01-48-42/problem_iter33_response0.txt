```python
import pandas as pd
import numpy as np

def heuristics_v2(df):
    # Calculate daily return
    df['daily_return'] = (df['close'] - df['open']) / df['open']
    
    # Define a factor for daily log return
    df['log_return'] = np.log(df['close'] / df['open'])
    
    # Create a factor that calculates the cumulative log return over the past 5 days
    df['cum_log_return_5d'] = df['log_return'].rolling(window=5).sum()
    
    # Compute the 10-day moving average of the daily return
    df['ma_daily_return_10d'] = df['daily_return'].rolling(window=10).mean()
    
    # Calculate the difference between the current day's return and its 10-day moving average
    df['return_diff_10d_ma'] = df['daily_return'] - df['ma_daily_return_10d']
    
    # Create a factor that measures the acceleration of returns by computing the difference in the 10-day moving average over consecutive days
    df['acceleration_10d_ma'] = df['ma_daily_return_10d'].diff()
    
    # Compute the standard deviation of the past 20 days' daily returns to measure recent volatility
    df['volatility_20d'] = df['daily_return'].rolling(window=20).std()
    
    # Calculate the ratio of the current day's return to the recent volatility
    df['return_to_volatility'] = df['daily_return'] / df['volatility_20d']
    
    # Introduce a factor that measures the rolling correlation between the daily return and the recent volatility
    df['corr_return_volatility_20d'] = df['daily_return'].rolling(window=20).corr(df['volatility_20d'])
    
    # Create a factor as the ratio of todayâ€™s volume over the average volume of the last 20 days, multiplied by the daily return
    df['volume_ratio_20d'] = df['volume'] / df['volume'].rolling(window=20).mean()
    df['volume_ratio_return'] = df['volume_ratio_20d'] * df['daily_return']
    
    # Introduce a threshold for the volume ratio to create a binary indicator when the volume is significantly higher than the average
    df['high_volume_flag'] = (df['volume_ratio_20d'] > 2.0).astype(int)
    
    # Enhance the binary factor by incorporating the direction and magnitude of the daily return on these high-volume days
    df['high_volume_return'] = df['high_volume_flag'] * df['daily_return']
    
    # Compute the percentage range as (high - low) / close
    df['percentage_range'] = (df['high'] - df['low']) / df['close']
    
    # Combine the percentage range with the daily return to form a new factor
    df['range_return_factor'] = df['percentage_range'] * df['daily_return']
    
    # Create a factor that considers the interaction between the percentage range and the 10-day moving average of the daily return
    df['range_return_10d_ma'] = df['percentage_range'] * df['ma_daily_return_10d']
    
    # Introduce a factor that measures the ratio of the percentage range to the 10-day moving average of the percentage range
    df['range_ratio_10d_ma'] = df['percentage_range'] / df['percentage_range'].rolling(window=10).mean()
    
    # Identify days where the volume is above the 95th percentile of the past 30 days
    df['high_volume_95th'] = (df['volume'] > df['volume'].rolling(window=30).quantile(0.95)).astype(int)
    
    # For those days, flag them and create a binary factor
    df['high_volume_flag_95th'] = df['high_volume_95th']
    
    # Enhance the binary factor by incorporating the direction of the daily return on these flagged days
    df['high_volume_return_95th'] = df['high_volume_flag_95th'] * np.sign(df['daily_return'])
    
    # Extend the binary factor to include the cumulative return over the next 5 days following the flagged days
    df['cumulative_return_5d_high_volume'] = df['high_volume_flag_95th'] * df['daily_return'].shift(-5).rolling(window=5).sum()
    
    # Determine if there is a gap up or down (open - previous close)
    df['gap'] = df['open'] - df['close'].shift(1)
    
    # Create
