```python
import pandas as pd
import numpy as np

def heuristics_v2(data):
    # Calculate daily return
    data['daily_return'] = (data['close'] - data['close'].shift(1)) / data['close'].shift(1)
    
    # Compute moving averages of daily returns
    data['ma_5_daily_return'] = data['daily_return'].rolling(window=5).mean()
    data['ma_20_daily_return'] = data['daily_return'].rolling(window=20).mean()
    
    # Calculate Exponential Moving Average (EMA) with smoothing factor of 2/(N+1)
    data['ema_10_close'] = data['close'].ewm(span=10, adjust=False).mean()
    
    # Calculate Weighted Moving Average (WMA) with exponentially increasing weights
    weights = np.arange(1, 16)
    data['wma_15_close'] = data['close'].rolling(window=15).apply(lambda x: np.dot(x, weights) / weights.sum(), raw=True)
    
    # Integrate EMAs into momentum calculations
    data['price_momentum'] = data['close'] - data['ema_10_close']
    data['integrated_momentum'] = data['close'] - data['wma_15_close'] + data['ma_20_daily_return']
    
    # Intraday range and volatility
    data['intraday_range_ratio'] = (data['high'] - data['low']) / data['close'].shift(1)
    data['upper_shadow'] = data['high'] - data[['open', 'close']].max(axis=1)
    data['lower_shadow'] = data[['open', 'close']].min(axis=1) - data['low']
    data['shadow_ratio'] = data['upper_shadow'] / data['lower_shadow']
    data['volume_adjusted_high_low_range'] = (data['high'] - data['low']) * np.sqrt(np.log(data['volume']))
    
    # 10-day Historical Volatility
    data['log_returns'] = np.log(data['close'] / data['close'].shift(1))
    data['hist_volatility_10'] = data['log_returns'].rolling(window=10).std() * np.sqrt(252)
    
    # Volume and its interaction with price
    data['volume_change'] = data['volume'] - data['volume'].shift(1)
    data['volume_ratio'] = data['volume'] / data['volume'].rolling(window=20).mean()
    data['daily_log_return'] = np.log(data['close'] / data['close'].shift(1))
    data['accumulated_log_return_volume'] = (data['daily_log_return'] * data['volume_change']).rolling(window=10).sum()
    
    # Enhanced Volume Thrust
    data['upward_thrust'] = data.apply(lambda x: x['volume'] * (x['close'] - x['open']) if x['close'] > x['open'] else 0, axis=1)
    data['downward_thrust'] = data.apply(lambda x: x['volume'] * (x['open'] - x['close']) if x['close'] <= x['open'] else 0, axis=1)
    data['enhanced_volume_thrust'] = data['upward_thrust'] - data['downward_thrust'] + (data['high'] - data['low']) / data['open']
    
    # Moving average crossover signals
    data['ema_5_close'] = data['close'].ewm(span=5, adjust=False).mean()
    data['ema_20_close'] = data['close'].ewm(span=20, adjust=False).mean()
    data['crossover_signal'] = np.where(data['ema_5_close'] > data['ema_20_close'], 1, np.where(data['ema_5_close'] < data['ema_20_close'], -1, 0))
    
    # Construct final composite alpha factor
    data['alpha_factor'] = (
        data['price_momentum'] +
        data['integrated_momentum'] -
        data['volume_adjusted_high_low_range'] -
        data['shadow_ratio'] +
        data['accumulated_log_return_volume'] +
        data['crossover_signal'] +
        data['enhanced_volume_thrust'] +
        data['hist_volatility_10'] * data['enhanced_volume_thrust']
    )
    
    return data['alpha_factor']
```
