```python
import pandas as pd

def heuristics_v2(df):
    # Calculate simple moving averages (SMA) for closing prices over different periods
    df['SMA_5'] = df['close'].rolling(window=5).mean()
    df['SMA_10'] = df['close'].rolling(window=10).mean()
    df['SMA_20'] = df['close'].rolling(window=20).mean()
    df['SMA_50'] = df['close'].rolling(window=50).mean()
    df['SMA_100'] = df['close'].rolling(window=100).mean()

    # Compare current close price with the SMAs to determine momentum or reversion signals
    df['SMA_5_Signal'] = (df['close'] - df['SMA_5']) / df['SMA_5']
    df['SMA_10_Signal'] = (df['close'] - df['SMA_10']) / df['SMA_10']
    df['SMA_20_Signal'] = (df['close'] - df['SMA_20']) / df['SMA_20']
    df['SMA_50_Signal'] = (df['close'] - df['SMA_50']) / df['SMA_50']
    df['SMA_100_Signal'] = (df['close'] - df['SMA_100']) / df['SMA_100']

    # Develop price rate of change (ROC) indicators for multiple time frames
    def calculate_roc(series, period):
        return (series - series.shift(period)) / series.shift(period)

    df['ROC_5'] = calculate_roc(df['close'], 5)
    df['ROC_10'] = calculate_roc(df['close'], 10)
    df['ROC_20'] = calculate_roc(df['close'], 20)
    df['ROC_50'] = calculate_roc(df['close'], 50)
    df['ROC_100'] = calculate_roc(df['close'], 100)

    # Create a volume-based ROC by calculating the percentage change in daily volume
    df['Volume_ROC_5'] = calculate_roc(df['volume'], 5)
    df['Volume_ROC_10'] = calculate_roc(df['volume'], 10)
    df['Volume_ROC_20'] = calculate_roc(df['volume'], 20)
    df['Volume_ROC_50'] = calculate_roc(df['volume'], 50)
    df['Volume_ROC_100'] = calculate_roc(df['volume'], 100)

    # Utilize candlestick patterns as short-term trend indicators
    def is_doji(open, high, low, close):
        return abs(close - open) / (high - low) < 0.1

    def is_bullish_engulfing(open, high, low, close, prev_open, prev_close):
        return prev_open > prev_close and open < close and close > prev_open and open < prev_close

    def is_bearish_engulfing(open, high, low, close, prev_open, prev_close):
        return prev_open < prev_close and open > close and close < prev_open and open > prev_close

    df['Doji'] = df.apply(lambda row: is_doji(row['open'], row['high'], row['low'], row['close']), axis=1).astype(int)
    df['Bullish_Engulfing'] = df.apply(lambda row: is_bullish_engulfing(row['open'], row['high'], row['low'], row['close'], df.loc[row.name - pd.Timedelta(days=1), 'open'], df.loc[row.name - pd.Timedelta(days=1), 'close']), axis=1).astype(int)
    df['Bearish_Engulfing'] = df.apply(lambda row: is_bearish_engulfing(row['open'], row['high'], row['low'], row['close'], df.loc[row.name - pd.Timedelta(days=1), 'open'], df.loc[row.name - pd.Timedelta(days=1), 'close']), axis=1).astype(int)

    # Calculate the ratio between the difference of high and low, and the previous close, to gauge volatility
    df['Volatility_Ratio'] = (df['high'] - df['low']) / df['close'].shift(1)

    # Compute the average transaction size (Amount / Volume) over various lookback periods
    df['Avg_Transaction_Size_5'] = (df['amount'] / df['volume']).rolling(window=5
