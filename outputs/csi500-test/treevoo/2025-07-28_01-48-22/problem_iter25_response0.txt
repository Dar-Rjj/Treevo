```python
import pandas as pd

def heuristics_v2(df):
    # Calculate Day Range
    df['day_range'] = df['high'] - df['low']
    
    # Measure Relative Day Range to Previous Close
    df['relative_day_range'] = df['day_range'] / df['close'].shift(1)
    
    # Compute Average Volume over a Fixed Period (e.g., 20 days)
    df['avg_volume_20'] = df['volume'].rolling(window=20).mean()
    
    # Determine if Volume is Above or Below its Average
    df['volume_above_avg'] = df['volume'] > df['avg_volume_20']
    
    # Assess the Impact of Volume on Daily Returns
    df['return'] = df['close'].pct_change()
    df['volume_impact_return'] = df['return'] * df['volume_above_avg'].astype(int)
    
    # Calculate Simple Moving Averages (SMA) for Different Periods
    df['sma_5'] = df['close'].rolling(window=5).mean()
    df['sma_20'] = df['close'].rolling(window=20).mean()
    
    # Generate Buy/Sell Signal
    df['sma_signal'] = (df['sma_5'] > df['sma_20']).astype(int)
    
    # Count Number of Consecutive Positive or Negative Returns
    df['consecutive_positive_returns'] = (df['return'] > 0).groupby((df['return'] <= 0).cumsum()).cumsum()
    df['consecutive_negative_returns'] = (df['return'] < 0).groupby((df['return'] >= 0).cumsum()).cumsum()
    
    # Establish Overbought/Oversold Conditions Based on Consecutive Trends
    df['overbought'] = (df['consecutive_positive_returns'] >= 3).astype(int)
    df['oversold'] = (df['consecutive_negative_returns'] >= 3).astype(int)
    
    # Calculate Volume Weighted Average Price (VWAP)
    df['vwap'] = (df['amount'] / df['volume']).cumsum() / (1 + df['volume'].cumsum())
    
    # Compare VWAP with Closing Price
    df['vwap_vs_close'] = df['vwap'] - df['close']
    
    # Calculate Daily Return
    df['daily_return'] = df['close'] - df['open']
    
    # Classify Gaps as Up, Down, or No Gap
    df['gap_up'] = (df['open'] > df['close'].shift(1)).astype(int)
    df['gap_down'] = (df['open'] < df['close'].shift(1)).astype(int)
    df['no_gap'] = ((df['gap_up'] == 0) & (df['gap_down'] == 0)).astype(int)
    
    # Evaluate the Sustainability of Gaps Over the Next Few Days
    df['gap_sustainability'] = (df['gap_up'] * (df['close'] > df['open'].shift(1))) + \
                               (df['gap_down'] * (df['close'] < df['open'].shift(1)))
    
    # Combine all factors into a single alpha factor
    df['alpha_factor'] = (
        df['relative_day_range'] +
        df['volume_impact_return'] +
        df['sma_signal'] +
        df['overbought'] -
        df['oversold'] +
        df['vwap_vs_close'] +
        df['daily_return'] +
        df['gap_sustainability']
    )
    
    return df['alpha_factor']
```
