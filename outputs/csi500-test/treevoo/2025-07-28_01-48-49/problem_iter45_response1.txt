```python
import pandas as pd
import numpy as np

def wma(series, period):
    weights = np.arange(1, period + 1)
    return (series.rolling(window=period).apply(lambda x: np.dot(x, weights) / weights.sum(), raw=True))

def rsi(series, period):
    delta = series.diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
    rs = gain / loss
    return 100 - (100 / (1 + rs))

def heuristics(df):
    # Calculate WMA of closing prices
    df['WMA_50'] = wma(df['close'], 50)
    df['WMA_200'] = wma(df['close'], 200)
    
    # Calculate RSI based on closing prices
    df['RSI_14'] = rsi(df['close'], 14)
    df['RSI_WMA_14'] = rsi(df['WMA_50'], 14)
    df['RSI_28'] = rsi(df['close'], 28)
    
    # Evaluate daily price movement
    df['Daily_Price_Movement'] = df['close'].diff()
    df['Cumulative_Sum_20'] = df['Daily_Price_Movement'].rolling(window=20).sum()
    df['Average_Daily_Movement_20'] = df['Daily_Price_Movement'].rolling(window=20).mean()
    df['Std_Dev_Daily_Movement_20'] = df['Daily_Price_Movement'].rolling(window=20).std()
    
    # Measure volume ratio and momentum
    df['SMA_Volume_20'] = df['volume'].rolling(window=20).mean()
    df['Volume_Ratio'] = df['volume'] / df['SMA_Volume_20']
    df['ROC_Volume_20'] = df['volume'].pct_change(periods=20)
    df['SMA_Volume_50'] = df['volume'].rolling(window=50).mean()
    df['Normalized_Volume'] = df['volume'] / df['SMA_Volume_50']
    
    # Investigate high and low prices to calculate volatility
    df['True_Range'] = df[['high', 'low']].apply(lambda x: max(x['high'] - x['low'], abs(x['high'] - df['close'].shift(1)), abs(x['low'] - df['close'].shift(1))), axis=1)
    df['ATR_14'] = df['True_Range'].rolling(window=14).mean()
    df['ATR_50'] = df['True_Range'].rolling(window=50).mean()
    
    # Analyze price gaps
    df['Price_Gap'] = df['open'] - df['close'].shift(1)
    df['Up_Gaps'] = df['Price_Gap'].apply(lambda x: x if x > 0 else 0)
    df['Down_Gaps'] = df['Price_Gap'].apply(lambda x: x if x < 0 else 0)
    df['Total_Up_Gaps'] = df['Up_Gaps'].rolling(window=20).count()
    df['Total_Down_Gaps'] = df['Down_Gaps'].rolling(window=20).count()
    df['Avg_Up_Gap_Size'] = df['Up_Gaps'].rolling(window=20).mean()
    df['Avg_Down_Gap_Size'] = df['Down_Gaps'].rolling(window=20).mean()
    df['Total_Gap_Size'] = df['Price_Gap'].rolling(window=20).sum()
    
    # Explore momentum
    df['ROC_10'] = df['close'].pct_change(periods=10)
    df['ROC_20'] = df['close'].pct_change(periods=20)
    df['ROC_60'] = df['close'].pct_change(periods=60)
    
    # Incorporate the accumulation/distribution line
    df['A_D_Line'] = ((df['close'] - df['low']) - (df['high'] - df['close'])) / (df['high'] - df['low']) * df['volume']
    df['A_D_Line'] = df['A_D_Line'].cumsum()
    df['A_D_Line_ROC_20'] = df['A_D_Line'].pct_change(periods=20)
    
    # Adjusted A/D line using median of high, low, and close
