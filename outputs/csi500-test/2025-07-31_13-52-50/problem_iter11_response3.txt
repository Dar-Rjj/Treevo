```python
import pandas as pd

def heuristics_v2(df):
    # Calculate Daily Returns
    df['daily_return'] = df['close'].pct_change()
    
    # Compute Moving Average of Daily Returns (n=20)
    n = 20
    df['ma_daily_return'] = df['daily_return'].rolling(window=n).mean()
    
    # Calculate Volume Change
    df['volume_change'] = df['volume'].pct_change()
    
    # Calculate Price Momentum Factor (n=20)
    df['price_momentum'] = df['daily_return'].rolling(window=n).sum()
    
    # Calculate Volume Momentum Factor (m=10)
    m = 10
    df['volume_momentum'] = df['volume_change'].rolling(window=m).sum()
    
    # Combine Price and Volume Momentum
    k1 = 1.0
    k2 = 0.5
    df['combined_momentum'] = k1 * df['price_momentum'] + k2 * df['volume_momentum']
    
    # Calculate High-Low Range
    df['high_low_range'] = df['high'] - df['low']
    
    # Calculate Price Breakout Ratio
    df['price_breakout_ratio'] = (df['high'] - df['open']) / df['high_low_range']
    
    # Calculate Volume Breakout Indicator
    df['volume_breakout_indicator'] = df['volume'] * (df['close'] - df['open'])
    
    # Aggregate Breakout Indicators
    df['volume_weighted_breakout_ratio'] = df['price_breakout_ratio'] * df['volume_breakout_indicator']
    df['aggregate_breakout'] = df['volume_weighted_breakout_ratio'].rolling(window=n).sum()
    
    # Smooth with Moving Average (Window Size = 20)
    window_size = 20
    df['smoothed_aggregate_breakout'] = df['aggregate_breakout'].rolling(window=window_size).mean()
    
    # Combine Moving Average and Volume Weight
    df['average_volume'] = df['volume'].rolling(window=n).mean()
    df['volume_weight'] = df['volume'] / df['average_volume']
    df['weighted_smoothed_breakout'] = df['smoothed_aggregate_breakout'] * df['volume_weight']
    
    # Calculate Intraday Return
    df['intraday_return'] = (df['high'] - df['low']) / df['open']
    
    # Adjust for Volume
    df['volume_deviation'] = df['volume'] - df['volume'].rolling(window=10).mean()
    df['adjusted_intraday_return'] = df['volume_deviation'] * df['intraday_return']
    
    # Incorporate Price Volatility
    std_window = 5
    df['price_volatility'] = df['close'].rolling(window=std_window).std()
    volatility_factor = df['price_volatility'].apply(lambda x: 1.2 if x > df['price_volatility'].median() else 0.8)
    df['adjusted_intraday_return'] = df['adjusted_intraday_return'] * volatility_factor
    
    # Identify Trend Reversal Potential
    df['prev_daily_return_deviation'] = df['daily_return'].diff().shift(1)
    df['current_daily_return_deviation'] = df['daily_return'].diff()
    df['trend_reversal'] = (df['current_daily_return_deviation'] > df['prev_daily_return_deviation']).astype(int)
    df['volume_increase'] = (df['volume'] > df['volume'].rolling(window=14).mean()).astype(int)
    
    # Final Composite Factor Calculation
    df['composite_factor'] = df['trend_reversal'] * df['volume_increase'] + df['combined_momentum'] + df['weighted_smoothed_breakout'] + df['adjusted_intraday_return']
    
    return df['composite_factor'].dropna()
```
