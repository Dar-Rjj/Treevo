```python
def heuristics_v2(df: pd.DataFrame) -> pd.Series:
    # Calculate the adaptive momentum as the difference between today's close and the 20-day simple moving average of the close
    adaptive_momentum = df['close'] - df['close'].rolling(window=20).mean()
    
    # Compute the exponential moving average (EMA) of the volume over 15 days for a more responsive liquidity measure
    ema_volume = df['volume'].ewm(span=15, adjust=False).mean()
    
    # Calculate the ratio of the high to the 15-day EMA of the high to capture relative strength
    relative_high_ema = df['high'] / df['high'].ewm(span=15, adjust=False).mean()
    
    # Incorporate a measure of volatility using the standard deviation of the last 20 days' closing prices
    volatility = df['close'].rolling(window=20).std()
    
    # Include a price pattern indicator: difference between the highest and lowest price over the past 15 days
    price_range = df['high'].rolling(window=15).max() - df['low'].rolling(window=15).min()
    
    # Consider bid-ask spread: if 'bid' and 'ask' are available in the DataFrame
    bid_ask_spread = df['ask'] - df['bid'] if 'ask' in df and 'bid' in df else 0
    
    # Cross-asset factor: calculate the correlation with another asset's returns (e.g., S&P 500)
    if 'sp500_returns' in df:
        cross_asset_factor = df['close'].pct_change().rolling(window=20).corr(df['sp500_returns'])
    else:
        cross_asset_factor = 1.0  # Default to 1.0 if no cross-asset data is available
    
    # Combine the components into a single factor with multiplicative and additive combinations
    factor_values = (adaptive_momentum * ema_volume * relative_high_ema * cross_asset_factor) / (volatility + price_range + bid_ask_spread)
    
    return factor_values
```
