```python
def heuristics_v2(df: pd.DataFrame) -> pd.Series:
    import pandas as pd
    import numpy as np
    from statsmodels.tsa.seasonal import seasonal_decompose
    from sklearn.ensemble import RandomForestRegressor
    import calendar

    # Calculate the daily volatility as the difference between high and low
    daily_volatility = df['high'] - df['low']

    # Calculate an exponential moving average for the close price over 5 days as a more responsive trend indicator
    ema_5 = df['close'].ewm(span=5, adjust=False).mean()

    # Determine if today's close is above the 5-day EMA, indicating an upward momentum
    momentum = (df['close'] > ema_5).astype(int)

    # Calculate the volume-weighted return of the last 3 days with a higher weight on recent data
    weighted_return = (df['close'].pct_change().fillna(0) * df['volume']).rolling(window=3).sum() / df['volume'].rolling(window=3).sum()

    # Calculate the RSI (Relative Strength Index) for the last 14 days using an exponential moving average for smoothing
    delta = df['close'].diff()
    gain = (delta.where(delta > 0, 0)).ewm(span=14, adjust=False).mean()
    loss = (-delta.where(delta < 0, 0)).ewm(span=14, adjust=False).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))

    # Incorporate seasonality
    df['month'] = df.index.month
    df['day_of_week'] = df.index.dayofweek
    df['day_of_month'] = df.index.day
    df['quarter'] = df.index.quarter

    # Calculate the day of the month effect
    df['day_effect'] = df.groupby('day_of_month')['close'].transform(lambda x: (x - x.mean()) / x.std()).fillna(0)

    # Calculate the week of the year effect
    df['week_effect'] = df.groupby('week')['close'].transform(lambda x: (x - x.mean()) / x.std()).fillna(0)

    # Use machine learning to predict the next day's return
    X = df[['close', 'high', 'low', 'volume', 'momentum', 'rsi', 'day_effect', 'week_effect']]
    y = df['close'].shift(-1) / df['close'] - 1
    X.dropna(inplace=True)
    y = y[X.index]
    model = RandomForestRegressor(n_estimators=100, random_state=42)
    model.fit(X, y)
    df['predicted_return'] = model.predict(X)

    # Create a factor combining inverse volatility, momentum, RSI, volume-weighted return, and predicted return
    factor = (1 / (daily_volatility + 1e-7)) * momentum * (rsi / 100) * weighted_return * df['predicted_return']

    return factor
```
