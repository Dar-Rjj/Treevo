```python
import pandas as pd
import numpy as np

def heuristics_v2(df):
    # Calculate daily return
    df['daily_return'] = (df['close'] - df['close'].shift(1)) / df['close'].shift(1)
    
    # Calculate intraday return
    df['intraday_return'] = (df['close'] - df['open']) / df['open']
    
    # Calculate upper and lower shadows
    df['upper_shadow'] = df['high'] - df[['open', 'close']].max(axis=1)
    df['lower_shadow'] = df[['open', 'close']].min(axis=1) - df['low']
    
    # Calculate volume change
    df['volume_change'] = df['volume'] - df['volume'].shift(1)
    
    # Calculate average transaction size
    df['avg_transaction_size'] = df['amount'] / df['volume']
    
    # Calculate price momentum (e.g., 5-day momentum)
    df['price_momentum'] = df['close'] - df['close'].rolling(window=5).mean()
    
    # Calculate volatility (e.g., 5-day standard deviation of daily returns)
    df['volatility'] = df['daily_return'].rolling(window=5).std()
    
    # Combined factor: price momentum * (volume[t] / mean(volume[t-5:t])) if daily return > 0
    df['combined_factor'] = np.where(df['daily_return'] > 0, 
                                      df['price_momentum'] * (df['volume'] / df['volume'].rolling(window=5).mean()), 0)
    
    # Positive to negative intraday return ratio (e.g., over 5 days)
    positive_intraday_returns = df['intraday_return'].apply(lambda x: max(0, x)).rolling(window=5).sum()
    negative_intraday_returns = df['intraday_return'].apply(lambda x: min(0, x)).rolling(window=5).sum().abs()
    df['pos_neg_intraday_ratio'] = positive_intraday_returns / negative_intraday_returns.replace(0, np.nan)
    
    # Large move days: |daily return| > 0.03 (3% threshold)
    df['large_move'] = np.abs(df['daily_return']) > 0.03
    
    # Frequency of large moves (e.g., over 20 days)
    df['frequency_large_moves'] = df['large_move'].rolling(window=20).sum()
    
    # Long-term trend (e.g., slope of linear regression over 60 days)
    def rolling_slope(x):
        y = x.values
        x = np.arange(len(y))
        m, b = np.polyfit(x, y, 1)
        return m
    df['long_term_trend'] = df['close'].rolling(window=60).apply(rolling_slope, raw=False)
    
    # Consistency of price movement
    df['consistency'] = np.sign(df['daily_return']) * np.sign(df['intraday_return'])
    
    # Trend-momentum indicator
    df['trend_momentum'] = df['long_term_trend'] * df['price_momentum']
    
    # Bearishness: upper shadow / (high[t] - low[t])
    df['bearishness'] = df['upper_shadow'] / (df['high'] - df['low'])
    
    # Bullishness: (high[t] - low[t]) / upper shadow
    df['bullishness'] = (df['high'] - df['low']) / df['upper_shadow'].replace(0, np.nan)
    
    # Weighted composite score (example: 50% consistency, 30% combined factor, 20% long-term trend)
    df['weighted_composite'] = 0.5 * df['consistency'] + 0.3 * df['combined_factor'] + 0.2 * df['long_term_trend']
    
    # Return the final alpha factor
    return df['weighted_composite']

# Example usage:
# df = pd.DataFrame({
#     'date': pd.date_range(start='2023-01-01', periods=100),
#     'open': np.random.rand(100) * 100,
#     'high': np.random.rand(100) * 110,
#     'low': np.random.rand(100) * 90,
#     'close': np.random.rand(100) * 100,
#     'volume': np.random.randint(1000, 5000, 100),
#     'amount': np.random.randint(10000
