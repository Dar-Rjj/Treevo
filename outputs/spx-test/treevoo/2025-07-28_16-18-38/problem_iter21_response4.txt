```python
import pandas as pd

def heuristics_v2(df):
    # Calculate short-term and long-term simple moving averages of close prices
    df['SMA_50'] = df['close'].rolling(window=50).mean()
    df['SMA_200'] = df['close'].rolling(window=200).mean()
    
    # Create a momentum indicator by subtracting long-term SMA from short-term SMA
    df['momentum'] = df['SMA_50'] - df['SMA_200']
    
    # Compute daily returns
    df['daily_return'] = df['close'].pct_change()
    
    # Calculate standard deviation of daily returns over a specific window
    df['volatility'] = df['daily_return'].rolling(window=20).std()
    
    # Check for inside bars
    df['inside_bar'] = (df['high'] < df['high'].shift(1)) & (df['low'] > df['low'].shift(1))
    
    # Check for outside bars
    df['outside_bar'] = (df['high'] > df['high'].shift(1)) & (df['low'] < df['low'].shift(1))
    
    # Calculate the sum of volume for days with positive and negative returns
    df['positive_volume_sum'] = df[df['daily_return'] > 0]['volume'].rolling(window=20).sum()
    df['negative_volume_sum'] = df[df['daily_return'] < 0]['volume'].rolling(window=20).sum()
    
    # Generate a ratio of positive to negative volume sums
    df['volume_ratio'] = df['positive_volume_sum'] / df['negative_volume_sum']
    
    # Identify recent support levels (lowest low over a specific period)
    df['support'] = df['low'].rolling(window=20).min()
    
    # Identify recent resistance levels (highest high over a specific period)
    df['resistance'] = df['high'].rolling(window=20).max()
    
    # Flag days when close price exceeds resistance or falls below support
    df['breakout'] = (df['close'] > df['resistance']) | (df['close'] < df['support'])
    
    # Identify days with volume significantly higher than average
    df['avg_volume'] = df['volume'].rolling(window=20).mean()
    df['volume_spike'] = df['volume'] > 1.5 * df['avg_volume']
    
    # Assign a score based on the magnitude of the volume spike
    df['spike_score'] = df['volume'] / df['avg_volume'] * df['volume_spike']
    
    # Calculate the difference between today's open and yesterday's close
    df['open_gap'] = df['open'] - df['close'].shift(1)
    
    # Categorize as gap up or gap down
    df['gap_up'] = (df['open_gap'] > 0) & (df['close'] > df['open'])
    df['gap_down'] = (df['open_gap'] < 0) & (df['close'] < df['open'])
    
    # Evaluate the gap size relative to the average true range (ATR)
    df['true_range'] = df[['high' - 'low', 'high' - 'close'].shift(1), 'close'.shift(1) - 'low']].max(axis=1)
    df['atr'] = df['true_range'].rolling(window=20).mean()
    df['gap_size_relative_to_atr'] = df['open_gap'].abs() / df['atr']
    
    # Compute VWAP
    df['vwap'] = (df['volume'] * (df['high'] + df['low'] + df['close']) / 3).cumsum() / df['volume'].cumsum()
    
    # Compare VWAP with the current close price
    df['vwap_signal'] = (df['close'] > df['vwap']).astype(int) - (df['close'] < df['vwap']).astype(int)
    
    # Calculate the percentage of days in a window with positive and negative returns
    df['positive_return_days'] = df['daily_return'].apply(lambda x: x > 0).rolling(window=20).mean()
    df['negative_return_days'] = df['daily_return'].apply(lambda x: x < 0).rolling(window=20).mean()
    
    # Generate a sentiment score based on the difference between positive and negative day percentages
    df['sentiment_score'] = df['positive_return_days'] - df['negative_return_days']
    
    # Compute RSI
    delta = df['close'].diff()
    gain = delta.where(delta > 0, 0)
   
