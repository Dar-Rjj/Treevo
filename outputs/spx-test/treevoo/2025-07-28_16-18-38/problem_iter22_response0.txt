```python
import pandas as pd

def heuristics_v2(df):
    # Calculate Short-Term and Long-Term SMAs
    short_term_sma = df['close'].rolling(window=10).mean()
    long_term_sma = df['close'].rolling(window=50).mean()
    
    # Create a Momentum Indicator
    momentum_indicator = short_term_sma - long_term_sma
    
    # Compute Daily Returns
    daily_returns = df['close'].pct_change()
    
    # Calculate Standard Deviation of Daily Returns over a Specific Window
    volatility = daily_returns.rolling(window=20).std()
    
    # Check for Inside Bars
    inside_bars = (df['high'] < df['high'].shift(1)) & (df['low'] > df['low'].shift(1))
    
    # Check for Outside Bars
    outside_bars = (df['high'] > df['high'].shift(1)) & (df['low'] < df['low'].shift(1))
    
    # Calculate the Sum of Volume for Days with Positive Returns
    positive_volume_sum = df[daily_returns > 0]['volume'].rolling(window=20).sum()
    
    # Calculate the Sum of Volume for Days with Negative Returns
    negative_volume_sum = df[daily_returns < 0]['volume'].rolling(window=20).sum()
    
    # Generate a Ratio of Positive to Negative Volume Sums
    volume_ratio = positive_volume_sum / negative_volume_sum
    
    # Identify Recent Support Levels
    support_levels = df['low'].rolling(window=20).min()
    
    # Identify Recent Resistance Levels
    resistance_levels = df['high'].rolling(window=20).max()
    
    # Flag Days When Close Price Exceeds Resistance or Falls Below Support
    breakout_signal = (df['close'] > resistance_levels) | (df['close'] < support_levels)
    
    # Identify Days with Volume Significantly Higher than Average
    volume_spike = df['volume'] > df['volume'].rolling(window=20).mean() * 2
    
    # Assign a Score Based on the Magnitude of the Volume Spike
    volume_spike_score = df['volume'] / df['volume'].rolling(window=20).mean()
    
    # Calculate the Difference Between Today's Open and Yesterday's Close
    gap = df['open'] - df['close'].shift(1)
    
    # Categorize as Gap Up or Gap Down
    gap_up = gap > 0
    gap_down = gap < 0
    
    # Evaluate the Gap Size Relative to the Average True Range (ATR)
    true_range = df['high'] - df['low']
    atr = true_range.rolling(window=20).mean()
    gap_size = gap.abs() / atr
    
    # Compute VWAP
    vwap = (df['close'] * df['volume']).cumsum() / df['volume'].cumsum()
    
    # Generate a Signal When Close Price is Above or Below VWAP
    vwap_signal = (df['close'] > vwap) * 1 - (df['close'] < vwap) * 1
    
    # Calculate the Percentage of Days in a Window with Positive Returns
    positive_days = (daily_returns > 0).rolling(window=20).mean()
    
    # Calculate the Percentage of Days in a Window with Negative Returns
    negative_days = (daily_returns < 0).rolling(window=20).mean()
    
    # Generate a Sentiment Score Based on the Difference Between Positive and Negative Day Percentages
    sentiment_score = positive_days - negative_days
    
    # Combine all factors into a single alpha factor
    alpha_factor = (
        momentum_indicator + 
        volatility + 
        inside_bars * 1 + 
        outside_bars * (-1) + 
        volume_ratio + 
        breakout_signal * 1 + 
        volume_spike_score + 
        gap_up * 1 + 
        gap_down * (-1) + 
        gap_size + 
        vwap_signal + 
        sentiment_score
    )
    
    return alpha_factor
```
