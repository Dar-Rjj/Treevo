[
     {
          "algorithm": "The new algorithm calculates the heuristics factor by averaging the ratio of the current close price to the 20-day minimum close price with the negative of the ratio of the current close price to the 20-day maximum close price, focusing on a shorter time frame.",
          "code": "def heuristics_v2(df):\n    min_close_20 = df['close'].rolling(window=20).min()\n    max_close_20 = df['close'].rolling(window=20).max()\n    ratio_min = df['close'] / min_close_20\n    ratio_max = -df['close'] / max_close_20\n    heuristics_matrix = (ratio_min + ratio_max) / 2\n    return heuristics_matrix",
          "objective": -0.03161,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the heuristics factor by combining the ratio of the current close price to the 30-day minimum close price with the negative of the ratio of the current close price to the 30-day maximum close price, capturing both the relative strength and weakness compared to recent historical prices.",
          "code": "def heuristics_v2(df):\n    min_close_30 = df['close'].rolling(window=30).min()\n    max_close_30 = df['close'].rolling(window=30).max()\n    ratio_min = df['close'] / min_close_30\n    ratio_max = -df['close'] / max_close_30\n    heuristics_matrix = (ratio_min + ratio_max).dropna()\n    return heuristics_matrix",
          "objective": -0.031,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the heuristics factor using the square of the ratio of the current close price to the 20-day minimum close price, and the negative square of the ratio of the current close price to the 20-day maximum close price, providing a measure that highlights shorter-term market strength or weakness.",
          "code": "def heuristics_v2(df):\n    min_close_20 = df['close'].rolling(window=20).min()\n    max_close_20 = df['close'].rolling(window=20).max()\n    ratio_min = (df['close'] / min_close_20) ** 2\n    ratio_max = - (df['close'] / max_close_20) ** 2\n    heuristics_matrix = (ratio_min + ratio_max).dropna()\n    return heuristics_matrix",
          "objective": -0.03033,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the heuristics factor by combining the square of the ratio of the current close price to the 30-day minimum close price with the negative square of the ratio of the current close price to the 30-day maximum close price, aiming to emphasize periods of relative extreme strength or weakness.",
          "code": "def heuristics_v2(df):\n    min_close_30 = df['close'].rolling(window=30).min()\n    max_close_30 = df['close'].rolling(window=30).max()\n    ratio_min = (df['close'] / min_close_30) ** 2\n    ratio_max = - (df['close'] / max_close_30) ** 2\n    heuristics_matrix = (ratio_min + ratio_max).dropna()\n    return heuristics_matrix",
          "objective": -0.02987,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the heuristics factor using a 20-day EMA of close prices, combined with the ratio of the current close price to this EMA and the negative of the ratio of the current close price to the 20-day maximum close price.",
          "code": "def heuristics_v2(df):\n    ema_close_20 = df['close'].ewm(span=20).mean()\n    max_close_20 = df['close'].rolling(window=20).max()\n    ratio_ema = df['close'] / ema_close_20\n    ratio_max = -df['close'] / max_close_20\n    heuristics_matrix = (ratio_ema + ratio_max).dropna()\n    return heuristics_matrix",
          "objective": -0.02935,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the heuristics factor by combining the cube of the ratio of the current close price to the 20-day minimum close price with the negative cube of the ratio of the current close price to the 20-day maximum close price, adjusting for shorter-term volatility.",
          "code": "def heuristics_v2(df):\n    min_close_20 = df['close'].rolling(window=20).min()\n    max_close_20 = df['close'].rolling(window=20).max()\n    ratio_min = (df['close'] / min_close_20) ** 3\n    ratio_max = - (df['close'] / max_close_20) ** 3\n    heuristics_matrix = (ratio_min + ratio_max).dropna()\n    return heuristics_matrix",
          "objective": -0.02845,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the heuristics factor using the cube of the ratio of the current close price to the 30-day minimum close price, and the negative cube of the ratio of the current close price to the 30-day maximum close price, further accentuating periods of extreme strength or weakness.",
          "code": "def heuristics_v2(df):\n    min_close_30 = df['close'].rolling(window=30).min()\n    max_close_30 = df['close'].rolling(window=30).max()\n    ratio_min = (df['close'] / min_close_30) ** 3\n    ratio_max = - (df['close'] / max_close_30) ** 3\n    heuristics_matrix = (ratio_min + ratio_max).dropna()\n    return heuristics_matrix",
          "objective": -0.02794,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the heuristics factor by taking the square root of the current close price, subtracting it from the mean of the 30-day high and low prices, and then dividing this result by the standard deviation of the 30-day close prices, to capture deviations from the average price range.",
          "code": "def heuristics_v2(df):\n    avg_high_low_30 = (df['high'].rolling(window=30).mean() + df['low'].rolling(window=30).mean()) / 2\n    std_close_30 = df['close'].rolling(window=30).std()\n    heuristic_val = (avg_high_low_30 - df['close'] ** 0.5) / std_close_30\n    heuristics_matrix = heuristic_val.dropna()\n    return heuristics_matrix",
          "objective": -0.02655,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes the heuristics factor by calculating a weighted average of the ratio of the current close price to the 30-day minimum close price and the negative of the ratio of the current close price to the 30-day maximum close price, using a 60-40 weight split for a balanced emphasis on both the 30-day minimum and maximum.",
          "code": "def heuristics_v2(df):\n    min_close_30 = df['close'].rolling(window=30).min()\n    max_close_30 = df['close'].rolling(window=30).max()\n    ratio_min = df['close'] / min_close_30\n    ratio_max = -df['close'] / max_close_30\n    heuristics_matrix = 0.6 * ratio_min + 0.4 * ratio_max\n    return heuristics_matrix",
          "objective": -0.02644,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the heuristics factor by considering the exponential moving average (EMA) of the close prices over a 30-day period, then combining it with the ratio of current close price to this EMA and the negative of the ratio of current close price to the 30-day maximum close price.",
          "code": "def heuristics_v2(df):\n    ema_close_30 = df['close'].ewm(span=30).mean()\n    max_close_30 = df['close'].rolling(window=30).max()\n    ratio_ema = df['close'] / ema_close_30\n    ratio_max = -df['close'] / max_close_30\n    heuristics_matrix = (ratio_ema + ratio_max).dropna()\n    return heuristics_matrix",
          "objective": -0.02584,
          "other_inf": null
     }
]