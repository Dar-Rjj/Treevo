import pandas as pd

def heuristics_v2(df):
    def compute_roc(price_series, n=14):
        return price_series.pct_change(periods=n) * 100

    def compute_adx(high, low, close, n=14):
        plus_dm = high.diff()
        minus_dm = low.diff()
        plus_dm[plus_dm < 0] = 0
        minus_dm[minus_dm > 0] = 0
        
        tr = pd.DataFrame({'high-low': high - low, 'high-close': high - close.shift(1), 'low-close': low - close.shift(1)})
        tr['tr'] = tr.max(axis=1)
        
        atr = tr['tr'].rolling(window=n).mean()
        
        plus_di = 100 * (plus_dm.rolling(window=n).sum() / atr)
        minus_di = abs(100 * (minus_dm.rolling(window=n).sum() / atr))
        
        dx = 100 * (abs(plus_di - minus_di) / (plus_di + minus_di))
        adx = dx.rolling(window=n).mean()
        return adx

    def compute_rs(close, benchmark_close, n=14):
        return (close / close.shift(n)) / (benchmark_close / benchmark_close.shift(n))

    close_prices = df['close']
    high_prices = df['high']
    low_prices = df['low']
    benchmark_close_prices = df['benchmark_close']  # Assuming 'benchmark_close' is a column in df representing the benchmark close prices
    
    roc_values = compute_roc(close_prices)
    adx_values = compute_adx(high_prices, low_prices, close_prices)
    rs_values = compute_rs(close_prices, benchmark_close_prices)
    
    heuristics_matrix = (roc_values + adx_values + rs_values) / 3
    return heuristics_matrix
