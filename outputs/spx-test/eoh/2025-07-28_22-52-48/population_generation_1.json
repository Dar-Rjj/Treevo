[
     {
          "algorithm": "The new algorithm calculates a composite heuristics score for each date by incorporating the MACD, RSI, and the stochastic oscillator to provide a more comprehensive view of trend, momentum, and overbought/oversold conditions.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def compute_macd(price_series, n_fast=12, n_slow=26):\n        ema_fast = price_series.ewm(span=n_fast, min_periods=n_fast).mean()\n        ema_slow = price_series.ewm(span=n_slow, min_periods=n_slow).mean()\n        macd = ema_fast - ema_slow\n        return macd\n\n    def compute_rsi(price_series, periods=14):\n        delta = price_series.diff(1)\n        gain = (delta.where(delta > 0, 0)).fillna(0)\n        loss = (-delta.where(delta < 0, 0)).fillna(0)\n        avg_gain = gain.rolling(window=periods, min_periods=periods).mean()\n        avg_loss = loss.rolling(window=periods, min_periods=periods).mean()\n        rs = avg_gain / avg_loss\n        rsi = 100 - (100 / (1 + rs))\n        return rsi\n\n    def compute_stochastic_oscillator(high, low, close, k_period=14, d_period=3):\n        l14 = low.rolling(window=k_period, min_periods=k_period).min()\n        h14 = high.rolling(window=k_period, min_periods=k_period).max()\n        k_percent = 100 * ((close - l14) / (h14 - l14))\n        d_percent = k_percent.rolling(window=d_period, min_periods=d_period).mean()\n        return d_percent\n\n    close_prices = df['close']\n    high_prices = df['high']\n    low_prices = df['low']\n    \n    macd_values = compute_macd(close_prices)\n    rsi_values = compute_rsi(close_prices)\n    stoch_osc_values = compute_stochastic_oscillator(high_prices, low_prices, close_prices)\n    \n    # Heuristic matrix: combination of MACD, RSI, and Stochastic Oscillator\n    heuristics_matrix = (macd_values + rsi_values + stoch_osc_values) / 3\n    return heuristics_matrix",
          "objective": -0.01624,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates an alpha factor by considering the exponential moving average (EMA) of the closing prices over a 20-day period, then subtracting a 50-day EMA of the same, to capture medium-term trends and potential reversals.",
          "code": "def heuristics_v2(df):\n    ema_20 = df['close'].ewm(span=20, adjust=False).mean()\n    ema_50 = df['close'].ewm(span=50, adjust=False).mean()\n    heuristics_matrix = (ema_20 - ema_50).dropna()\n    return heuristics_matrix",
          "objective": -0.01603,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor based on the weighted sum of differences between shorter and longer moving averages of high prices, and subtracts a weighted difference of low price moving averages, with an emphasis on different window sizes.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    short_window_high = 7\n    long_window_high = 28\n    short_window_low = 9\n    long_window_low = 30\n    df['short_high_ma'] = df['high'].rolling(window=short_window_high).mean()\n    df['long_high_ma'] = df['high'].rolling(window=long_window_high).mean()\n    df['short_low_ma'] = df['low'].rolling(window=short_window_low).mean()\n    df['long_low_ma'] = df['low'].rolling(window=long_window_low).mean()\n    heuristics_matrix = (df['short_high_ma'] - df['long_high_ma']) * 1.5 - (df['short_low_ma'] - df['long_low_ma'])\n    return heuristics_matrix",
          "objective": -0.01579,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates an alpha factor by using the difference between a 12-day EMA and a 26-day EMA of the closing prices, to identify short-term trend reversals.",
          "code": "def heuristics_v2(df):\n    ema_12 = df['close'].ewm(span=12, adjust=False).mean()\n    ema_26 = df['close'].ewm(span=26, adjust=False).mean()\n    heuristics_matrix = (ema_12 - ema_26).dropna()\n    return heuristics_matrix",
          "objective": -0.01507,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a composite heuristics score for each date by combining the moving average convergence divergence (MACD) and the relative strength index (RSI) of the 'close' price, with the MACD emphasizing trend momentum and RSI serving as an indicator of overbought or oversold conditions.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def compute_macd(price_series, n_fast=12, n_slow=26):\n        ema_fast = price_series.ewm(span=n_fast, min_periods=n_fast).mean()\n        ema_slow = price_series.ewm(span=n_slow, min_periods=n_slow).mean()\n        macd = ema_fast - ema_slow\n        return macd\n\n    def compute_rsi(price_series, periods=14):\n        delta = price_series.diff(1)\n        gain = (delta.where(delta > 0, 0)).fillna(0)\n        loss = (-delta.where(delta < 0, 0)).fillna(0)\n        avg_gain = gain.rolling(window=periods, min_periods=periods).mean()\n        avg_loss = loss.rolling(window=periods, min_periods=periods).mean()\n        rs = avg_gain / avg_loss\n        rsi = 100 - (100 / (1 + rs))\n        return rsi\n    \n    close_prices = df['close']\n    macd_values = compute_macd(close_prices)\n    rsi_values = compute_rsi(close_prices)\n    \n    # Heuristic matrix: combination of MACD and RSI\n    heuristics_matrix = (macd_values + rsi_values)/2\n    return heuristics_matrix",
          "objective": -0.01486,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates an alpha factor by considering the difference between a 20-day and 50-day exponential moving average (EMA) of the closing prices, then scales this difference by the ratio of the current day's volume to the 20-day EMA of the volume, to add a dimension of trading activity.",
          "code": "def heuristics_v2(df):\n    ema_20_price = df['close'].ewm(span=20, adjust=False).mean()\n    ema_50_price = df['close'].ewm(span=50, adjust=False).mean()\n    ema_20_volume = df['volume'].ewm(span=20, adjust=False).mean()\n    heuristics_matrix = ((ema_20_price - ema_50_price) * (df['volume'] / ema_20_volume)).dropna()\n    return heuristics_matrix",
          "objective": -0.01289,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm constructs a novel heuristic factor by calculating the weighted sum of moving averages and their differences, integrating both short-term and long-term market movements to predict future returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate short-term (5-day) and long-term (20-day) moving averages\n    ma_5 = df['close'].rolling(window=5).mean()\n    ma_20 = df['close'].rolling(window=20).mean()\n    \n    # Compute the difference between short-term and long-term moving averages\n    diff_ma = ma_5 - ma_20\n    \n    # Define weights for the combination of moving averages and their differences\n    weight_ma_5 = 0.4\n    weight_ma_20 = 0.3\n    weight_diff = 0.3\n    \n    # Create the heuristic factor\n    heuristics_matrix = (weight_ma_5 * ma_5) + (weight_ma_20 * ma_20) + (weight_diff * diff_ma)\n    \n    return heuristics_matrix",
          "objective": -0.01225,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a novel heuristic factor by incorporating the weighted sum of 10-day and 30-day moving averages, the difference between them, and the rate of change of the 10-day moving average.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    ma_10 = df['close'].rolling(window=10).mean()\n    ma_30 = df['close'].rolling(window=30).mean()\n    diff_ma = ma_10 - ma_30\n    roc_ma_10 = ma_10.pct_change()\n    \n    weight_ma_10 = 0.5\n    weight_ma_30 = 0.2\n    weight_diff = 0.2\n    weight_roc = 0.1\n    \n    heuristics_matrix = (weight_ma_10 * ma_10) + (weight_ma_30 * ma_30) + (weight_diff * diff_ma) + (weight_roc * roc_ma_10)\n    \n    return heuristics_matrix",
          "objective": -0.01222,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm adjusts the weights and introduces a medium-term (10-day) moving average to better capture market dynamics, combining all three moving averages and their respective differences.",
          "code": "def heuristics_v2(df):\n    # Calculate short-term (5-day), medium-term (10-day), and long-term (20-day) moving averages\n    ma_5 = df['close'].rolling(window=5).mean()\n    ma_10 = df['close'].rolling(window=10).mean()\n    ma_20 = df['close'].rolling(window=20).mean()\n    \n    # Compute the differences between each pair of moving averages\n    diff_ma_5_10 = ma_5 - ma_10\n    diff_ma_10_20 = ma_10 - ma_20\n    \n    # Define new weights for the combination\n    weight_ma_5 = 0.3\n    weight_ma_10 = 0.2\n    weight_ma_20 = 0.2\n    weight_diff_5_10 = 0.15\n    weight_diff_10_20 = 0.15\n    \n    # Create the heuristic factor\n    heuristics_matrix = (weight_ma_5 * ma_5) + (weight_ma_10 * ma_10) + (weight_ma_20 * ma_20) + \\\n                        (weight_diff_5_10 * diff_ma_5_10) + (weight_diff_10_20 * diff_ma_10_20)\n    \n    return heuristics_matrix",
          "objective": -0.0122,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by adjusting the weights of short-term and long-term moving averages, their difference, and the rate of change of the short-term moving average, to create a more nuanced predictor of future stock returns.",
          "code": "def heuristics_v2(df):\n    ma_5 = df['close'].rolling(window=5).mean()\n    ma_20 = df['close'].rolling(window=20).mean()\n    diff_ma = ma_5 - ma_20\n    roc_ma_5 = ma_5.pct_change()\n    \n    weight_ma_5 = 0.6\n    weight_ma_20 = 0.2\n    weight_diff = 0.1\n    weight_roc = 0.1\n    \n    heuristics_matrix = (weight_ma_5 * ma_5) + (weight_ma_20 * ma_20) + (weight_diff * diff_ma) + (weight_roc * roc_ma_5)\n    \n    return heuristics_matrix",
          "objective": -0.01219,
          "other_inf": null
     }
]