[
     {
          "algorithm": "The algorithm calculates a composite heuristics score for each date by combining the moving average convergence divergence (MACD) and the relative strength index (RSI) of the 'close' price, with the MACD emphasizing trend momentum and RSI serving as an indicator of overbought or oversold conditions.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def compute_macd(price_series, n_fast=12, n_slow=26):\n        ema_fast = price_series.ewm(span=n_fast, min_periods=n_fast).mean()\n        ema_slow = price_series.ewm(span=n_slow, min_periods=n_slow).mean()\n        macd = ema_fast - ema_slow\n        return macd\n\n    def compute_rsi(price_series, periods=14):\n        delta = price_series.diff(1)\n        gain = (delta.where(delta > 0, 0)).fillna(0)\n        loss = (-delta.where(delta < 0, 0)).fillna(0)\n        avg_gain = gain.rolling(window=periods, min_periods=periods).mean()\n        avg_loss = loss.rolling(window=periods, min_periods=periods).mean()\n        rs = avg_gain / avg_loss\n        rsi = 100 - (100 / (1 + rs))\n        return rsi\n    \n    close_prices = df['close']\n    macd_values = compute_macd(close_prices)\n    rsi_values = compute_rsi(close_prices)\n    \n    # Heuristic matrix: combination of MACD and RSI\n    heuristics_matrix = (macd_values + rsi_values)/2\n    return heuristics_matrix",
          "objective": -0.01486,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm constructs a novel heuristic factor by calculating the weighted sum of moving averages and their differences, integrating both short-term and long-term market movements to predict future returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate short-term (5-day) and long-term (20-day) moving averages\n    ma_5 = df['close'].rolling(window=5).mean()\n    ma_20 = df['close'].rolling(window=20).mean()\n    \n    # Compute the difference between short-term and long-term moving averages\n    diff_ma = ma_5 - ma_20\n    \n    # Define weights for the combination of moving averages and their differences\n    weight_ma_5 = 0.4\n    weight_ma_20 = 0.3\n    weight_diff = 0.3\n    \n    # Create the heuristic factor\n    heuristics_matrix = (weight_ma_5 * ma_5) + (weight_ma_20 * ma_20) + (weight_diff * diff_ma)\n    \n    return heuristics_matrix",
          "objective": -0.01225,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a novel alpha factor by combining the difference between the highest and lowest price of the day, adjusted by the ratio of the closing price to the opening price, with the volume as a weight, aiming to capture momentum and volatility.",
          "code": "def heuristics_v2(df):\n    heuristics_matrix = (df['high'] - df['low']) * (df['close'] / df['open']) * df['volume']\n    return heuristics_matrix",
          "objective": -0.01112,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a heuristic factor based on the weighted difference between the moving averages of high and low prices, aiming to capture momentum and volatility insights.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    short_window = 5\n    long_window = 20\n    df['short_high_ma'] = df['high'].rolling(window=short_window).mean()\n    df['long_high_ma'] = df['high'].rolling(window=long_window).mean()\n    df['short_low_ma'] = df['low'].rolling(window=short_window).mean()\n    df['long_low_ma'] = df['low'].rolling(window=long_window).mean()\n    heuristics_matrix = (df['short_high_ma'] - df['long_high_ma']) - (df['short_low_ma'] - df['long_low_ma'])\n    return heuristics_matrix",
          "objective": -0.00986,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a novel alpha factor by calculating the moving average crossover of close prices and incorporating volume trend, then adjusting for volatility, to generate a heuristic matrix that could potentially predict future stock returns.",
          "code": "def heuristics_v2(df):\n    short_window = 40\n    long_window = 100\n    df['short_mavg'] = df['close'].rolling(window=short_window, min_periods=short_window).mean()\n    df['long_mavg'] = df['close'].rolling(window=long_window, min_periods=long_window).mean()\n    df['volume_trend'] = df['volume'].pct_change()\n    df['volatility'] = df['close'].rolling(window=short_window, min_periods=short_window).std()\n    heuristics_matrix = (df['short_mavg'] - df['long_mavg']) / df['volatility'] * df['volume_trend']\n    return heuristics_matrix",
          "objective": -0.00421,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies patterns in price and volume data to generate a set of heuristics, which are combined into a factor aiming to predict future stock returns, through a series of steps including calculating moving averages, their differences, and a final aggregation.",
          "code": "def heuristics_v2(df):\n    # Calculate short-term and long-term moving averages for close prices\n    ma_short = df['close'].rolling(window=5).mean()\n    ma_long = df['close'].rolling(window=20).mean()\n    \n    # Calculate the difference between the short-term and long-term MAs\n    ma_diff = ma_short - ma_long\n    \n    # Calculate the percentage change in volume over a 5-day period\n    vol_change = df['volume'].pct_change(periods=5)\n    \n    # Generate a heuristic by combining MA difference and volume change\n    heuristics_matrix = (ma_diff * vol_change).fillna(0)\n    \n    return heuristics_matrix",
          "objective": -0.00345,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies patterns in the relative movement of closing prices over time compared to a moving average, generating an alpha factor that captures momentum shifts.",
          "code": "def heuristics_v2(df):\n    def calculate_moving_average(series, window=30):\n        return series.rolling(window=window).mean()\n    \n    df['close_ma'] = calculate_moving_average(df['close'])\n    df['heuristic_factor'] = (df['close'] - df['close_ma']).pct_change()\n    heuristics_matrix = df['heuristic_factor'].dropna()\n    return heuristics_matrix",
          "objective": -0.0024,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm constructs an interpretable alpha factor by calculating the ratio of today's closing price to the average of the highest and lowest prices over the past 10 days, aiming to capture momentum and mean reversion signals.",
          "code": "def heuristics_v2(df):\n    heuristics_matrix = (df['close'] / ((df['high'].rolling(window=10).mean() + df['low'].rolling(window=10).mean()) / 2)).dropna()\n    return heuristics_matrix",
          "objective": -0.00223,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm, named MomentumDivergence, calculates the difference between the 50-day and 200-day moving averages of the closing price, then multiplies it by the negative change in volume over the last 10 days to generate a novel alpha factor.",
          "code": "def heuristics_v2(df):\n    ma_50 = df['close'].rolling(window=50).mean()\n    ma_200 = df['close'].rolling(window=200).mean()\n    vol_change = (df['volume'] - df['volume'].shift(10)) / df['volume'].shift(10)\n    heuristics_matrix = (ma_50 - ma_200) * (-vol_change)\n    return heuristics_matrix",
          "objective": -0.00219,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies potential alpha factors by calculating the ratio of the exponential moving average (EMA) of the closing price over a short period to that over a long period, and combining this with the percentage change in volume, aiming to capture momentum and interest in the stock.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    short_window = 12\n    long_window = 26\n    ema_short = df['close'].ewm(span=short_window, adjust=False).mean()\n    ema_long = df['close'].ewm(span=long_window, adjust=False).mean()\n    volume_change = df['volume'].pct_change()\n    factor_values = (ema_short / ema_long) * volume_change\n    heuristics_matrix = pd.Series(factor_values, index=df.index)\n    return heuristics_matrix",
          "objective": -0.0019,
          "other_inf": null
     }
]