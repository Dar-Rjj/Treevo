[
     {
          "algorithm": "The new algorithm calculates the heuristics factor by averaging the ratio of the current close price to the 20-day minimum close price with the negative of the ratio of the current close price to the 20-day maximum close price, focusing on a shorter time frame.",
          "code": "def heuristics_v2(df):\n    min_close_20 = df['close'].rolling(window=20).min()\n    max_close_20 = df['close'].rolling(window=20).max()\n    ratio_min = df['close'] / min_close_20\n    ratio_max = -df['close'] / max_close_20\n    heuristics_matrix = (ratio_min + ratio_max) / 2\n    return heuristics_matrix",
          "objective": -0.03161,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the heuristics factor by combining the ratio of the current close price to the 30-day minimum close price with the negative of the ratio of the current close price to the 30-day maximum close price, capturing both the relative strength and weakness compared to recent historical prices.",
          "code": "def heuristics_v2(df):\n    min_close_30 = df['close'].rolling(window=30).min()\n    max_close_30 = df['close'].rolling(window=30).max()\n    ratio_min = df['close'] / min_close_30\n    ratio_max = -df['close'] / max_close_30\n    heuristics_matrix = (ratio_min + ratio_max).dropna()\n    return heuristics_matrix",
          "objective": -0.031,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the heuristics factor by combining the square of the ratio of the current close price to the 30-day minimum close price with the negative square of the ratio of the current close price to the 30-day maximum close price, aiming to emphasize periods of relative extreme strength or weakness.",
          "code": "def heuristics_v2(df):\n    min_close_30 = df['close'].rolling(window=30).min()\n    max_close_30 = df['close'].rolling(window=30).max()\n    ratio_min = (df['close'] / min_close_30) ** 2\n    ratio_max = - (df['close'] / max_close_30) ** 2\n    heuristics_matrix = (ratio_min + ratio_max).dropna()\n    return heuristics_matrix",
          "objective": -0.02987,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the heuristics factor by combining the cube of the ratio of the current close price to the 20-day minimum close price with the negative cube of the ratio of the current close price to the 20-day maximum close price, adjusting for shorter-term volatility.",
          "code": "def heuristics_v2(df):\n    min_close_20 = df['close'].rolling(window=20).min()\n    max_close_20 = df['close'].rolling(window=20).max()\n    ratio_min = (df['close'] / min_close_20) ** 3\n    ratio_max = - (df['close'] / max_close_20) ** 3\n    heuristics_matrix = (ratio_min + ratio_max).dropna()\n    return heuristics_matrix",
          "objective": -0.02845,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the heuristics factor using the cube of the ratio of the current close price to the 30-day minimum close price, and the negative cube of the ratio of the current close price to the 30-day maximum close price, further accentuating periods of extreme strength or weakness.",
          "code": "def heuristics_v2(df):\n    min_close_30 = df['close'].rolling(window=30).min()\n    max_close_30 = df['close'].rolling(window=30).max()\n    ratio_min = (df['close'] / min_close_30) ** 3\n    ratio_max = - (df['close'] / max_close_30) ** 3\n    heuristics_matrix = (ratio_min + ratio_max).dropna()\n    return heuristics_matrix",
          "objective": -0.02794,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the heuristics factor by considering the exponential moving average (EMA) of the close prices over a 30-day period, then combining it with the ratio of current close price to this EMA and the negative of the ratio of current close price to the 30-day maximum close price.",
          "code": "def heuristics_v2(df):\n    ema_close_30 = df['close'].ewm(span=30).mean()\n    max_close_30 = df['close'].rolling(window=30).max()\n    ratio_ema = df['close'] / ema_close_30\n    ratio_max = -df['close'] / max_close_30\n    heuristics_matrix = (ratio_ema + ratio_max).dropna()\n    return heuristics_matrix",
          "objective": -0.02584,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates an alpha factor by combining the rate of change (ROC) over a 14-day period and the Chaikin Money Flow (CMF) over a 20-day period, aiming to capture both momentum and money flow dynamics.",
          "code": "def heuristics_v2(df):\n    def compute_roc(price_series, n=14):\n        return price_series.pct_change(n)\n\n    def compute_cmf(high_series, low_series, close_series, volume_series, n=20):\n        mfv = ((close_series - low_series) - (high_series - close_series)) / (high_series - low_series)\n        mfv = mfv.fillna(0.0) * volume_series\n        cmf = mfv.rolling(window=n).sum() / volume_series.rolling(window=n).sum()\n        return cmf\n\n    close_prices = df['close']\n    high_prices = df['high']\n    low_prices = df['low']\n    volume = df['volume']\n\n    roc_values = compute_roc(close_prices)\n    cmf_values = compute_cmf(high_prices, low_prices, close_prices, volume)\n\n    # Heuristic matrix: combination of ROC and CMF\n    heuristics_matrix = (roc_values + cmf_values) / 2\n    return heuristics_matrix",
          "objective": -0.01993,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes an alpha factor by weighting the 14-day ROC and 20-day CMF, and then applying a momentum adjustment based on the 10-day simple moving average of closing prices.",
          "code": "def heuristics_v2(df):\n    def compute_roc(price_series, n=14):\n        return price_series.pct_change(n)\n\n    def compute_cmf(high_series, low_series, close_series, volume_series, n=20):\n        mfv = ((close_series - low_series) - (high_series - close_series)) / (high_series - low_series)\n        mfv = mfv.fillna(0.0) * volume_series\n        cmf = mfv.rolling(window=n).sum() / volume_series.rolling(window=n).sum()\n        return cmf\n\n    def compute_sma(price_series, n=10):\n        return price_series.rolling(window=n).mean()\n\n    close_prices = df['close']\n    high_prices = df['high']\n    low_prices = df['low']\n    volume = df['volume']\n\n    roc_values = compute_roc(close_prices)\n    cmf_values = compute_cmf(high_prices, low_prices, close_prices, volume)\n    sma_values = compute_sma(close_prices)\n\n    # Heuristic matrix: weighted combination of ROC and CMF with momentum adjustment\n    heuristics_matrix = (roc_values * 0.6 + cmf_values * 0.4) * (close_prices / sma_values)\n    return heuristics_matrix",
          "objective": -0.01882,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates an alpha factor by using the ratio of the 12-day simple moving average (SMA) to the 26-day SMA of the closing prices, aiming to identify potential momentum shifts.",
          "code": "def heuristics_v2(df):\n    sma_12 = df['close'].rolling(window=12).mean()\n    sma_26 = df['close'].rolling(window=26).mean()\n    heuristics_matrix = (sma_12 / sma_26).dropna()\n    return heuristics_matrix",
          "objective": -0.01686,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates an alpha factor by combining the rate of change (ROC) over a 21-day period and the Chaikin Money Flow (CMF) over a 25-day period, aiming to capture a slightly longer-term momentum and money flow dynamics.",
          "code": "def heuristics_v2(df):\n    def compute_roc(price_series, n=21):\n        return price_series.pct_change(n)\n\n    def compute_cmf(high_series, low_series, close_series, volume_series, n=25):\n        mfv = ((close_series - low_series) - (high_series - close_series)) / (high_series - low_series)\n        mfv = mfv.fillna(0.0) * volume_series\n        cmf = mfv.rolling(window=n).sum() / volume_series.rolling(window=n).sum()\n        return cmf\n\n    close_prices = df['close']\n    high_prices = df['high']\n    low_prices = df['low']\n    volume = df['volume']\n\n    roc_values = compute_roc(close_prices)\n    cmf_values = compute_cmf(high_prices, low_prices, close_prices, volume)\n\n    # Heuristic matrix: combination of ROC and CMF\n    heuristics_matrix = (roc_values + cmf_values) / 2\n    return heuristics_matrix",
          "objective": -0.01651,
          "other_inf": null
     }
]