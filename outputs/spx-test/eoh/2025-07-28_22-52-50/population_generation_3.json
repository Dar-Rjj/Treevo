[
     {
          "algorithm": "The new algorithm calculates a modified heuristic factor by considering the ratio of the coefficient of variation (standard deviation divided by mean) of the closing prices over the last 20 days to the average of the daily price range (high minus low) over the same period, aiming to capture longer-term volatility relative to the average price along with typical daily price movement.",
          "code": "def heuristics_v2(df):\n    std_close_20_day = df['close'].rolling(window=20).std()\n    mean_close_20_day = df['close'].rolling(window=20).mean()\n    avg_range_20_day = (df['high'] - df['low']).rolling(window=20).mean()\n    heuristics_matrix = (std_close_20_day / mean_close_20_day) / avg_range_20_day\n    return heuristics_matrix",
          "objective": -0.03472,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by combining the ratio of the standard deviation of the closing prices over the last 30 days to the simple moving average of the closing prices over the same period, with an adjustment factor based on the relative difference between the highest high and lowest low over the past 30 days.",
          "code": "def heuristics_v2(df):\n    std_close_30_day = df['close'].rolling(window=30).std()\n    sma_close_30_day = df['close'].rolling(window=30).mean()\n    high_low_diff_30_day = (df['high'].rolling(window=30).max() - df['low'].rolling(window=30).min()) / sma_close_30_day\n    heuristics_matrix = (std_close_30_day / sma_close_30_day) * (1 + high_low_diff_30_day)\n    return heuristics_matrix",
          "objective": -0.03235,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by combining the ratio of the standard deviation of the closing prices over the last 30 days to the exponential moving average of the closing prices over the same period, with an adjustment factor based on the relative difference between the highest high and lowest low over the past 30 days.",
          "code": "def heuristics_v2(df):\n    std_close_30_day = df['close'].rolling(window=30).std()\n    ema_close_30_day = df['close'].ewm(span=30, adjust=False).mean()\n    high_low_diff_30_day = (df['high'].rolling(window=30).max() - df['low'].rolling(window=30).min()) / ema_close_30_day\n    heuristics_matrix = (std_close_30_day / ema_close_30_day) * (1 + high_low_diff_30_day)\n    return heuristics_matrix",
          "objective": -0.0323,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by considering the ratio of the standard deviation of the closing prices over the last 30 days to the average of the highest high and lowest low prices over the same period, aiming to capture longer-term volatility and price range dynamics.",
          "code": "def heuristics_v2(df):\n    std_close_30_day = df['close'].rolling(window=30).std()\n    avg_high_low_30_day = (df['high'].rolling(window=30).mean() + df['low'].rolling(window=30).mean()) / 2\n    heuristics_matrix = std_close_30_day / avg_high_low_30_day\n    return heuristics_matrix",
          "objective": -0.03222,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by combining the ratio of the standard deviation of the closing prices over the last 20 days to the simple moving average of the closing prices over the same period, with an adjustment factor based on the relative difference between the highest high and lowest low over the past 20 days.",
          "code": "def heuristics_v2(df):\n    std_close_20_day = df['close'].rolling(window=20).std()\n    sma_close_20_day = df['close'].rolling(window=20).mean()\n    high_low_diff_20_day = (df['high'].rolling(window=20).max() - df['low'].rolling(window=20).min()) / sma_close_20_day\n    heuristics_matrix = (std_close_20_day / sma_close_20_day) * (1 + high_low_diff_20_day)\n    return heuristics_matrix",
          "objective": -0.03069,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by considering the ratio of the standard deviation of the closing prices over the last 20 days to the average of the highest high and lowest low prices over the same period, aiming to capture volatility and price range dynamics.",
          "code": "def heuristics_v2(df):\n    std_close_20_day = df['close'].rolling(window=20).std()\n    avg_high_low_20_day = (df['high'].rolling(window=20).mean() + df['low'].rolling(window=20).mean()) / 2\n    heuristics_matrix = std_close_20_day / avg_high_low_20_day\n    return heuristics_matrix",
          "objective": -0.0305,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the heuristic factor by using the ratio of the exponential moving average (EMA) over the last 30 days to the simple moving average (SMA) of the closing prices over the same period, adjusted by twice the coefficient of variation of the closing prices in the last 30 days.",
          "code": "def heuristics_v2(df):\n    ema_close_30_day = df['close'].ewm(span=30, adjust=False).mean()\n    sma_close_30_day = df['close'].rolling(window=30).mean()\n    cv_close_30_day = df['close'].rolling(window=30).std() / df['close'].rolling(window=30).mean()\n    heuristics_matrix = (ema_close_30_day / sma_close_30_day) * (1 + 2 * cv_close_30_day)\n    return heuristics_matrix",
          "objective": -0.02926,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a factor based on the ratio of the average true range (ATR) over the last 30 days to the simple moving average (SMA) of the closing prices, adjusted by the relative strength index (RSI) of the closing prices over the same period.",
          "code": "def heuristics_v2(df):\n    atr_30_day = df['high'].rolling(window=30).max() - df['low'].rolling(window=30).min()\n    sma_close_30_day = df['close'].rolling(window=30).mean()\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=30).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=30).mean()\n    rs = gain / loss\n    rsi_30_day = 100 - (100 / (1 + rs))\n    heuristics_matrix = (atr_30_day / sma_close_30_day) * (rsi_30_day / 50)\n    return heuristics_matrix",
          "objective": -0.02803,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a modified heuristic factor by considering the ratio of the coefficient of variation (standard deviation divided by mean) of the closing prices over the last 10 days to the difference between the maximum high and minimum low prices over the same period, aiming to capture volatility relative to average price along with price range dynamics.",
          "code": "def heuristics_v2(df):\n    std_close_10_day = df['close'].rolling(window=10).std()\n    mean_close_10_day = df['close'].rolling(window=10).mean()\n    max_high_10_day = df['high'].rolling(window=10).max()\n    min_low_10_day = df['low'].rolling(window=10).min()\n    heuristics_matrix = (std_close_10_day / mean_close_10_day) / (max_high_10_day - min_low_10_day)\n    return heuristics_matrix",
          "objective": -0.02727,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor using the ratio of the exponential moving average (EMA) over the last 20 days to the simple moving average (SMA) of the closing prices over the same period, adjusted by twice the coefficient of variation of the closing prices in the last 20 days.",
          "code": "def heuristics_v2(df):\n    ema_close_20_day = df['close'].ewm(span=20, adjust=False).mean()\n    sma_close_20_day = df['close'].rolling(window=20).mean()\n    cv_close_20_day = 2 * (df['close'].rolling(window=20).std() / df['close'].rolling(window=20).mean())\n    heuristics_matrix = (ema_close_20_day / sma_close_20_day) * (1 + cv_close_20_day)\n    return heuristics_matrix",
          "objective": -0.02655,
          "other_inf": null
     }
]