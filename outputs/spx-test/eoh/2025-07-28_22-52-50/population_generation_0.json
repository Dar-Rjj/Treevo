[
     {
          "algorithm": "The algorithm calculates a heuristic factor based on the weighted combination of moving averages and volume changes, aiming to predict future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    short_window = 10\n    long_window = 30\n    df['short_mavg'] = df['close'].rolling(window=short_window, min_periods=short_window).mean()\n    df['long_mavg'] = df['close'].rolling(window=long_window, min_periods=long_window).mean()\n    df['volume_change'] = df['volume'].pct_change()\n    df['heuristic_factor'] = (df['short_mavg'] - df['long_mavg']) + df['volume_change']\n    heuristics_matrix = df['heuristic_factor'].dropna()\n    return heuristics_matrix",
          "objective": -0.01647,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a composite factor by combining moving averages of different lengths with the relative strength index (RSI) and price rate of change (ROC), aiming to generate interpretable alpha signals.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate short and long moving averages\n    short_ma = df['close'].rolling(window=10).mean()\n    long_ma = df['close'].rolling(window=50).mean()\n    \n    # Compute RSI (Relative Strength Index)\n    delta = df['close'].diff(1)\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate ROC (Rate of Change)\n    roc = df['close'].pct_change(periods=12)\n    \n    # Composite factor\n    heuristics_matrix = (short_ma - long_ma) + rsi + roc\n    \n    return heuristics_matrix",
          "objective": -0.01636,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm extracts and combines key financial indicators from the input DataFrame to create a novel alpha factor, leveraging moving averages, momentum, and volatility metrics.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate simple moving averages\n    short_window = 10\n    long_window = 50\n    df['SMA_Short'] = df['close'].rolling(window=short_window).mean()\n    df['SMA_Long'] = df['close'].rolling(window=long_window).mean()\n\n    # Momentum calculation (price change over a period)\n    momentum_period = 14\n    df['Momentum'] = df['close'].pct_change(momentum_period)\n\n    # Volatility (standard deviation of daily returns)\n    vol_period = 20\n    df['Volatility'] = df['close'].pct_change().rolling(window=vol_period).std()\n\n    # Combined heuristic: Difference between short and long SMAs, adjusted by momentum and volatility\n    heuristics_matrix = (df['SMA_Short'] - df['SMA_Long']) + df['Momentum'] - df['Volatility']\n\n    return heuristics_matrix",
          "objective": -0.01635,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm, named Heuristics V2, calculates a novel alpha factor by combining weighted moving averages of open and close prices with a momentum indicator derived from the volume, to predict future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    open_prices = df['open']\n    close_prices = df['close']\n    volume = df['volume']\n    \n    # Calculate the short-term (5 days) and long-term (20 days) moving averages for open and close prices\n    short_open_ma = open_prices.rolling(window=5).mean()\n    long_open_ma = open_prices.rolling(window=20).mean()\n    short_close_ma = close_prices.rolling(window=5).mean()\n    long_close_ma = close_prices.rolling(window=20).mean()\n    \n    # Momentum indicator: 14-day rate of change (ROC) of volume\n    volume_momentum = (volume / volume.shift(14)) - 1\n    \n    # Combined heuristic factor\n    heuristics_matrix = 0.5 * ((short_open_ma - long_open_ma) + (short_close_ma - long_close_ma)) + 0.5 * volume_momentum\n    \n    return heuristics_matrix",
          "objective": -0.01416,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies potential alpha factors by calculating the rolling mean reversion and momentum of stock prices, combining these with volume trends to generate a composite heuristics matrix.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    close = df['close']\n    volume = df['volume']\n    \n    # Momentum: 10-day return\n    momentum = close.pct_change(10)\n    \n    # Mean Reversion: Difference between price and its 30-day moving average\n    mean_reversion = close - close.rolling(window=30).mean()\n    \n    # Volume Trend: 10-day change in volume\n    volume_trend = volume.pct_change(10)\n    \n    # Composite Heuristics Matrix\n    heuristics_matrix = (momentum + mean_reversion + volume_trend) / 3\n    \n    return heuristics_matrix",
          "objective": -0.01103,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm, called Heuristics_V2, calculates a novel factor by computing the exponential moving average of the ratio between the daily volume and the difference of the high and low prices, aiming to capture unusual trading activity relative to price volatility.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the difference between high and low for each day\n    range_diff = df['high'] - df['low']\n    \n    # Compute the ratio of volume to the daily price range\n    vol_to_range_ratio = df['volume'] / range_diff\n    \n    # Calculate the Exponential Moving Average (EMA) of the computed ratio\n    ema_factor = vol_to_range_ratio.ewm(span=10, adjust=False).mean()\n    \n    # Return the EMA factor as a Series\n    heuristics_matrix = pd.Series(ema_factor, name='Heuristics_Factor')\n    return heuristics_matrix",
          "objective": -0.00921,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a momentum-based alpha factor by computing the ratio of the average closing price over the last 10 days to the average volume over the last 10 days, aiming to interpret stock return predictability through the lens of price and volume dynamics.",
          "code": "def heuristics_v2(df):\n    close_10_day_avg = df['close'].rolling(window=10).mean()\n    volume_10_day_avg = df['volume'].rolling(window=10).mean()\n    heuristics_matrix = close_10_day_avg / volume_10_day_avg\n    return heuristics_matrix",
          "objective": -0.0059,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a heuristics-based factor by combining the percentage change in closing price with the relative difference between the average of high and low prices, capturing momentum and volatility aspects.",
          "code": "def heuristics_v2(df):\n    close_change = df['close'].pct_change()\n    avg_high_low = (df['high'] + df['low']) / 2\n    rel_diff = (avg_high_low - df['close'].shift(1)) / df['close'].shift(1)\n    heuristics_matrix = close_change * rel_diff\n    return heuristics_matrix",
          "objective": -0.00434,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a heuristic factor based on the ratio of the difference between closing and opening prices to the average volume over a 5-day window, aiming to capture the momentum adjusted by liquidity.",
          "code": "def heuristics_v2(df):\n    df['price_diff'] = df['close'] - df['open']\n    df['avg_volume_5d'] = df['volume'].rolling(window=5).mean()\n    heuristics_matrix = df['price_diff'] / df['avg_volume_5d']\n    return heuristics_matrix",
          "objective": -0.00259,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates the exponential moving average (EMA) difference between the close and open prices, then combines it with a simple ratio of volume to its 30-day moving average to generate a novel alpha factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    ema_diff = df['close'] - df['open'].ewm(span=14).mean()\n    vol_ratio = df['volume'] / df['volume'].rolling(window=30).mean()\n    heuristics_matrix = (ema_diff * vol_ratio).dropna()\n    return heuristics_matrix",
          "objective": -0.00255,
          "other_inf": null
     }
]