[
     {
          "algorithm": "The new algorithm calculates a heuristic factor by combining the ratio of the standard deviation of the closing prices over the last 30 days to the simple moving average of the closing prices over the same period, with an adjustment factor based on the relative difference between the highest high and lowest low over the past 30 days.",
          "code": "def heuristics_v2(df):\n    std_close_30_day = df['close'].rolling(window=30).std()\n    sma_close_30_day = df['close'].rolling(window=30).mean()\n    high_low_diff_30_day = (df['high'].rolling(window=30).max() - df['low'].rolling(window=30).min()) / sma_close_30_day\n    heuristics_matrix = (std_close_30_day / sma_close_30_day) * (1 + high_low_diff_30_day)\n    return heuristics_matrix",
          "objective": -0.03235,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by combining the ratio of the standard deviation of the closing prices over the last 20 days to the simple moving average of the closing prices over the same period, with an adjustment factor based on the relative difference between the highest high and lowest low over the past 20 days.",
          "code": "def heuristics_v2(df):\n    std_close_20_day = df['close'].rolling(window=20).std()\n    sma_close_20_day = df['close'].rolling(window=20).mean()\n    high_low_diff_20_day = (df['high'].rolling(window=20).max() - df['low'].rolling(window=20).min()) / sma_close_20_day\n    heuristics_matrix = (std_close_20_day / sma_close_20_day) * (1 + high_low_diff_20_day)\n    return heuristics_matrix",
          "objective": -0.03069,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by considering the ratio of the standard deviation of the closing prices over the last 20 days to the average of the highest high and lowest low prices over the same period, aiming to capture volatility and price range dynamics.",
          "code": "def heuristics_v2(df):\n    std_close_20_day = df['close'].rolling(window=20).std()\n    avg_high_low_20_day = (df['high'].rolling(window=20).mean() + df['low'].rolling(window=20).mean()) / 2\n    heuristics_matrix = std_close_20_day / avg_high_low_20_day\n    return heuristics_matrix",
          "objective": -0.0305,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by incorporating the ratio of the exponential moving average (EMA) over the last 10 days to the simple moving average (SMA) of the closing prices over the same period, adjusted by the coefficient of variation of the closing prices in the last 10 days.",
          "code": "def heuristics_v2(df):\n    ema_close_10_day = df['close'].ewm(span=10, adjust=False).mean()\n    sma_close_10_day = df['close'].rolling(window=10).mean()\n    cv_close_10_day = df['close'].rolling(window=10).std() / df['close'].rolling(window=10).mean()\n    heuristics_matrix = (ema_close_10_day / sma_close_10_day) * (1 + cv_close_10_day)\n    return heuristics_matrix",
          "objective": -0.02611,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor by considering the ratio of the standard deviation of closing prices over the last 30 days to the exponential moving average (EMA) of the closing prices over the same period, combined with an adjustment based on the percentage change in volume compared to the average volume over the past 30 days.",
          "code": "def heuristics_v2(df):\n    std_close_30_day = df['close'].rolling(window=30).std()\n    ema_close_30_day = df['close'].ewm(span=30, adjust=False).mean()\n    avg_volume_30_day = df['volume'].rolling(window=30).mean()\n    vol_change_30_day = (df['volume'] - avg_volume_30_day) / avg_volume_30_day\n    heuristics_matrix = (std_close_30_day / ema_close_30_day) * (1 + vol_change_30_day)\n    return heuristics_matrix",
          "objective": -0.02167,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a modified heuristic factor by considering the ratio of the standard deviation of the closing prices over the last 10 days to the average of the highest high and lowest low prices over the same period, aiming to capture shorter-term volatility and price range dynamics.",
          "code": "def heuristics_v2(df):\n    std_close_10_day = df['close'].rolling(window=10).std()\n    avg_high_low_10_day = (df['high'].rolling(window=10).mean() + df['low'].rolling(window=10).mean()) / 2\n    heuristics_matrix = std_close_10_day / avg_high_low_10_day\n    return heuristics_matrix",
          "objective": -0.02161,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm incorporates the relative strength index (RSI) as a momentum indicator, alongside the ATR and MFI, and uses the difference between a 50-period and 200-period EMA to signal long-term trends.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate ATR\n    df['H-L'] = df['high'] - df['low']\n    df['H-PC'] = abs(df['high'] - df['close'].shift(1))\n    df['L-PC'] = abs(df['low'] - df['close'].shift(1))\n    df['TR'] = df[['H-L', 'H-PC', 'L-PC']].max(axis=1)\n    atr_period = 14\n    df['ATR'] = df['TR'].rolling(window=atr_period).mean()\n\n    # Calculate MFI\n    mfi_period = 14\n    typical_price = (df['high'] + df['low'] + df['close']) / 3\n    raw_money_flow = typical_price * df['volume']\n    positive_flow = raw_money_flow.where(typical_price > typical_price.shift(1), 0)\n    negative_flow = raw_money_flow.where(typical_price < typical_price.shift(1), 0)\n    positive_mf = positive_flow.rolling(window=mfi_period).sum()\n    negative_mf = negative_flow.rolling(window=mfi_period).sum()\n    money_flow_ratio = positive_mf / negative_mf\n    df['MFI'] = 100 - (100 / (1 + money_flow_ratio))\n\n    # Calculate RSI\n    delta = df['close'].diff()\n    up, down = delta.copy(), delta.copy()\n    up[up < 0] = 0\n    down[down > 0] = 0\n    rsi_period = 14\n    gain = up.ewm(com=rsi_period-1, adjust=False).mean()\n    loss = down.abs().ewm(com=rsi_period-1, adjust=False).mean()\n    rs = gain / loss\n    df['RSI'] = 100 - (100 / (1 + rs))\n\n    # Calculate EMA crossovers\n    short_ema_period = 50\n    long_ema_period = 200\n    df['EMA_Short'] = df['close'].ewm(span=short_ema_period, adjust=False).mean()\n    df['EMA_Long'] = df['close'].ewm(span=long_ema_period, adjust=False).mean()\n    ema_crossover = df['EMA_Short'] - df['EMA_Long']\n\n    # Combined heuristic: ATR adjusted by MFI and RSI, plus EMA crossover\n    heuristics_matrix = df['ATR'] + (df['MFI'] - 50) * 0.01 * df['ATR'] + (df['RSI'] - 50) * 0.01 * df['ATR'] + ema_crossover\n\n    return heuristics_matrix",
          "objective": -0.01844,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor based on the weighted combination of moving averages, volume changes, and price volatility, aiming to predict future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    short_window = 10\n    long_window = 30\n    df['short_mavg'] = df['close'].rolling(window=short_window, min_periods=short_window).mean()\n    df['long_mavg'] = df['close'].rolling(window=long_window, min_periods=long_window).mean()\n    df['volume_change'] = df['volume'].pct_change()\n    df['price_volatility'] = df['close'].rolling(window=short_window, min_periods=short_window).std()\n    df['heuristic_factor'] = (df['short_mavg'] - df['long_mavg']) + df['volume_change'] + df['price_volatility']\n    heuristics_matrix = df['heuristic_factor'].dropna()\n    return heuristics_matrix",
          "objective": -0.01742,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a novel alpha factor by integrating the average true range (ATR) as a measure of volatility, the money flow index (MFI) as an indicator of buying or selling pressure, and the exponential moving average (EMA) crossover to predict future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate ATR\n    df['H-L'] = df['high'] - df['low']\n    df['H-PC'] = abs(df['high'] - df['close'].shift(1))\n    df['L-PC'] = abs(df['low'] - df['close'].shift(1))\n    df['TR'] = df[['H-L', 'H-PC', 'L-PC']].max(axis=1)\n    atr_period = 14\n    df['ATR'] = df['TR'].rolling(window=atr_period).mean()\n\n    # Calculate MFI\n    mfi_period = 14\n    typical_price = (df['high'] + df['low'] + df['close']) / 3\n    raw_money_flow = typical_price * df['volume']\n    positive_flow = raw_money_flow.where(typical_price > typical_price.shift(1), 0)\n    negative_flow = raw_money_flow.where(typical_price < typical_price.shift(1), 0)\n    positive_mf = positive_flow.rolling(window=mfi_period).sum()\n    negative_mf = negative_flow.rolling(window=mfi_period).sum()\n    money_flow_ratio = positive_mf / negative_mf\n    df['MFI'] = 100 - (100 / (1 + money_flow_ratio))\n\n    # Calculate EMA crossovers\n    short_ema_period = 12\n    long_ema_period = 26\n    df['EMA_Short'] = df['close'].ewm(span=short_ema_period, adjust=False).mean()\n    df['EMA_Long'] = df['close'].ewm(span=long_ema_period, adjust=False).mean()\n    ema_crossover = df['EMA_Short'] - df['EMA_Long']\n\n    # Combined heuristic: ATR adjusted by MFI and EMA crossover\n    heuristics_matrix = df['ATR'] + (df['MFI'] - 50) * 0.01 * df['ATR'] + ema_crossover\n\n    return heuristics_matrix",
          "objective": -0.01738,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm integrates the Average True Range (ATR) as a volatility measure, the Money Flow Index (MFI) as an indicator of buying or selling pressure, and incorporates the difference between 5-period and 20-period Exponential Moving Averages (EMA) to generate a novel alpha factor.",
          "code": "def heuristics_v2(df):\n    # Calculate ATR\n    df['H-L'] = df['high'] - df['low']\n    df['H-PC'] = abs(df['high'] - df['close'].shift(1))\n    df['L-PC'] = abs(df['low'] - df['close'].shift(1))\n    df['TR'] = df[['H-L', 'H-PC', 'L-PC']].max(axis=1)\n    atr_period = 14\n    df['ATR'] = df['TR'].rolling(window=atr_period).mean()\n\n    # Calculate MFI\n    mfi_period = 14\n    typical_price = (df['high'] + df['low'] + df['close']) / 3\n    raw_money_flow = typical_price * df['volume']\n    positive_flow = raw_money_flow.where(typical_price > typical_price.shift(1), 0)\n    negative_flow = raw_money_flow.where(typical_price < typical_price.shift(1), 0)\n    positive_mf = positive_flow.rolling(window=mfi_period).sum()\n    negative_mf = negative_flow.rolling(window=mfi_period).sum()\n    money_flow_ratio = positive_mf / negative_mf\n    df['MFI'] = 100 - (100 / (1 + money_flow_ratio))\n\n    # Calculate EMA crossovers\n    ema_short_period = 5\n    ema_long_period = 20\n    df['EMA_Short'] = df['close'].ewm(span=ema_short_period, adjust=False).mean()\n    df['EMA_Long'] = df['close'].ewm(span=ema_long_period, adjust=False).mean()\n    ema_crossover = df['EMA_Short'] - df['EMA_Long']\n\n    # Combined heuristic: ATR adjusted by MFI and EMA crossover\n    heuristics_matrix = df['ATR'] + (df['MFI'] - 50) * 0.01 * df['ATR'] + ema_crossover\n\n    return heuristics_matrix",
          "objective": -0.01659,
          "other_inf": null
     }
]