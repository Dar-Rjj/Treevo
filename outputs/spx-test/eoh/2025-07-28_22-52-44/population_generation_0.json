[
     {
          "algorithm": "The algorithm calculates a heuristic factor based on the relative strength index (RSI) and moving average convergence divergence (MACD) to predict future stock returns, combining these with a custom momentum indicator derived from the difference between the close price and the volume-weighted average price (VWAP) over a specified period.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate RSI\n    delta = df['close'].diff(1)\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate MACD\n    ema_12 = df['close'].ewm(span=12, adjust=False).mean()\n    ema_26 = df['close'].ewm(span=26, adjust=False).mean()\n    macd = ema_12 - ema_26\n    signal = macd.rolling(window=9).mean()\n    \n    # Custom Momentum Indicator: Difference between close and VWAP\n    vwap = (df['volume'] * (df['high'] + df['low'] + df['close']) / 3).cumsum() / df['volume'].cumsum()\n    momentum_indicator = df['close'] - vwap\n    \n    # Combine factors\n    heuristics_matrix = 0.5 * (rsi - 50) + 0.3 * (macd - signal) + 0.2 * momentum_indicator\n    return heuristics_matrix",
          "objective": -0.02333,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates the ratio of the difference between the high and low prices to the closing price, then smooths this series using a 5-day moving average to generate a novel alpha factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the range (high - low) and then divide by the close price\n    volatility_factor = (df['high'] - df['low']) / df['close']\n    # Apply a 5-day moving average to smooth out the factor\n    heuristics_matrix = volatility_factor.rolling(window=5).mean()\n    return heuristics_matrix",
          "objective": -0.02276,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm, termed Dynamic Range Momentum (DRM), calculates the ratio of the difference between the highest and lowest price over a fixed period to the closing price, capturing the intensity of price movement as a heuristic factor.",
          "code": "def heuristics_v2(df):\n    def dynamic_range_momentum(row):\n        return (row['high'] - row['low']) / row['close']\n    \n    heuristics_matrix = df.apply(dynamic_range_momentum, axis=1)\n    return heuristics_matrix",
          "objective": -0.01597,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies patterns in the historical trading data by analyzing the relationship between volume and price changes, then generates a heuristics matrix that aims to predict future stock returns based on these discovered patterns.",
          "code": "def heuristics_v2(df):\n    # Calculate daily return\n    df['daily_return'] = df['close'].pct_change()\n    # Shift the daily return to align with the prediction target\n    df['next_day_return'] = df['daily_return'].shift(-1)\n    # Volume-weighted price change\n    df['vwp_change'] = ((df['close'] - df['open']) / (df['high'] - df['low'])) * df['volume']\n    # Heuristic factor: smoothed volume-weighted price change\n    df['heuristic_factor'] = df['vwp_change'].rolling(window=5).mean()\n    # Prepare the heuristics matrix\n    heuristics_matrix = df['heuristic_factor'].dropna()\n    return heuristics_matrix",
          "objective": -0.01418,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a heuristic factor based on the weighted combination of price momentum and volume changes, capturing potential shifts in investor sentiment and market dynamics.",
          "code": "def heuristics_v2(df):\n    # Calculate the momentum factor\n    momentum = df['close'].pct_change(periods=21)\n    \n    # Calculate the volume change factor\n    volume_change = df['volume'].pct_change(periods=7)\n    \n    # Combine the factors with weights\n    heuristics_matrix = 0.7 * momentum + 0.3 * volume_change\n    \n    return heuristics_matrix",
          "objective": -0.01357,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a weighted sum of the moving averages of price and volume over different time periods to generate a novel alpha factor, incorporating a momentum signal and a volume-based activity measure.",
          "code": "def heuristics_v2(df):\n    short_window = 5\n    long_window = 20\n    price_moving_avg_short = df['close'].rolling(window=short_window).mean()\n    price_moving_avg_long = df['close'].rolling(window=long_window).mean()\n    volume_change = df['volume'].pct_change().fillna(0)\n    heuristics_matrix = (price_moving_avg_short - price_moving_avg_long) * (1 + volume_change)\n    return heuristics_matrix",
          "objective": -0.01185,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies patterns in the relationship between daily trading volumes and price movements, using a combination of moving averages and volume changes to generate factor values that potentially predict future stock returns.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change()\n    df['volume_change'] = df['volume'].pct_change()\n    df['avg_price_10d'] = df['close'].rolling(window=10).mean()\n    df['avg_volume_10d'] = df['volume'].rolling(window=10).mean()\n    df['heuristic_factor'] = (df['price_change'] * df['avg_volume_10d']) + (df['volume_change'] * df['avg_price_10d'])\n    heuristics_matrix = df['heuristic_factor']\n    return heuristics_matrix",
          "objective": -0.01044,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm, named Heuristics V2, generates novel alpha factors by combining market features through a series of arithmetic and comparative operations designed to highlight unique patterns and anomalies in stock behavior.",
          "code": "def heuristics_v2(df):\n    # Calculate the difference between high and low prices as volatility measure\n    daily_volatility = df['high'] - df['low']\n    \n    # Calculate the ratio of close price to open price as a momentum indicator\n    close_open_ratio = df['close'] / df['open']\n    \n    # Identify days where the closing price is below the opening price (bearish day)\n    bearish_day = (df['close'] < df['open']).astype(int)\n    \n    # Compute the change in volume compared to the previous day to gauge interest\n    volume_change = df['volume'].pct_change().fillna(0)\n    \n    # Combine the factors into a single heuristic score for each day\n    heuristics_matrix = (daily_volatility + close_open_ratio + bearish_day * 10 + volume_change) / 4\n    \n    return heuristics_matrix",
          "objective": -0.00869,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm leverages a combination of momentum and volatility indicators, calculating the difference between the 50-day and 200-day moving averages (as a measure of medium to long-term momentum) and the standard deviation over the last 50 days (representing recent volatility), to form a composite heuristic factor.",
          "code": "def heuristics_v2(df):\n    ma_50 = df['close'].rolling(window=50).mean()\n    ma_200 = df['close'].rolling(window=200).mean()\n    vol_50 = df['close'].rolling(window=50).std()\n    heuristics_matrix = (ma_50 - ma_200) / vol_50\n    return heuristics_matrix",
          "objective": -0.00686,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a composite factor by integrating moving average crossovers, momentum, and volume surge signals to predict future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Momentum Factor\n    df['momentum'] = df['close'].pct_change(periods=12)\n    \n    # Moving Average Crossover\n    df['SMA_50'] = df['close'].rolling(window=50).mean()\n    df['SMA_200'] = df['close'].rolling(window=200).mean()\n    df['crossover'] = df['SMA_50'] > df['SMA_200']\n    \n    # Volume Surge\n    df['volume_surge'] = df['volume'].pct_change(periods=1) > 0.5\n    \n    # Composite Heuristic\n    df['composite_heuristic'] = (df['momentum'] + df['crossover'].astype(int) + df['volume_surge'].astype(int)) / 3\n    \n    heuristics_matrix = df['composite_heuristic']\n    \n    return heuristics_matrix",
          "objective": -0.00606,
          "other_inf": null
     }
]