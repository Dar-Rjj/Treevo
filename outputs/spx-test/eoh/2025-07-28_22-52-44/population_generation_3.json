[
     {
          "algorithm": "The new algorithm calculates the difference between the logarithm of the high and low prices, normalized by the average of the open and close prices, then applies a 10-day exponentially weighted moving average to smooth this series.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the log difference between high and low\n    log_diff = np.log(df['high']) - np.log(df['low'])\n    # Normalize by the average of open and close prices\n    volatility_factor = log_diff / ((df['open'] + df['close']) / 2)\n    # Apply a 10-day exponentially weighted moving average to smooth out the factor\n    heuristics_matrix = volatility_factor.ewm(span=10).mean()\n    return heuristics_matrix",
          "objective": -0.03433,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the weighted sum of the differences between high and low prices, with weights inversely proportional to the square root of the closing price, over a 20-day rolling window, then divides by the weighted sum of closing prices with the same weights, aiming to reflect intraday volatility adjusted for price level.",
          "code": "import numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the difference between high and low prices for each day\n    hl_diff = df['high'] - df['low']\n    # Calculate the inverse of the square root of the close price as the weight\n    weights = 1 / np.sqrt(df['close'])\n    # Weighted sum of the high-low differences over a 20-day rolling window\n    weighted_hl_diff_sum = (hl_diff * weights).rolling(window=20).sum()\n    # Weighted sum of the close prices over the same 20-day rolling window\n    weighted_close_sum = (df['close'] * weights).rolling(window=20).sum()\n    # Calculate the ratio of the weighted sum of high-low differences to the weighted sum of close prices\n    heuristics_matrix = weighted_hl_diff_sum / weighted_close_sum\n    return heuristics_matrix",
          "objective": -0.03256,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the sum of the differences between the high and low prices to the sum of closing prices over a 20-day window, aiming to capture the average intraday volatility relative to the total market activity.",
          "code": "def heuristics_v2(df):\n    # Calculate the difference between high and low prices for each day\n    hl_diff = df['high'] - df['low']\n    # Sum the high-low differences over a 20-day rolling window\n    hl_diff_sum = hl_diff.rolling(window=20).sum()\n    # Sum the close prices over the same 20-day rolling window\n    close_sum = df['close'].rolling(window=20).sum()\n    # Calculate the ratio of the sum of high-low differences to the sum of close prices\n    heuristics_matrix = hl_diff_sum / close_sum\n    return heuristics_matrix",
          "objective": -0.03243,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the sum of the absolute differences between consecutive days' closing prices to the sum of closing prices over a 20-day window, aiming to capture a smoothed measure of price volatility.",
          "code": "def heuristics_v2(df):\n    # Calculate the absolute difference between consecutive days' close prices\n    abs_diff = df['close'].diff().abs()\n    # Sum the absolute differences and the close prices over a 20-day rolling window\n    abs_diff_sum = abs_diff.rolling(window=20).sum()\n    close_sum = df['close'].rolling(window=20).sum()\n    # Calculate the ratio of the sum of absolute differences to the sum of close prices\n    heuristics_matrix = abs_diff_sum / close_sum\n    return heuristics_matrix",
          "objective": -0.03192,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the sum of absolute differences between consecutive days' closing prices to the sum of closing prices over a 30-day window, aiming to emphasize consistent price movements.",
          "code": "def heuristics_v2(df):\n    # Calculate the absolute difference between consecutive days' close prices\n    abs_diff = df['close'].diff().abs()\n    # Sum the absolute differences and the close prices over a 30-day rolling window\n    abs_diff_sum = abs_diff.rolling(window=30).sum()\n    close_sum = df['close'].rolling(window=30).sum()\n    # Calculate the ratio of the sum of absolute differences to the sum of close prices\n    heuristics_matrix = abs_diff_sum / close_sum\n    return heuristics_matrix",
          "objective": -0.03126,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the weighted sum of the differences between high and low prices, with weights inversely proportional to the cube root of the closing price, over a 30-day rolling window, then divides by the weighted sum of closing prices with the same weights, aiming to reflect intraday volatility adjusted for price level.",
          "code": "def heuristics_v2(df):\n    hl_diff = df['high'] - df['low']\n    weights = 1 / (df['close'] ** (1/3))\n    weighted_hl_diff_sum = (hl_diff * weights).rolling(window=30).sum()\n    weighted_close_sum = (df['close'] * weights).rolling(window=30).sum()\n    heuristics_matrix = weighted_hl_diff_sum / weighted_close_sum\n    return heuristics_matrix",
          "objective": -0.03107,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the sum of the absolute differences between consecutive days' high and low prices to the sum of closing prices over a 30-day window, aiming to capture a broader measure of intraday price volatility.",
          "code": "def heuristics_v2(df):\n    # Calculate the absolute difference between consecutive days' high and low prices\n    abs_diff = (df['high'] - df['low']).abs()\n    # Sum the absolute differences and the close prices over a 30-day rolling window\n    abs_diff_sum = abs_diff.rolling(window=30).sum()\n    close_sum = df['close'].rolling(window=30).sum()\n    # Calculate the ratio of the sum of absolute differences to the sum of close prices\n    heuristics_matrix = abs_diff_sum / close_sum\n    return heuristics_matrix",
          "objective": -0.03091,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the weighted sum of the differences between high and low prices, with weights being the logarithm of the closing price, over a 30-day rolling window, then divides by the weighted sum of the closing prices using the same weights, aiming to reflect intraday volatility adjusted for price level.",
          "code": "import numpy as np\n\ndef heuristics_v2(df):\n    hl_diff = df['high'] - df['low']\n    weights = np.log(df['close'])\n    weighted_hl_diff_sum = (hl_diff * weights).rolling(window=30).sum()\n    weighted_close_sum = (df['close'] * weights).rolling(window=30).sum()\n    heuristics_matrix = weighted_hl_diff_sum / weighted_close_sum\n    return heuristics_matrix",
          "objective": -0.0308,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the sum of the squared differences between consecutive days' closing prices to the sum of the squared closing prices over a 30-day window, aiming to capture a more pronounced measure of price volatility.",
          "code": "def heuristics_v2(df):\n    # Calculate the squared difference between consecutive days' close prices\n    sq_diff = df['close'].diff().pow(2)\n    # Sum the squared differences and the squared close prices over a 30-day rolling window\n    sq_diff_sum = sq_diff.rolling(window=30).sum()\n    close_sq_sum = df['close'].pow(2).rolling(window=30).sum()\n    # Calculate the ratio of the sum of squared differences to the sum of squared close prices\n    heuristics_matrix = sq_diff_sum / close_sq_sum\n    return heuristics_matrix",
          "objective": -0.03048,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the sum of squared differences between consecutive days' closing prices to the sum of squares of closing prices over a 20-day window, aiming to emphasize volatility.",
          "code": "def heuristics_v2(df):\n    # Calculate the squared difference between consecutive days' close prices\n    sq_diff = df['close'].diff().pow(2)\n    # Sum the squared differences and the squares of close prices over a 20-day rolling window\n    sq_diff_sum = sq_diff.rolling(window=20).sum()\n    close_sq_sum = df['close'].pow(2).rolling(window=20).sum()\n    # Calculate the ratio of the sum of squared differences to the sum of squares of close prices\n    heuristics_matrix = sq_diff_sum / close_sq_sum\n    return heuristics_matrix",
          "objective": -0.03,
          "other_inf": null
     }
]