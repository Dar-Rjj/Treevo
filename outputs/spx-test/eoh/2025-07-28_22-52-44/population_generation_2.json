[
     {
          "algorithm": "The new algorithm calculates the ratio of the sum of the absolute differences between consecutive days' closing prices to the sum of closing prices over a 20-day window, aiming to capture a smoothed measure of price volatility.",
          "code": "def heuristics_v2(df):\n    # Calculate the absolute difference between consecutive days' close prices\n    abs_diff = df['close'].diff().abs()\n    # Sum the absolute differences and the close prices over a 20-day rolling window\n    abs_diff_sum = abs_diff.rolling(window=20).sum()\n    close_sum = df['close'].rolling(window=20).sum()\n    # Calculate the ratio of the sum of absolute differences to the sum of close prices\n    heuristics_matrix = abs_diff_sum / close_sum\n    return heuristics_matrix",
          "objective": -0.03192,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the sum of absolute differences between consecutive days' closing prices to the sum of closing prices over a 30-day window, aiming to emphasize consistent price movements.",
          "code": "def heuristics_v2(df):\n    # Calculate the absolute difference between consecutive days' close prices\n    abs_diff = df['close'].diff().abs()\n    # Sum the absolute differences and the close prices over a 30-day rolling window\n    abs_diff_sum = abs_diff.rolling(window=30).sum()\n    close_sum = df['close'].rolling(window=30).sum()\n    # Calculate the ratio of the sum of absolute differences to the sum of close prices\n    heuristics_matrix = abs_diff_sum / close_sum\n    return heuristics_matrix",
          "objective": -0.03126,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the sum of the squared differences between consecutive days' closing prices to the sum of the squared closing prices over a 30-day window, aiming to capture a more pronounced measure of price volatility.",
          "code": "def heuristics_v2(df):\n    # Calculate the squared difference between consecutive days' close prices\n    sq_diff = df['close'].diff().pow(2)\n    # Sum the squared differences and the squared close prices over a 30-day rolling window\n    sq_diff_sum = sq_diff.rolling(window=30).sum()\n    close_sq_sum = df['close'].pow(2).rolling(window=30).sum()\n    # Calculate the ratio of the sum of squared differences to the sum of squared close prices\n    heuristics_matrix = sq_diff_sum / close_sq_sum\n    return heuristics_matrix",
          "objective": -0.03048,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the sum of squared differences between consecutive days' closing prices to the square of the sum of closing prices over a 20-day window, aiming to capture a smoothed measure of price volatility with an emphasis on larger deviations.",
          "code": "def heuristics_v2(df):\n    # Calculate the squared difference between consecutive days' close prices\n    sq_diff = df['close'].diff() ** 2\n    # Sum the squared differences and the close prices over a 20-day rolling window\n    sq_diff_sum = sq_diff.rolling(window=20).sum()\n    close_sum = df['close'].rolling(window=20).sum()\n    # Calculate the ratio of the sum of squared differences to the square of the sum of close prices\n    heuristics_matrix = sq_diff_sum / (close_sum ** 2)\n    return heuristics_matrix",
          "objective": -0.02991,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of (high - low) to (close), then applies a 20-day exponentially weighted moving average for smoothing.",
          "code": "def heuristics_v2(df):\n    # Calculate the range (high - low) and then divide by (close)\n    volatility_factor = (df['high'] - df['low']) / df['close']\n    # Apply a 20-day exponentially weighted moving average to smooth out the factor\n    heuristics_matrix = volatility_factor.ewm(span=20).mean()\n    return heuristics_matrix",
          "objective": -0.02883,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of (high - low) to (high + low), then applies a 20-day exponentially weighted moving average for smoothing.",
          "code": "def heuristics_v2(df):\n    # Calculate the range (high - low) and then divide by (high + low)\n    volatility_factor = (df['high'] - df['low']) / (df['high'] + df['low'])\n    # Apply a 20-day exponentially weighted moving average to smooth out the factor\n    heuristics_matrix = volatility_factor.ewm(span=20).mean()\n    return heuristics_matrix",
          "objective": -0.02878,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the difference between the high and low prices to the opening price, then smooths this series using a 10-day moving average to generate a novel alpha factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the range (high - low) and then divide by the open price\n    volatility_factor = (df['high'] - df['low']) / df['open']\n    # Apply a 10-day moving average to smooth out the factor\n    heuristics_matrix = volatility_factor.rolling(window=10).mean()\n    return heuristics_matrix",
          "objective": -0.02836,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the difference between the high and low prices to the average of the open and close prices, then applies a 10-day exponentially weighted moving average to smooth this series.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the range (high - low) and then divide by the average of open and close prices\n    volatility_factor = (df['high'] - df['low']) / ((df['open'] + df['close']) / 2)\n    # Apply a 10-day exponentially weighted moving average to smooth out the factor\n    heuristics_matrix = volatility_factor.ewm(span=10).mean()\n    return heuristics_matrix",
          "objective": -0.02598,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the range (high - low) to the opening price, then applies a 10-day exponentially weighted moving average for smoothing.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the range (high - low) and then divide by the open price\n    volatility_factor = (df['high'] - df['low']) / df['open']\n    # Apply a 10-day exponentially weighted moving average to smooth out the factor\n    heuristics_matrix = volatility_factor.ewm(span=10).mean()\n    return heuristics_matrix",
          "objective": -0.02587,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the difference between the high and low prices to the average of high and low, then smooths this series using a 7-day moving average.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the range (high - low) and then divide by the average of high and low\n    volatility_factor = (df['high'] - df['low']) / ((df['high'] + df['low']) / 2)\n    # Apply a 7-day moving average to smooth out the factor\n    heuristics_matrix = volatility_factor.rolling(window=7).mean()\n    return heuristics_matrix",
          "objective": -0.02552,
          "other_inf": null
     }
]