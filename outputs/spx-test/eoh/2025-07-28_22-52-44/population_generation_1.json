[
     {
          "algorithm": "The new algorithm calculates the ratio of (high - low) to (high + low), then applies a 20-day exponentially weighted moving average for smoothing.",
          "code": "def heuristics_v2(df):\n    # Calculate the range (high - low) and then divide by (high + low)\n    volatility_factor = (df['high'] - df['low']) / (df['high'] + df['low'])\n    # Apply a 20-day exponentially weighted moving average to smooth out the factor\n    heuristics_matrix = volatility_factor.ewm(span=20).mean()\n    return heuristics_matrix",
          "objective": -0.02878,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the range (high - low) to the opening price, then applies a 10-day exponentially weighted moving average for smoothing.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the range (high - low) and then divide by the open price\n    volatility_factor = (df['high'] - df['low']) / df['open']\n    # Apply a 10-day exponentially weighted moving average to smooth out the factor\n    heuristics_matrix = volatility_factor.ewm(span=10).mean()\n    return heuristics_matrix",
          "objective": -0.02587,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a heuristic factor based on the relative strength index (RSI) and moving average convergence divergence (MACD) to predict future stock returns, combining these with a custom momentum indicator derived from the difference between the close price and the volume-weighted average price (VWAP) over a specified period.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate RSI\n    delta = df['close'].diff(1)\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate MACD\n    ema_12 = df['close'].ewm(span=12, adjust=False).mean()\n    ema_26 = df['close'].ewm(span=26, adjust=False).mean()\n    macd = ema_12 - ema_26\n    signal = macd.rolling(window=9).mean()\n    \n    # Custom Momentum Indicator: Difference between close and VWAP\n    vwap = (df['volume'] * (df['high'] + df['low'] + df['close']) / 3).cumsum() / df['volume'].cumsum()\n    momentum_indicator = df['close'] - vwap\n    \n    # Combine factors\n    heuristics_matrix = 0.5 * (rsi - 50) + 0.3 * (macd - signal) + 0.2 * momentum_indicator\n    return heuristics_matrix",
          "objective": -0.02333,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates the ratio of the difference between the high and low prices to the closing price, then smooths this series using a 5-day moving average to generate a novel alpha factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the range (high - low) and then divide by the close price\n    volatility_factor = (df['high'] - df['low']) / df['close']\n    # Apply a 5-day moving average to smooth out the factor\n    heuristics_matrix = volatility_factor.rolling(window=5).mean()\n    return heuristics_matrix",
          "objective": -0.02276,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor using a 20-day RSI, a 9 and 21 EMA for MACD, and a custom momentum indicator based on the difference between the closing price and the volume-weighted average price (VWAP) over a 10-day period.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate RSI with a 20-day lookback\n    delta = df['close'].diff(1)\n    gain = (delta.where(delta > 0, 0)).rolling(window=20).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=20).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate MACD with 9 and 21 EMAs\n    ema_9 = df['close'].ewm(span=9, adjust=False).mean()\n    ema_21 = df['close'].ewm(span=21, adjust=False).mean()\n    macd = ema_9 - ema_21\n    signal = macd.rolling(window=9).mean()\n    \n    # Custom Momentum Indicator: Difference between close and VWAP over 10 days\n    vwap = (df['volume'] * (df['high'] + df['low'] + df['close']) / 3).cumsum() / df['volume'].cumsum()\n    vwap_10 = vwap.rolling(window=10).mean()\n    momentum_indicator = df['close'] - vwap_10\n    \n    # Combine factors\n    heuristics_matrix = 0.5 * (rsi - 50) + 0.3 * (macd - signal) + 0.2 * momentum_indicator\n    return heuristics_matrix",
          "objective": -0.02254,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm incorporates a 20-day rolling mean of the price, combines this with a 14-day momentum factor, and a 5-day volume change, using different weights for each component.",
          "code": "def heuristics_v2(df):\n    # Calculate the smoothed close price\n    smoothed_close = df['close'].rolling(window=20).mean().pct_change(periods=14)\n    \n    # Calculate the momentum factor\n    momentum = df['close'].pct_change(periods=14)\n    \n    # Calculate the volume change factor\n    volume_change = df['volume'].pct_change(periods=5)\n    \n    # Combine the factors with new weights\n    heuristics_matrix = 0.6 * smoothed_close + 0.3 * momentum + 0.1 * volume_change\n    \n    return heuristics_matrix",
          "objective": -0.01709,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor by combining the difference between a short-term and long-term weighted moving average of the closing prices with the ratio of the closing price to the average volume over the past 20 days, aiming to capture price momentum and relative volume pressure.",
          "code": "def heuristics_v2(df):\n    # Calculate Short-Term and Long-Term Weighted Moving Average\n    wma_short = df['close'].rolling(window=10).mean()\n    wma_long = df['close'].rolling(window=30).mean()\n    \n    # Difference Between Short-Term and Long-Term WMA\n    wma_diff_signal = wma_short - wma_long\n    \n    # Average Volume Over the Past 20 Days\n    avg_volume_20 = df['volume'].rolling(window=20).mean()\n    \n    # Ratio of Close Price to Average Volume\n    close_avg_volume_ratio = df['close'] / avg_volume_20\n    \n    # Combine Factors\n    heuristics_matrix = 0.6 * wma_diff_signal + 0.4 * close_avg_volume_ratio\n    return heuristics_matrix",
          "objective": -0.0163,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm, termed Dynamic Range Momentum (DRM), calculates the ratio of the difference between the highest and lowest price over a fixed period to the closing price, capturing the intensity of price movement as a heuristic factor.",
          "code": "def heuristics_v2(df):\n    def dynamic_range_momentum(row):\n        return (row['high'] - row['low']) / row['close']\n    \n    heuristics_matrix = df.apply(dynamic_range_momentum, axis=1)\n    return heuristics_matrix",
          "objective": -0.01597,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm, termed Adjusted Dynamic Range Momentum (ADRM), calculates the ratio of the difference between the highest and lowest price over a fixed period to the average of the high and low prices, aiming to capture the intensity of price movement while smoothing out extreme values.",
          "code": "def heuristics_v2(df):\n    def adjusted_dynamic_range_momentum(row):\n        return (row['high'] - row['low']) / ((row['high'] + row['low']) / 2)\n    \n    heuristics_matrix = df.apply(adjusted_dynamic_range_momentum, axis=1)\n    return heuristics_matrix",
          "objective": -0.01582,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm incorporates a rolling mean of the price over a 14-day period to smooth out short-term fluctuations, combines this with the momentum factor and volume change, using different weights for each component.",
          "code": "def heuristics_v2(df):\n    # Calculate the smoothed close price\n    smoothed_close = df['close'].rolling(window=14).mean().pct_change(periods=21)\n    \n    # Calculate the momentum factor\n    momentum = df['close'].pct_change(periods=21)\n    \n    # Calculate the volume change factor\n    volume_change = df['volume'].pct_change(periods=7)\n    \n    # Combine the factors with new weights\n    heuristics_matrix = 0.5 * smoothed_close + 0.3 * momentum + 0.2 * volume_change\n    \n    return heuristics_matrix",
          "objective": -0.0154,
          "other_inf": null
     }
]