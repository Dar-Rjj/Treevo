[
     {
          "algorithm": "The new algorithm calculates the weighted sum of the differences between high and low prices, with weights inversely proportional to the square root of the closing price, over a 20-day rolling window, then divides by the simple moving average (SMA) of the closing prices over the same window, aiming to provide a smoothed measure of intraday volatility relative to the average price level.",
          "code": "def heuristics_v2(df):\n    hl_diff = df['high'] - df['low']\n    weights = 1 / (df['close'] ** (1/2))\n    weighted_hl_diff_sum = (hl_diff * weights).rolling(window=20).sum()\n    sma_close = df['close'].rolling(window=20).mean()\n    heuristics_matrix = weighted_hl_diff_sum / sma_close\n    return heuristics_matrix",
          "objective": -0.04395,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the exponential moving average (EMA) of the differences between high and low prices, with weights inversely proportional to the square root of the closing price, over a 20-day rolling window, then divides by the simple moving average (SMA) of the closing prices over the same window.",
          "code": "def heuristics_v2(df):\n    hl_diff = df['high'] - df['low']\n    weights = 1 / (df['close'] ** (1/2))\n    weighted_hl_diff_ema = (hl_diff * weights).ewm(span=20, adjust=False).mean()\n    sma_close = df['close'].rolling(window=20).mean()\n    heuristics_matrix = weighted_hl_diff_ema / sma_close\n    return heuristics_matrix",
          "objective": -0.04238,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the exponential moving average (EMA) of the differences between high and low prices, with weights inversely proportional to the square root of the closing price, over a 20-day window, then divides by the EMA of the closing prices over the same window, aiming to provide a smoothed measure of intraday volatility relative to the average price level.",
          "code": "def heuristics_v2(df):\n    hl_diff = df['high'] - df['low']\n    weights = 1 / (df['close'] ** (1/2))\n    weighted_hl_diff_ema = (hl_diff * weights).ewm(span=20).mean()\n    ema_close = df['close'].ewm(span=20).mean()\n    heuristics_matrix = weighted_hl_diff_ema / ema_close\n    return heuristics_matrix",
          "objective": -0.04088,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the exponential moving average (EMA) of the differences between high and low prices, with weights inversely proportional to the cube root of the closing price, over a 10-day window, then divides by the EMA of the closing prices over the same window, to provide a more sensitive measure of intraday volatility relative to the average price level.",
          "code": "def heuristics_v2(df):\n    hl_diff = df['high'] - df['low']\n    weights = 1 / (df['close'] ** (1/3))\n    weighted_hl_diff_ema = (hl_diff * weights).ewm(span=10).mean()\n    ema_close = df['close'].ewm(span=10).mean()\n    heuristics_matrix = weighted_hl_diff_ema / ema_close\n    return heuristics_matrix",
          "objective": -0.03957,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the sum of the logarithmic differences between consecutive days' closing prices, divided by the sum of closing prices over a 20-day rolling window, aiming to provide a measure of price change that is more sensitive to percentage changes.",
          "code": "import numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the logarithmic difference between consecutive days' close prices\n    log_diff = np.log(df['close']).diff().abs()\n    # Sum the logarithmic differences and the close prices over a 20-day rolling window\n    log_diff_sum = log_diff.rolling(window=20).sum()\n    close_sum = df['close'].rolling(window=20).sum()\n    # Calculate the ratio of the sum of logarithmic differences to the sum of close prices\n    heuristics_matrix = log_diff_sum / close_sum\n    return heuristics_matrix",
          "objective": -0.03913,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the weighted sum of the differences between high and low prices, with weights inversely proportional to the cube root of the closing price, over a 30-day rolling window, then divides by the weighted sum of squared closing prices with the same weights, aiming to capture a more nuanced view of intraday volatility adjusted for a higher sensitivity to price level.",
          "code": "import numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the difference between high and low prices for each day\n    hl_diff = df['high'] - df['low']\n    # Calculate the inverse of the cube root of the close price as the weight\n    weights = 1 / np.cbrt(df['close'])\n    # Weighted sum of the high-low differences over a 30-day rolling window\n    weighted_hl_diff_sum = (hl_diff * weights).rolling(window=30).sum()\n    # Weighted sum of the squared close prices over the same 30-day rolling window\n    weighted_close_squared_sum = ((df['close'] ** 2) * weights).rolling(window=30).sum()\n    # Calculate the ratio of the weighted sum of high-low differences to the weighted sum of squared close prices\n    heuristics_matrix = weighted_hl_diff_sum / weighted_close_squared_sum\n    return heuristics_matrix",
          "objective": -0.03648,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the weighted sum of the differences between high and low prices, with weights inversely proportional to the closing price, over a 10-day rolling window, then divides by the exponential moving average (EMA) of the closing prices over the same window, aiming to provide a dynamic measure of intraday volatility relative to the trend-adjusted price level.",
          "code": "def heuristics_v2(df):\n    hl_diff = df['high'] - df['low']\n    weights = 1 / df['close']\n    weighted_hl_diff_sum = (hl_diff * weights).rolling(window=10).sum()\n    ema_close = df['close'].ewm(span=10, adjust=False).mean()\n    heuristics_matrix = weighted_hl_diff_sum / ema_close\n    return heuristics_matrix",
          "objective": -0.03618,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the difference between the logarithm of the high and low prices, normalized by the average of the open and close prices, then applies a 10-day exponentially weighted moving average to smooth this series.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the log difference between high and low\n    log_diff = np.log(df['high']) - np.log(df['low'])\n    # Normalize by the average of open and close prices\n    volatility_factor = log_diff / ((df['open'] + df['close']) / 2)\n    # Apply a 10-day exponentially weighted moving average to smooth out the factor\n    heuristics_matrix = volatility_factor.ewm(span=10).mean()\n    return heuristics_matrix",
          "objective": -0.03433,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the weighted sum of the differences between high and low prices, with weights inversely proportional to the square root of the closing price, over a 20-day rolling window, then divides by the weighted sum of closing prices with the same weights, aiming to reflect intraday volatility adjusted for price level.",
          "code": "import numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the difference between high and low prices for each day\n    hl_diff = df['high'] - df['low']\n    # Calculate the inverse of the square root of the close price as the weight\n    weights = 1 / np.sqrt(df['close'])\n    # Weighted sum of the high-low differences over a 20-day rolling window\n    weighted_hl_diff_sum = (hl_diff * weights).rolling(window=20).sum()\n    # Weighted sum of the close prices over the same 20-day rolling window\n    weighted_close_sum = (df['close'] * weights).rolling(window=20).sum()\n    # Calculate the ratio of the weighted sum of high-low differences to the weighted sum of close prices\n    heuristics_matrix = weighted_hl_diff_sum / weighted_close_sum\n    return heuristics_matrix",
          "objective": -0.03256,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the sum of the differences between the high and low prices to the sum of closing prices over a 20-day window, aiming to capture the average intraday volatility relative to the total market activity.",
          "code": "def heuristics_v2(df):\n    # Calculate the difference between high and low prices for each day\n    hl_diff = df['high'] - df['low']\n    # Sum the high-low differences over a 20-day rolling window\n    hl_diff_sum = hl_diff.rolling(window=20).sum()\n    # Sum the close prices over the same 20-day rolling window\n    close_sum = df['close'].rolling(window=20).sum()\n    # Calculate the ratio of the sum of high-low differences to the sum of close prices\n    heuristics_matrix = hl_diff_sum / close_sum\n    return heuristics_matrix",
          "objective": -0.03243,
          "other_inf": null
     }
]