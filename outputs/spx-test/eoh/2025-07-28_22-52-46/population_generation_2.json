[
     {
          "algorithm": "The new algorithm adjusts the original by incorporating a weighted sum of momentum, simple moving average crossovers, and volume trends, with weights adjusted dynamically based on their rolling 30-day historical Sharpe ratios, to predict future returns.",
          "code": "def heuristics_v2(df):\n    # Compute daily return\n    df['daily_return'] = df['close'].pct_change()\n    \n    # Compute simple moving averages for close price\n    df['sma_10'] = df['close'].rolling(window=10).mean()\n    df['sma_30'] = df['close'].rolling(window=30).mean()\n    \n    # Calculate momentum\n    df['momentum'] = df['close'] - df['close'].shift(5)\n    \n    # Calculate SMA crossover\n    df['sma_crossover'] = df['sma_10'] - df['sma_30']\n    \n    # Volume trend\n    df['volume_trend'] = df['volume'].rolling(window=10).mean() / df['volume'].rolling(window=30).mean()\n    \n    # Rolling 30-day historical Sharpe ratios\n    sharpe_ratios_momentum = (df['momentum'] * df['daily_return'].shift(-1)).rolling(window=30).mean() / df['momentum'].rolling(window=30).std()\n    sharpe_ratios_sma_crossover = (df['sma_crossover'] * df['daily_return'].shift(-1)).rolling(window=30).mean() / df['sma_crossover'].rolling(window=30).std()\n    sharpe_ratios_volume_trend = (df['volume_trend'] * df['daily_return'].shift(-1)).rolling(window=30).mean() / df['volume_trend'].rolling(window=30).std()\n    \n    # Generate heuristic matrix\n    heuristics_matrix = (df['momentum'] * sharpe_ratios_momentum +\n                         df['sma_crossover'] * sharpe_ratios_sma_crossover +\n                         df['volume_trend'] * sharpe_ratios_volume_trend)\n    \n    return heuristics_matrix",
          "objective": -0.06519,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a weighted sum of momentum, simple moving average crossovers, and volume trends, with weights based on their historical Sharpe ratios rather than correlations, to predict future returns.}\n\n```python\ndef heuristics_v2(df):\n    # Compute daily return\n    df['daily_return'] = df['close'].pct_change()\n    \n    # Compute simple moving averages for close price\n    df['sma_10'] = df['close'].rolling(window=10).mean()\n    df['sma_30'] = df['close'].rolling(window=30).mean()\n    \n    # Calculate momentum\n    df['momentum'] = df['close'] - df['close'].shift(5)\n    \n    # Calculate SMA crossover\n    df['sma_crossover'] = df['sma_10'] - df['sma_30']\n    \n    # Volume trend\n    df['volume_trend'] = df['volume'].rolling(window=10).mean() / df['volume'].rolling(window=30).mean()\n    \n    # Historical Sharpe ratios\n    sharpe_ratios = {'momentum': (df['momentum'] * df['daily_return'].shift(-1)).mean() / df['momentum'].std(),\n                     'sma_crossover': (df['sma_crossover'] * df['daily_return'].shift(-1)).mean() / df['sma_crossover'].std(),\n                     'volume_trend': (df['volume_trend'] * df['daily_return'].shift(-1)).mean() / df['volume_trend'].std()",
          "code": "def heuristics_v2(df):\n    # Compute daily return\n    df['daily_return'] = df['close'].pct_change()\n    \n    # Compute simple moving averages for close price\n    df['sma_10'] = df['close'].rolling(window=10).mean()\n    df['sma_30'] = df['close'].rolling(window=30).mean()\n    \n    # Calculate momentum\n    df['momentum'] = df['close'] - df['close'].shift(5)\n    \n    # Calculate SMA crossover\n    df['sma_crossover'] = df['sma_10'] - df['sma_30']\n    \n    # Volume trend\n    df['volume_trend'] = df['volume'].rolling(window=10).mean() / df['volume'].rolling(window=30).mean()\n    \n    # Historical Sharpe ratios\n    sharpe_ratios = {'momentum': (df['momentum'] * df['daily_return'].shift(-1)).mean() / df['momentum'].std(),\n                     'sma_crossover': (df['sma_crossover'] * df['daily_return'].shift(-1)).mean() / df['sma_crossover'].std(),\n                     'volume_trend': (df['volume_trend'] * df['daily_return'].shift(-1)).mean() / df['volume_trend'].std()}\n    \n    # Generate heuristic matrix\n    heuristics_matrix = (df['momentum'] * sharpe_ratios['momentum'] +\n                         df['sma_crossover'] * sharpe_ratios['sma_crossover'] +\n                         df['volume_trend'] * sharpe_ratios['volume_trend'])\n    \n    return heuristics_matrix",
          "objective": -0.05401,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm adjusts the original by incorporating a weighted sum of momentum, simple moving average crossovers, and volume trends, with weights adjusted dynamically based on their rolling 60-day historical Sharpe ratios, to predict future returns.",
          "code": "def heuristics_v2(df):\n    # Compute daily return\n    df['daily_return'] = df['close'].pct_change()\n    \n    # Compute simple moving averages for close price\n    df['sma_10'] = df['close'].rolling(window=10).mean()\n    df['sma_30'] = df['close'].rolling(window=30).mean()\n    \n    # Calculate momentum\n    df['momentum'] = df['close'] - df['close'].shift(5)\n    \n    # Calculate SMA crossover\n    df['sma_crossover'] = df['sma_10'] - df['sma_30']\n    \n    # Volume trend\n    df['volume_trend'] = df['volume'].rolling(window=10).mean() / df['volume'].rolling(window=30).mean()\n    \n    # Rolling 60-day historical Sharpe ratios\n    sharpe_ratios_momentum = (df['momentum'] * df['daily_return'].shift(-1)).rolling(window=60).mean() / df['momentum'].rolling(window=60).std()\n    sharpe_ratios_sma_crossover = (df['sma_crossover'] * df['daily_return'].shift(-1)).rolling(window=60).mean() / df['sma_crossover'].rolling(window=60).std()\n    sharpe_ratios_volume_trend = (df['volume_trend'] * df['daily_return'].shift(-1)).rolling(window=60).mean() / df['volume_trend'].rolling(window=60).std()\n    \n    # Generate heuristic matrix\n    heuristics_matrix = (df['momentum'] * sharpe_ratios_momentum +\n                         df['sma_crossover'] * sharpe_ratios_sma_crossover +\n                         df['volume_trend'] * sharpe_ratios_volume_trend)\n    \n    return heuristics_matrix",
          "objective": -0.05017,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a weighted sum of momentum, simple moving average crossovers, and volume trends, with weights based on their historical information ratios instead of Sharpe ratios.}\n\n```python\ndef heuristics_v2(df):\n    # Compute daily return\n    df['daily_return'] = df['close'].pct_change()\n    \n    # Compute simple moving averages for close price\n    df['sma_10'] = df['close'].rolling(window=10).mean()\n    df['sma_30'] = df['close'].rolling(window=30).mean()\n    \n    # Calculate momentum\n    df['momentum'] = df['close'] - df['close'].shift(5)\n    \n    # Calculate SMA crossover\n    df['sma_crossover'] = df['sma_10'] - df['sma_30']\n    \n    # Volume trend\n    df['volume_trend'] = df['volume'].rolling(window=10).mean() / df['volume'].rolling(window=30).mean()\n    \n    # Historical Information ratios\n    info_ratios = {'momentum': (df['momentum'] * df['daily_return'].shift(-1)).mean() / (df['momentum'] * df['daily_return']).std(),\n                   'sma_crossover': (df['sma_crossover'] * df['daily_return'].shift(-1)).mean() / (df['sma_crossover'] * df['daily_return']).std(),\n                   'volume_trend': (df['volume_trend'] * df['daily_return'].shift(-1)).mean() / (df['volume_trend'] * df['daily_return']).std()",
          "code": "def heuristics_v2(df):\n    # Compute daily return\n    df['daily_return'] = df['close'].pct_change()\n    \n    # Compute simple moving averages for close price\n    df['sma_10'] = df['close'].rolling(window=10).mean()\n    df['sma_30'] = df['close'].rolling(window=30).mean()\n    \n    # Calculate momentum\n    df['momentum'] = df['close'] - df['close'].shift(5)\n    \n    # Calculate SMA crossover\n    df['sma_crossover'] = df['sma_10'] - df['sma_30']\n    \n    # Volume trend\n    df['volume_trend'] = df['volume'].rolling(window=10).mean() / df['volume'].rolling(window=30).mean()\n    \n    # Historical Information ratios\n    info_ratios = {'momentum': (df['momentum'] * df['daily_return'].shift(-1)).mean() / (df['momentum'] * df['daily_return']).std(),\n                   'sma_crossover': (df['sma_crossover'] * df['daily_return'].shift(-1)).mean() / (df['sma_crossover'] * df['daily_return']).std(),\n                   'volume_trend': (df['volume_trend'] * df['daily_return'].shift(-1)).mean() / (df['volume_trend'] * df['daily_return']).std()}\n    \n    # Generate heuristic matrix\n    heuristics_matrix = (df['momentum'] * info_ratios['momentum'] +\n                         df['sma_crossover'] * info_ratios['sma_crossover'] +\n                         df['volume_trend'] * info_ratios['volume_trend'])\n    \n    return heuristics_matrix",
          "objective": -0.0421,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a weighted combination of technical indicators and volume trends, where the weights are dynamically adjusted based on the rolling correlation of each indicator with future returns over a specified lookback period.}\n\n```python\nimport pandas as pd\n\ndef heuristics_v2(df):\n    # Compute daily return\n    df['daily_return'] = df['close'].pct_change()\n    \n    # Compute simple moving averages for close price\n    df['sma_10'] = df['close'].rolling(window=10).mean()\n    df['sma_30'] = df['close'].rolling(window=30).mean()\n    \n    # Calculate momentum\n    df['momentum'] = df['close'] - df['close'].shift(5)\n    \n    # Calculate price relative to SMA\n    df['price_to_sma_10'] = df['close'] / df['sma_10']\n    df['price_to_sma_30'] = df['close'] / df['sma_30']\n    \n    # Volume trend\n    df['volume_trend'] = df['volume'].rolling(window=10).mean() / df['volume'].rolling(window=30).mean()\n    \n    # Rolling historical return correlations with a lookback window of 60 days\n    corr_with_returns = {\n        'momentum': df['momentum'].rolling(window=60).corr(df['daily_return'].shift(-1)),\n        'price_to_sma_10': df['price_to_sma_10'].rolling(window=60).corr(df['daily_return'].shift(-1)),\n        'price_to_sma_30': df['price_to_sma_30'].rolling(window=60).corr(df['daily_return'].shift(-1)),\n        'volume_trend': df['volume_trend'].rolling(window=60).corr(df['daily_return'].shift(-1))\n    ",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Compute daily return\n    df['daily_return'] = df['close'].pct_change()\n    \n    # Compute simple moving averages for close price\n    df['sma_10'] = df['close'].rolling(window=10).mean()\n    df['sma_30'] = df['close'].rolling(window=30).mean()\n    \n    # Calculate momentum\n    df['momentum'] = df['close'] - df['close'].shift(5)\n    \n    # Calculate price relative to SMA\n    df['price_to_sma_10'] = df['close'] / df['sma_10']\n    df['price_to_sma_30'] = df['close'] / df['sma_30']\n    \n    # Volume trend\n    df['volume_trend'] = df['volume'].rolling(window=10).mean() / df['volume'].rolling(window=30).mean()\n    \n    # Rolling historical return correlations with a lookback window of 60 days\n    corr_with_returns = {\n        'momentum': df['momentum'].rolling(window=60).corr(df['daily_return'].shift(-1)),\n        'price_to_sma_10': df['price_to_sma_10'].rolling(window=60).corr(df['daily_return'].shift(-1)),\n        'price_to_sma_30': df['price_to_sma_30'].rolling(window=60).corr(df['daily_return'].shift(-1)),\n        'volume_trend': df['volume_trend'].rolling(window=60).corr(df['daily_return'].shift(-1))\n    }\n    \n    # Generate heuristic matrix using rolling correlations\n    heuristics_matrix = (df['momentum'] * corr_with_returns['momentum'] +\n                         df['price_to_sma_10'] * corr_with_returns['price_to_sma_10'] +\n                         df['price_to_sma_30'] * corr_with_returns['price_to_sma_30'] +\n                         df['volume_trend'] * corr_with_returns['volume_trend'])\n    \n    return heuristics_matrix",
          "objective": -0.03572,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a weighted combination of technical indicators, including momentum, price-to-SMA ratios, and volume trends, with weights based on their historical correlation to future returns, but uses 50-day and 100-day simple moving averages instead, and adds a new volatility factor.}\n\n```python\nimport pandas as pd\n\ndef heuristics_v2(df):\n    # Compute daily return\n    df['daily_return'] = df['close'].pct_change()\n    \n    # Compute simple moving averages for close price\n    df['sma_50'] = df['close'].rolling(window=50).mean()\n    df['sma_100'] = df['close'].rolling(window=100).mean()\n    \n    # Calculate momentum\n    df['momentum'] = df['close'] - df['close'].shift(10)\n    \n    # Calculate price relative to SMA\n    df['price_to_sma_50'] = df['close'] / df['sma_50']\n    df['price_to_sma_100'] = df['close'] / df['sma_100']\n    \n    # Volume trend\n    df['volume_trend'] = df['volume'].rolling(window=50).mean() / df['volume'].rolling(window=100).mean()\n    \n    # Volatility\n    df['volatility'] = df['close'].rolling(window=50).std()\n    \n    # Historical return correlations\n    corr_with_returns = {'momentum': df['momentum'].corr(df['daily_return'].shift(-1)), \n                         'price_to_sma_50': df['price_to_sma_50'].corr(df['daily_return'].shift(-1)),\n                         'price_to_sma_100': df['price_to_sma_100'].corr(df['daily_return'].shift(-1)),\n                         'volume_trend': df['volume_trend'].corr(df['daily_return'].shift(-1)),\n                         'volatility': df['volatility'].corr(df['daily_return'].shift(-1))",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Compute daily return\n    df['daily_return'] = df['close'].pct_change()\n    \n    # Compute simple moving averages for close price\n    df['sma_50'] = df['close'].rolling(window=50).mean()\n    df['sma_100'] = df['close'].rolling(window=100).mean()\n    \n    # Calculate momentum\n    df['momentum'] = df['close'] - df['close'].shift(10)\n    \n    # Calculate price relative to SMA\n    df['price_to_sma_50'] = df['close'] / df['sma_50']\n    df['price_to_sma_100'] = df['close'] / df['sma_100']\n    \n    # Volume trend\n    df['volume_trend'] = df['volume'].rolling(window=50).mean() / df['volume'].rolling(window=100).mean()\n    \n    # Volatility\n    df['volatility'] = df['close'].rolling(window=50).std()\n    \n    # Historical return correlations\n    corr_with_returns = {'momentum': df['momentum'].corr(df['daily_return'].shift(-1)), \n                         'price_to_sma_50': df['price_to_sma_50'].corr(df['daily_return'].shift(-1)),\n                         'price_to_sma_100': df['price_to_sma_100'].corr(df['daily_return'].shift(-1)),\n                         'volume_trend': df['volume_trend'].corr(df['daily_return'].shift(-1)),\n                         'volatility': df['volatility'].corr(df['daily_return'].shift(-1))}\n    \n    # Generate heuristic matrix\n    heuristics_matrix = (df['momentum'] * corr_with_returns['momentum'] +\n                         df['price_to_sma_50'] * corr_with_returns['price_to_sma_50'] +\n                         df['price_to_sma_100'] * corr_with_returns['price_to_sma_100'] +\n                         df['volume_trend'] * corr_with_returns['volume_trend'] +\n                         df['volatility'] * corr_with_returns['volatility'])\n    \n    return heuristics_matrix",
          "objective": -0.03198,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a weighted combination of technical indicators and volume trends to generate alpha factors, where the weights are determined by the historical correlation of each indicator with future returns.}\n\n```python\nimport pandas as pd\n\ndef heuristics_v2(df):\n    # Compute daily return\n    df['daily_return'] = df['close'].pct_change()\n    \n    # Compute simple moving averages for close price\n    df['sma_10'] = df['close'].rolling(window=10).mean()\n    df['sma_30'] = df['close'].rolling(window=30).mean()\n    \n    # Calculate momentum\n    df['momentum'] = df['close'] - df['close'].shift(5)\n    \n    # Calculate price relative to SMA\n    df['price_to_sma_10'] = df['close'] / df['sma_10']\n    df['price_to_sma_30'] = df['close'] / df['sma_30']\n    \n    # Volume trend\n    df['volume_trend'] = df['volume'].rolling(window=10).mean() / df['volume'].rolling(window=30).mean()\n    \n    # Historical return correlations\n    corr_with_returns = {'momentum': df['momentum'].corr(df['daily_return'].shift(-1)), \n                         'price_to_sma_10': df['price_to_sma_10'].corr(df['daily_return'].shift(-1)),\n                         'price_to_sma_30': df['price_to_sma_30'].corr(df['daily_return'].shift(-1)),\n                         'volume_trend': df['volume_trend'].corr(df['daily_return'].shift(-1))",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Compute daily return\n    df['daily_return'] = df['close'].pct_change()\n    \n    # Compute simple moving averages for close price\n    df['sma_10'] = df['close'].rolling(window=10).mean()\n    df['sma_30'] = df['close'].rolling(window=30).mean()\n    \n    # Calculate momentum\n    df['momentum'] = df['close'] - df['close'].shift(5)\n    \n    # Calculate price relative to SMA\n    df['price_to_sma_10'] = df['close'] / df['sma_10']\n    df['price_to_sma_30'] = df['close'] / df['sma_30']\n    \n    # Volume trend\n    df['volume_trend'] = df['volume'].rolling(window=10).mean() / df['volume'].rolling(window=30).mean()\n    \n    # Historical return correlations\n    corr_with_returns = {'momentum': df['momentum'].corr(df['daily_return'].shift(-1)), \n                         'price_to_sma_10': df['price_to_sma_10'].corr(df['daily_return'].shift(-1)),\n                         'price_to_sma_30': df['price_to_sma_30'].corr(df['daily_return'].shift(-1)),\n                         'volume_trend': df['volume_trend'].corr(df['daily_return'].shift(-1))}\n    \n    # Generate heuristic matrix\n    heuristics_matrix = (df['momentum'] * corr_with_returns['momentum'] +\n                         df['price_to_sma_10'] * corr_with_returns['price_to_sma_10'] +\n                         df['price_to_sma_30'] * corr_with_returns['price_to_sma_30'] +\n                         df['volume_trend'] * corr_with_returns['volume_trend'])\n    \n    return heuristics_matrix",
          "objective": -0.03068,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the sum of the absolute differences between the high and low prices to the average of the opening and closing prices, then applies a 10-day moving average to this ratio for a more stable signal.",
          "code": "def heuristics_v2(df):\n    # Compute the numerator (|High - Low|) and the denominator (Open + Close)/2\n    num = abs(df['high'] - df['low'])\n    denom = (df['open'] + df['close']) / 2\n    \n    # Calculate the base heuristic\n    base_heuristic = num / denom\n    \n    # Apply a 10-day moving average to smooth the series\n    heuristics_matrix = base_heuristic.rolling(window=10).mean()\n    \n    return heuristics_matrix",
          "objective": -0.02851,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted combination of technical indicators and volume trends, where weights are dynamically adjusted based on the rolling correlation with future returns over a 90-day lookback period.}\n\n```python\nimport pandas as pd\n\ndef heuristics_v2(df):\n    # Compute daily return\n    df['daily_return'] = df['close'].pct_change()\n    \n    # Compute simple moving averages for close price\n    df['sma_10'] = df['close'].rolling(window=10).mean()\n    df['sma_30'] = df['close'].rolling(window=30).mean()\n    \n    # Calculate momentum\n    df['momentum'] = df['close'] - df['close'].shift(5)\n    \n    # Calculate price relative to SMA\n    df['price_to_sma_10'] = df['close'] / df['sma_10']\n    df['price_to_sma_30'] = df['close'] / df['sma_30']\n    \n    # Volume trend\n    df['volume_trend'] = df['volume'].rolling(window=10).mean() / df['volume'].rolling(window=30).mean()\n    \n    # Rolling historical return correlations with a lookback window of 90 days\n    corr_with_returns = {\n        'momentum': df['momentum'].rolling(window=90).corr(df['daily_return'].shift(-1)),\n        'price_to_sma_10': df['price_to_sma_10'].rolling(window=90).corr(df['daily_return'].shift(-1)),\n        'price_to_sma_30': df['price_to_sma_30'].rolling(window=90).corr(df['daily_return'].shift(-1)),\n        'volume_trend': df['volume_trend'].rolling(window=90).corr(df['daily_return'].shift(-1))\n    ",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Compute daily return\n    df['daily_return'] = df['close'].pct_change()\n    \n    # Compute simple moving averages for close price\n    df['sma_10'] = df['close'].rolling(window=10).mean()\n    df['sma_30'] = df['close'].rolling(window=30).mean()\n    \n    # Calculate momentum\n    df['momentum'] = df['close'] - df['close'].shift(5)\n    \n    # Calculate price relative to SMA\n    df['price_to_sma_10'] = df['close'] / df['sma_10']\n    df['price_to_sma_30'] = df['close'] / df['sma_30']\n    \n    # Volume trend\n    df['volume_trend'] = df['volume'].rolling(window=10).mean() / df['volume'].rolling(window=30).mean()\n    \n    # Rolling historical return correlations with a lookback window of 90 days\n    corr_with_returns = {\n        'momentum': df['momentum'].rolling(window=90).corr(df['daily_return'].shift(-1)),\n        'price_to_sma_10': df['price_to_sma_10'].rolling(window=90).corr(df['daily_return'].shift(-1)),\n        'price_to_sma_30': df['price_to_sma_30'].rolling(window=90).corr(df['daily_return'].shift(-1)),\n        'volume_trend': df['volume_trend'].rolling(window=90).corr(df['daily_return'].shift(-1))\n    }\n    \n    # Generate heuristic matrix using rolling correlations\n    heuristics_matrix = (df['momentum'] * corr_with_returns['momentum'] +\n                         df['price_to_sma_10'] * corr_with_returns['price_to_sma_10'] +\n                         df['price_to_sma_30'] * corr_with_returns['price_to_sma_30'] +\n                         df['volume_trend'] * corr_with_returns['volume_trend'])\n    \n    return heuristics_matrix",
          "objective": -0.02794,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a weighted combination of technical indicators, including 20-day momentum, 20- and 100-day price-to-SMA ratios, 20- and 50-day volume trends, and 20-day volatility, with weights based on their historical correlation to future returns.}\n\n```python\nimport pandas as pd\n\ndef heuristics_v2(df):\n    # Compute daily return\n    df['daily_return'] = df['close'].pct_change()\n    \n    # Compute simple moving averages for close price\n    df['sma_20'] = df['close'].rolling(window=20).mean()\n    df['sma_100'] = df['close'].rolling(window=100).mean()\n    \n    # Calculate momentum\n    df['momentum'] = df['close'] - df['close'].shift(20)\n    \n    # Calculate price relative to SMA\n    df['price_to_sma_20'] = df['close'] / df['sma_20']\n    df['price_to_sma_100'] = df['close'] / df['sma_100']\n    \n    # Volume trend\n    df['volume_trend_20'] = df['volume'].rolling(window=20).mean() / df['volume'].rolling(window=50).mean()\n    df['volume_trend_50'] = df['volume'].rolling(window=50).mean() / df['volume'].rolling(window=100).mean()\n    \n    # Volatility\n    df['volatility'] = df['close'].rolling(window=20).std()\n    \n    # Historical return correlations\n    corr_with_returns = {'momentum': df['momentum'].corr(df['daily_return'].shift(-1)), \n                         'price_to_sma_20': df['price_to_sma_20'].corr(df['daily_return'].shift(-1)),\n                         'price_to_sma_100': df['price_to_sma_100'].corr(df['daily_return'].shift(-1)),\n                         'volume_trend_20': df['volume_trend_20'].corr(df['daily_return'].shift(-1)),\n                         'volume_trend_50': df['volume_trend_50'].corr(df['daily_return'].shift(-1)),\n                         'volatility': df['volatility'].corr(df['daily_return'].shift(-1))",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Compute daily return\n    df['daily_return'] = df['close'].pct_change()\n    \n    # Compute simple moving averages for close price\n    df['sma_20'] = df['close'].rolling(window=20).mean()\n    df['sma_100'] = df['close'].rolling(window=100).mean()\n    \n    # Calculate momentum\n    df['momentum'] = df['close'] - df['close'].shift(20)\n    \n    # Calculate price relative to SMA\n    df['price_to_sma_20'] = df['close'] / df['sma_20']\n    df['price_to_sma_100'] = df['close'] / df['sma_100']\n    \n    # Volume trend\n    df['volume_trend_20'] = df['volume'].rolling(window=20).mean() / df['volume'].rolling(window=50).mean()\n    df['volume_trend_50'] = df['volume'].rolling(window=50).mean() / df['volume'].rolling(window=100).mean()\n    \n    # Volatility\n    df['volatility'] = df['close'].rolling(window=20).std()\n    \n    # Historical return correlations\n    corr_with_returns = {'momentum': df['momentum'].corr(df['daily_return'].shift(-1)), \n                         'price_to_sma_20': df['price_to_sma_20'].corr(df['daily_return'].shift(-1)),\n                         'price_to_sma_100': df['price_to_sma_100'].corr(df['daily_return'].shift(-1)),\n                         'volume_trend_20': df['volume_trend_20'].corr(df['daily_return'].shift(-1)),\n                         'volume_trend_50': df['volume_trend_50'].corr(df['daily_return'].shift(-1)),\n                         'volatility': df['volatility'].corr(df['daily_return'].shift(-1))}\n    \n    # Generate heuristic matrix\n    heuristics_matrix = (df['momentum'] * corr_with_returns['momentum'] +\n                         df['price_to_sma_20'] * corr_with_returns['price_to_sma_20'] +\n                         df['price_to_sma_100'] * corr_with_returns['price_to_sma_100'] +\n                         df['volume_trend_20'] * corr_with_returns['volume_trend_20'] +\n                         df['volume_trend_50'] * corr_with_returns['volume_trend_50'] +\n                         df['volatility'] * corr_with_returns['volatility'])\n    \n    return heuristics_matrix",
          "objective": -0.0279,
          "other_inf": null
     }
]