[
     {
          "algorithm": "The algorithm computes a weighted combination of technical indicators and volume trends to generate alpha factors, where the weights are determined by the historical correlation of each indicator with future returns.}\n\n```python\nimport pandas as pd\n\ndef heuristics_v2(df):\n    # Compute daily return\n    df['daily_return'] = df['close'].pct_change()\n    \n    # Compute simple moving averages for close price\n    df['sma_10'] = df['close'].rolling(window=10).mean()\n    df['sma_30'] = df['close'].rolling(window=30).mean()\n    \n    # Calculate momentum\n    df['momentum'] = df['close'] - df['close'].shift(5)\n    \n    # Calculate price relative to SMA\n    df['price_to_sma_10'] = df['close'] / df['sma_10']\n    df['price_to_sma_30'] = df['close'] / df['sma_30']\n    \n    # Volume trend\n    df['volume_trend'] = df['volume'].rolling(window=10).mean() / df['volume'].rolling(window=30).mean()\n    \n    # Historical return correlations\n    corr_with_returns = {'momentum': df['momentum'].corr(df['daily_return'].shift(-1)), \n                         'price_to_sma_10': df['price_to_sma_10'].corr(df['daily_return'].shift(-1)),\n                         'price_to_sma_30': df['price_to_sma_30'].corr(df['daily_return'].shift(-1)),\n                         'volume_trend': df['volume_trend'].corr(df['daily_return'].shift(-1))",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Compute daily return\n    df['daily_return'] = df['close'].pct_change()\n    \n    # Compute simple moving averages for close price\n    df['sma_10'] = df['close'].rolling(window=10).mean()\n    df['sma_30'] = df['close'].rolling(window=30).mean()\n    \n    # Calculate momentum\n    df['momentum'] = df['close'] - df['close'].shift(5)\n    \n    # Calculate price relative to SMA\n    df['price_to_sma_10'] = df['close'] / df['sma_10']\n    df['price_to_sma_30'] = df['close'] / df['sma_30']\n    \n    # Volume trend\n    df['volume_trend'] = df['volume'].rolling(window=10).mean() / df['volume'].rolling(window=30).mean()\n    \n    # Historical return correlations\n    corr_with_returns = {'momentum': df['momentum'].corr(df['daily_return'].shift(-1)), \n                         'price_to_sma_10': df['price_to_sma_10'].corr(df['daily_return'].shift(-1)),\n                         'price_to_sma_30': df['price_to_sma_30'].corr(df['daily_return'].shift(-1)),\n                         'volume_trend': df['volume_trend'].corr(df['daily_return'].shift(-1))}\n    \n    # Generate heuristic matrix\n    heuristics_matrix = (df['momentum'] * corr_with_returns['momentum'] +\n                         df['price_to_sma_10'] * corr_with_returns['price_to_sma_10'] +\n                         df['price_to_sma_30'] * corr_with_returns['price_to_sma_30'] +\n                         df['volume_trend'] * corr_with_returns['volume_trend'])\n    \n    return heuristics_matrix",
          "objective": -0.03068,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes the ratio of the difference between the high and low prices to the average of the open and close prices, aiming to capture volatility relative to price levels, and then applies a 3-day moving average on this ratio to smooth out short-term fluctuations.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Compute the numerator (High - Low) and the denominator (Open + Close)/2\n    num = df['high'] - df['low']\n    denom = (df['open'] + df['close']) / 2\n    \n    # Calculate the base heuristic\n    base_heuristic = num / denom\n    \n    # Apply a 3-day moving average to smooth the series\n    heuristics_matrix = base_heuristic.rolling(window=3).mean()\n    \n    return heuristics_matrix",
          "objective": -0.02005,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm constructs a novel alpha factor by calculating the moving average convergence divergence (MACD) of the closing prices, then combining it with the ratio of the current day's volume to the 30-day average volume, aiming to capture momentum and liquidity effects.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    short_window = 12\n    long_window = 26\n    signal_window = 9\n    df['EMA_short'] = df['close'].ewm(span=short_window, adjust=False).mean()\n    df['EMA_long'] = df['close'].ewm(span=long_window, adjust=False).mean()\n    df['MACD'] = df['EMA_short'] - df['EMA_long']\n    df['Signal_Line'] = df['MACD'].ewm(span=signal_window, adjust=False).mean()\n    df['Volume_Ratio'] = df['volume'] / df['volume'].rolling(window=30).mean()\n    heuristics_matrix = df['MACD'] + df['Signal_Line'] * df['Volume_Ratio']\n    return heuristics_matrix",
          "objective": -0.01486,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a novel alpha factor by combining moving average crossovers, momentum indicators, and trading volume patterns to predict future stock returns.",
          "code": "def heuristics_v2(df):\n    def calc_moving_averages(data, short_window=50, long_window=200):\n        data['SMA_short'] = data['close'].rolling(window=short_window).mean()\n        data['SMA_long'] = data['close'].rolling(window=long_window).mean()\n        return data\n\n    def calc_momentum(data, window=14):\n        data['Momentum'] = (data['close'] - data['close'].shift(window)) / data['close'].shift(window)\n        return data\n\n    def calc_volume_trend(data, window=10):\n        data['Avg_Volume'] = data['volume'].rolling(window=window).mean()\n        data['Volume_Trend'] = (data['volume'] - data['Avg_Volume']) / data['Avg_Volume']\n        return data\n\n    df = calc_moving_averages(df.copy())\n    df = calc_momentum(df)\n    df = calc_volume_trend(df)\n\n    df['Alpha_Factor'] = (df['SMA_short'] - df['SMA_long']) + df['Momentum'] + df['Volume_Trend']\n    heuristics_matrix = df['Alpha_Factor']\n\n    return heuristics_matrix",
          "objective": -0.01444,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies patterns in historical market data by first calculating the momentum and volatility, then combining these with a weighted moving average of trading volume to produce a heuristics matrix that aims to predict future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily return\n    df['Daily_Return'] = df['close'].pct_change()\n    \n    # Calculate momentum (e.g., 10-day momentum)\n    df['Momentum'] = df['close'].pct_change(10)\n    \n    # Calculate volatility (standard deviation of daily returns over the last 10 days)\n    df['Volatility'] = df['Daily_Return'].rolling(window=10).std()\n    \n    # Calculate weighted moving average of volume\n    df['WMA_Volume'] = df['volume'].ewm(span=10, adjust=False).mean()\n    \n    # Combine the factors into a heuristic score\n    df['Heuristic_Score'] = df['Momentum'] * df['WMA_Volume'] / df['Volatility']\n    \n    # Drop rows with NaN values resulted from calculations\n    df.dropna(inplace=True)\n    \n    # Extract the heuristics score as a series\n    heuristics_matrix = df['Heuristic_Score']\n    \n    return heuristics_matrix",
          "objective": -0.0127,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a weighted combination of moving averages and price momentum to generate a heuristic factor, where the weights are determined by the historical performance of each individual component.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate short-term and long-term moving averages\n    ma_short = df['close'].rolling(window=10).mean()\n    ma_long = df['close'].rolling(window=50).mean()\n    \n    # Price momentum over a 20-day period\n    momentum = df['close'] / df['close'].shift(20) - 1\n    \n    # Historical performance of each component (simplified as their mean)\n    perf_ma_short = ma_short.mean()\n    perf_ma_long = ma_long.mean()\n    perf_momentum = momentum.mean()\n    \n    # Total performance for weight calculation\n    total_perf = perf_ma_short + perf_ma_long + perf_momentum\n    \n    # Weights based on historical performance\n    weight_ma_short = perf_ma_short / total_perf\n    weight_ma_long = perf_ma_long / total_perf\n    weight_momentum = perf_momentum / total_perf\n    \n    # Compute the heuristics matrix\n    heuristics_matrix = (weight_ma_short * ma_short + \n                         weight_ma_long * ma_long + \n                         weight_momentum * momentum)\n    \n    return heuristics_matrix",
          "objective": -0.01163,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm involves extracting momentum, volatility, and liquidity indicators from the input DataFrame to generate a composite alpha factor matrix that aims to predict stock returns.",
          "code": "def heuristics_v2(df):\n    # Momentum Factor: Calculate the 10-day return\n    mom_factor = df['close'].pct_change(10)\n    \n    # Volatility Factor: Calculate the 20-day standard deviation of daily returns\n    vol_factor = df['close'].pct_change().rolling(window=20).std()\n    \n    # Liquidity Factor: Volume-to-price ratio as a proxy for liquidity\n    liq_factor = df['volume'] / df['close']\n    \n    # Composite Heuristic Matrix by combining all factors\n    heuristics_matrix = (mom_factor + vol_factor + liq_factor) / 3\n    \n    return heuristics_matrix",
          "objective": -0.00912,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a set of heuristic alphas by combining moving averages, volatility measures, and volume trends to create an interpretable matrix that predicts future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    heuristics_matrix = pd.Series(index=df.index)\n    \n    # Simple moving averages\n    sma_5 = df['close'].rolling(window=5).mean()\n    sma_20 = df['close'].rolling(window=20).mean()\n    \n    # Exponential moving average\n    ema_10 = df['close'].ewm(span=10, adjust=False).mean()\n    \n    # Volatility (standard deviation of daily returns over the last 20 days)\n    volatility = df['close'].pct_change().rolling(window=20).std()\n    \n    # Volume trend\n    volume_trend = df['volume'].rolling(window=5).mean() / df['volume'].rolling(window=20).mean()\n    \n    # Combine features into a single heuristic\n    heuristics_matrix = (sma_5 - sma_20) + (ema_10 - df['close']) + (volatility * 100) + (volume_trend - 1)\n    \n    return heuristics_matrix",
          "objective": -0.0087,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a weighted combination of market features, using volume as the weight, to generate a novel alpha factor.",
          "code": "def heuristics_v2(df):\n    heuristics_matrix = (df['open'] + df['high'] + df['low'] + df['close']) * df['volume']\n    return heuristics_matrix",
          "objective": -0.00721,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies patterns in the relationship between the trading volume and closing price changes over time, leveraging a custom weighted moving average of volume and price difference, to generate alpha factors as potential indicators for future stock returns.",
          "code": "def heuristics_v2(df):\n    heuristics_matrix = (df['volume'] * (df['close'].diff().fillna(0))).rolling(window=14).mean()\n    return heuristics_matrix",
          "objective": -0.00593,
          "other_inf": null
     }
]