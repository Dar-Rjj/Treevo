[
     {
          "algorithm": "The new algorithm calculates the ratio of consecutive days' closing prices to their corresponding opening prices and multiplies it by the natural logarithm of the trading volume, aiming to capture the relationship between price movements and trading activity.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the ratio of consecutive days' closing prices to their opening prices\n    close_open_ratio = (df['close'] / df['open']).pct_change().shift(-1)\n    # Apply natural logarithm to the volume\n    log_volume = np.log(df['volume'])\n    # Generate the heuristics matrix as the product of the close-open ratio and the log of volume\n    heuristics_matrix = close_open_ratio * log_volume\n    return heuristics_matrix",
          "objective": -0.23603,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the weighted difference between consecutive days' closing and opening prices, using the square root of trading volume as the weight, aiming to incorporate both price change and trading activity into a single factor.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the difference between consecutive days' closing and opening prices\n    close_open_diff = (df['close'] - df['open']).shift(-1)\n    # Use the square root of volume as the weight\n    sqrt_volume = np.sqrt(df['volume'])\n    # Generate the heuristics matrix as the product of the close-open difference and the square root of volume\n    heuristics_matrix = close_open_diff * sqrt_volume\n    return heuristics_matrix",
          "objective": -0.20394,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of consecutive days' closing prices to the difference between high and low prices, then multiplies it by the square root of the 5-day standard deviation of volume, aiming to create a more volatility-sensitive alpha factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the ratio of consecutive days' closing prices\n    close_ratio = df['close'].pct_change().shift(-1)\n    # Calculate the difference between high and low prices\n    hl_diff = df['high'] - df['low']\n    # Calculate the 5-day standard deviation of volume\n    vol_std = df['volume'].rolling(window=5).std()\n    # Generate the heuristics matrix as the product of the close ratio divided by the HL difference and the square root of volume standard deviation\n    heuristics_matrix = (close_ratio / hl_diff) * vol_std.pow(0.5)\n    return heuristics_matrix",
          "objective": -0.20131,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of consecutive days' closing prices to their low prices and multiplies it by the square root of the trading volume, aiming to highlight extreme price movements in relation to trading activity.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the ratio of consecutive days' closing prices to their low prices\n    close_low_ratio = (df['close'] / df['low']).pct_change().shift(-1)\n    # Apply square root to the volume\n    sqrt_volume = np.sqrt(df['volume'])\n    # Generate the heuristics matrix as the product of the close-low ratio and the square root of volume\n    heuristics_matrix = close_low_ratio * sqrt_volume\n    return heuristics_matrix",
          "objective": -0.12652,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies patterns in the ratio of consecutive day's closing prices to the average of their trading volumes, aiming to generate a heuristics-based alpha factor by mapping these ratios through a series of non-linear transformations.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the ratio of consecutive days' closing prices\n    close_ratio = df['close'].pct_change().shift(-1)\n    # Calculate the rolling mean of volume over a 5-day window\n    volume_mean = df['volume'].rolling(window=5).mean()\n    # Apply a non-linear transformation to the close ratio and volume mean\n    transformed_close_ratio = (close_ratio - close_ratio.min()) / (close_ratio.max() - close_ratio.min())\n    transformed_volume_mean = (volume_mean - volume_mean.min()) / (volume_mean.max() - volume_mean.min())\n    # Generate the heuristics matrix as the product of the two transformed values\n    heuristics_matrix = transformed_close_ratio * transformed_volume_mean\n    return heuristics_matrix",
          "objective": -0.08257,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the difference between high and low prices to the trading volume, applying non-linear transformations, and then generates a heuristics-based alpha factor as the sum of these transformed values.",
          "code": "def heuristics_v2(df):\n    # Calculate the ratio of the difference between high and low prices to the trading volume\n    price_diff_to_volume = (df['high'] - df['low']) / df['volume']\n    # Apply a non-linear transformation to the price difference to volume ratio\n    transformed_price_diff_to_volume = (price_diff_to_volume - price_diff_to_volume.min()) / (price_diff_to_volume.max() - price_diff_to_volume.min())\n    # Generate the heuristics matrix as the sum of the transformed value with itself to emphasize the signal\n    heuristics_matrix = transformed_price_diff_to_volume + transformed_price_diff_to_volume\n    return heuristics_matrix",
          "objective": -0.04888,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a novel alpha factor by computing the ratio of the 30-day exponential moving average (EMA) of the logarithm of the high prices to the 30-day weighted moving average (WMA) of the logarithm of the close prices, using a linearly decreasing weight scheme, aiming to detect shifts in market dynamics.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the natural logarithm of the close and high prices\n    df['log_close'] = np.log(df['close'])\n    df['log_high'] = np.log(df['high'])\n\n    # Calculate the 30-day Exponential Moving Average (EMA) for log_high\n    df['EMA_30_log_high'] = df['log_high'].ewm(span=30, adjust=False).mean()\n\n    # Define weights for Weighted Moving Average (WMA) with a linearly decreasing weight scheme\n    lin_weights = np.linspace(30, 1, 30)\n    lin_weights /= lin_weights.sum()\n\n    # Calculate the 30-day Weighted Moving Average (WMA) for log_close\n    df['WMA_30_log_close'] = df['log_close'].rolling(window=30).apply(lambda x: (x * lin_weights[::-1]).sum(), raw=True)\n\n    # Create the heuristic: ratio of EMA_30_log_high to WMA_30_log_close\n    heuristics_matrix = df['EMA_30_log_high'] / df['WMA_30_log_close']\n\n    return heuristics_matrix",
          "objective": -0.03634,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of consecutive days' closing prices to the 2-day moving average of the volume, then multiplies it by the cube of the 10-day standard deviation of the difference between high and low prices.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the ratio of consecutive days' closing prices\n    close_ratio = df['close'].pct_change().shift(-1)\n    # Calculate the 2-day moving average of the volume\n    vol_ma_2 = df['volume'].rolling(window=2).mean()\n    # Calculate the 10-day standard deviation of the HL difference\n    hl_diff_std = (df['high'] - df['low']).rolling(window=10).std()\n    # Generate the heuristics matrix\n    heuristics_matrix = (close_ratio / vol_ma_2) * hl_diff_std.pow(3)\n    return heuristics_matrix",
          "objective": -0.03282,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a novel alpha factor by computing the ratio of the 20-day exponential moving average (EMA) of the logarithm of the close prices to the 20-day weighted moving average (WMA) of the logarithm of the low prices, using an exponentially decreasing weight scheme.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the natural logarithm of the close and low prices\n    df['log_close'] = np.log(df['close'])\n    df['log_low'] = np.log(df['low'])\n\n    # Calculate the 20-day Exponential Moving Average (EMA) for log_close\n    df['EMA_20_log_close'] = df['log_close'].ewm(span=20, adjust=False).mean()\n\n    # Define weights for Weighted Moving Average (WMA) with an exponentially decreasing weight scheme\n    exp_weights = np.exp(-np.linspace(0, 1, 20))\n    exp_weights /= exp_weights.sum()\n\n    # Calculate the 20-day Weighted Moving Average (WMA) for log_low\n    df['WMA_20_log_low'] = df['log_low'].rolling(window=20).apply(lambda x: (x * exp_weights[::-1]).sum(), raw=True)\n\n    # Create the heuristic: ratio of EMA_20_log_close to WMA_20_log_low\n    heuristics_matrix = df['EMA_20_log_close'] / df['WMA_20_log_low']\n\n    return heuristics_matrix",
          "objective": -0.03214,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a novel alpha factor by computing the difference between the 20-day simple moving average (SMA) of the logarithm of the low prices and the 50-day simple moving average (SMA) of the logarithm of the close prices, to capture the potential shifts in long-term trends.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the natural logarithm of the close and low prices\n    df['log_close'] = np.log(df['close'])\n    df['log_low'] = np.log(df['low'])\n    \n    # Calculate the 20-day Simple Moving Average (SMA) for log_low\n    df['SMA_20_log_low'] = df['log_low'].rolling(window=20).mean()\n    \n    # Calculate the 50-day Simple Moving Average (SMA) for log_close\n    df['SMA_50_log_close'] = df['log_close'].rolling(window=50).mean()\n    \n    # Create the heuristic: difference between SMA_20_log_low and SMA_50_log_close\n    heuristics_matrix = df['SMA_20_log_low'] - df['SMA_50_log_close']\n    \n    return heuristics_matrix",
          "objective": -0.02628,
          "other_inf": null
     }
]