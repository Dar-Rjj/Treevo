[
     {
          "algorithm": "The algorithm identifies patterns in the ratio of consecutive day's closing prices to the average of their trading volumes, aiming to generate a heuristics-based alpha factor by mapping these ratios through a series of non-linear transformations.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the ratio of consecutive days' closing prices\n    close_ratio = df['close'].pct_change().shift(-1)\n    # Calculate the rolling mean of volume over a 5-day window\n    volume_mean = df['volume'].rolling(window=5).mean()\n    # Apply a non-linear transformation to the close ratio and volume mean\n    transformed_close_ratio = (close_ratio - close_ratio.min()) / (close_ratio.max() - close_ratio.min())\n    transformed_volume_mean = (volume_mean - volume_mean.min()) / (volume_mean.max() - volume_mean.min())\n    # Generate the heuristics matrix as the product of the two transformed values\n    heuristics_matrix = transformed_close_ratio * transformed_volume_mean\n    return heuristics_matrix",
          "objective": -0.08257,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a novel alpha factor by considering the weighted difference between the logarithm of the closing price and the average logarithm of the high and low prices over a 20-day period, aiming to capture the relative strength and potential reversal signals.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the natural logarithm of the close, high, and low prices\n    df['log_close'] = np.log(df['close'])\n    df['log_high'] = np.log(df['high'])\n    df['log_low'] = np.log(df['low'])\n    \n    # Calculate the average of the logarithms of the high and low prices over a 20-day window\n    df['avg_log_high_low'] = (df['log_high'] + df['log_low']) / 2\n    df['MA_20_avg_log_high_low'] = df['avg_log_high_low'].rolling(window=20).mean()\n    \n    # Create the heuristic: weighted difference between log_close and MA_20_avg_log_high_low\n    heuristics_matrix = df['log_close'] - 1.5 * df['MA_20_avg_log_high_low']\n    \n    return heuristics_matrix",
          "objective": -0.02294,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the factor by integrating the momentum of price changes, the volatility relative to the average volume, and the directional movement indicated by the difference between the highest and lowest prices over a set period.",
          "code": "def heuristics_v2(df):\n    # Momentum: 14-day change in closing price\n    momentum = df['close'] - df['close'].shift(14)\n    \n    # Volatility: 20-day standard deviation of closing price\n    vol = df['close'].rolling(window=20).std()\n    \n    # Volume ratio: current volume compared to its 30-day moving average\n    avg_vol_30d = df['volume'].rolling(window=30).mean()\n    vol_ratio = df['volume'] / avg_vol_30d\n    \n    # Directional movement: difference between 20-day high and low\n    high_20d = df['high'].rolling(window=20).max()\n    low_20d = df['low'].rolling(window=20).min()\n    dir_movement = (high_20d - low_20d) / df['close']\n    \n    # Composite heuristic\n    heuristics_matrix = (momentum + (vol * vol_ratio) + dir_movement) / 3\n    \n    return heuristics_matrix",
          "objective": -0.02005,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a novel alpha factor by incorporating the exponential moving average (EMA) of the logarithm of the closing price and subtracting it from the smoothed (using a simple moving average, SMA) version of the logarithm of the high prices over a 20-day period, aiming to capture momentum and potential trend reversals.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the natural logarithm of the close and high prices\n    df['log_close'] = np.log(df['close'])\n    df['log_high'] = np.log(df['high'])\n    \n    # Calculate the 20-day Exponential Moving Average (EMA) for log_close\n    df['EMA_20_log_close'] = df['log_close'].ewm(span=20, adjust=False).mean()\n    \n    # Calculate the 20-day Simple Moving Average (SMA) for log_high\n    df['SMA_20_log_high'] = df['log_high'].rolling(window=20).mean()\n    \n    # Create the heuristic: difference between SMA_20_log_high and EMA_20_log_close\n    heuristics_matrix = df['SMA_20_log_high'] - df['EMA_20_log_close']\n    \n    return heuristics_matrix",
          "objective": -0.01937,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the factor by taking the difference between the 20-day and 50-day simple moving averages of the closing price, then dividing this difference by the standard deviation of the closing prices over a 20-day window.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    sma_20 = df['close'].rolling(window=20).mean()\n    sma_50 = df['close'].rolling(window=50).mean()\n    diff_sma = sma_20 - sma_50\n    std_close = df['close'].rolling(window=20).std()\n    heuristics_matrix = diff_sma / std_close\n    return heuristics_matrix",
          "objective": -0.01778,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the factor by taking the difference between the 10-day and 30-day simple moving averages of the closing price, then dividing this difference by the standard deviation of the closing prices over a 10-day window.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    sma_10 = df['close'].rolling(window=10).mean()\n    sma_30 = df['close'].rolling(window=30).mean()\n    diff_sma = sma_10 - sma_30\n    std_close = df['close'].rolling(window=10).std()\n    heuristics_matrix = diff_sma / std_close\n    return heuristics_matrix",
          "objective": -0.01463,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a factor by integrating the directional movement index (DMI) with the Chaikin Money Flow (CMF) to predict future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def dmi(series, period=14):\n        high = df['high']\n        low = df['low']\n        up_move = high - high.shift(1)\n        down_move = low.shift(1) - low\n        plus_dm = pd.Series(0, index=up_move.index)\n        minus_dm = pd.Series(0, index=down_move.index)\n        plus_dm[(up_move > down_move) & (up_move > 0)] = up_move\n        minus_dm[(down_move > up_move) & (down_move > 0)] = down_move\n        tr = pd.concat([high - low, abs(high - df['close'].shift(1)), abs(low - df['close'].shift(1))], axis=1).max(axis=1)\n        tr_smooth = tr.rolling(window=period).sum()\n        plus_di = 100 * (plus_dm.rolling(window=period).sum() / tr_smooth)\n        minus_di = 100 * (minus_dm.rolling(window=period).sum() / tr_smooth)\n        return plus_di - minus_di\n\n    def cmf(series, period=20):\n        mfm = ((df['close'] - df['low']) - (df['high'] - df['close'])) / (df['high'] - df['low'])\n        mfv = mfm * df['volume']\n        cmf = mfv.rolling(window=period).sum() / df['volume'].rolling(window=period).sum()\n        return cmf\n\n    dmi_values = dmi(df['close'])\n    cmf_values = cmf(df['close'])\n\n    heuristics_matrix = (dmi_values + cmf_values) / 2\n    \n    return heuristics_matrix",
          "objective": -0.01457,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a heuristic factor by combining the relative strength index (RSI) with the exponential moving average (EMA) crossover signals, integrating volume as a weight, to predict future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def rsi(series, period=14):\n        delta = series.diff(1)\n        gain = delta.where(delta > 0, 0)\n        loss = -delta.where(delta < 0, 0)\n        avg_gain = gain.rolling(window=period).mean()\n        avg_loss = loss.rolling(window=period).mean()\n        rs = avg_gain / avg_loss\n        return 100 - (100 / (1 + rs))\n\n    ema_short = df['close'].ewm(span=12, adjust=False).mean()\n    ema_long = df['close'].ewm(span=26, adjust=False).mean()\n    macd = ema_short - ema_long\n    signal_line = macd.ewm(span=9, adjust=False).mean()\n\n    rsi_values = rsi(df['close'])\n    crossover_signal = (macd - signal_line) * df['volume']\n    \n    heuristics_matrix = (rsi_values + crossover_signal) / 2\n    \n    return heuristics_matrix",
          "objective": -0.01385,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm integrates the Relative Strength Index (RSI) with the Money Flow Index (MFI) to predict future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def rsi(series, period=14):\n        delta = series.diff(1)\n        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()\n        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()\n        rs = gain / loss\n        return 100 - (100 / (1 + rs))\n\n    def mfi(df, period=14):\n        typical_price = (df['high'] + df['low'] + df['close']) / 3\n        raw_money_flow = typical_price * df['volume']\n        positive_flow = raw_money_flow.where(typical_price > typical_price.shift(1), 0)\n        negative_flow = raw_money_flow.where(typical_price < typical_price.shift(1), 0)\n        money_ratio = positive_flow.rolling(window=period).sum() / negative_flow.rolling(window=period).sum()\n        mfi = 100 - (100 / (1 + money_ratio))\n        return mfi\n\n    rsi_values = rsi(df['close'])\n    mfi_values = mfi(df)\n\n    heuristics_matrix = (rsi_values + mfi_values) / 2\n    \n    return heuristics_matrix",
          "objective": -0.01351,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted average of the RSI and MFI, with RSI having a higher weight, to potentially give more emphasis on price momentum.",
          "code": "def heuristics_v2(df):\n    def rsi(series, period=14):\n        delta = series.diff(1)\n        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()\n        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()\n        rs = gain / loss\n        return 100 - (100 / (1 + rs))\n\n    def mfi(df, period=14):\n        typical_price = (df['high'] + df['low'] + df['close']) / 3\n        raw_money_flow = typical_price * df['volume']\n        positive_flow = raw_money_flow.where(typical_price > typical_price.shift(1), 0)\n        negative_flow = raw_money_flow.where(typical_price < typical_price.shift(1), 0)\n        money_ratio = positive_flow.rolling(window=period).sum() / negative_flow.rolling(window=period).sum()\n        mfi = 100 - (100 / (1 + money_ratio))\n        return mfi\n\n    rsi_values = rsi(df['close'])\n    mfi_values = mfi(df)\n\n    heuristics_matrix = (rsi_values * 0.7 + mfi_values * 0.3)\n    \n    return heuristics_matrix",
          "objective": -0.01325,
          "other_inf": null
     }
]