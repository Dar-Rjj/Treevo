[
     {
          "algorithm": "The algorithm identifies patterns in the ratio of consecutive day's closing prices to the average of their trading volumes, aiming to generate a heuristics-based alpha factor by mapping these ratios through a series of non-linear transformations.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the ratio of consecutive days' closing prices\n    close_ratio = df['close'].pct_change().shift(-1)\n    # Calculate the rolling mean of volume over a 5-day window\n    volume_mean = df['volume'].rolling(window=5).mean()\n    # Apply a non-linear transformation to the close ratio and volume mean\n    transformed_close_ratio = (close_ratio - close_ratio.min()) / (close_ratio.max() - close_ratio.min())\n    transformed_volume_mean = (volume_mean - volume_mean.min()) / (volume_mean.max() - volume_mean.min())\n    # Generate the heuristics matrix as the product of the two transformed values\n    heuristics_matrix = transformed_close_ratio * transformed_volume_mean\n    return heuristics_matrix",
          "objective": -0.08257,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a heuristic factor by combining the relative strength index (RSI) with the exponential moving average (EMA) crossover signals, integrating volume as a weight, to predict future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def rsi(series, period=14):\n        delta = series.diff(1)\n        gain = delta.where(delta > 0, 0)\n        loss = -delta.where(delta < 0, 0)\n        avg_gain = gain.rolling(window=period).mean()\n        avg_loss = loss.rolling(window=period).mean()\n        rs = avg_gain / avg_loss\n        return 100 - (100 / (1 + rs))\n\n    ema_short = df['close'].ewm(span=12, adjust=False).mean()\n    ema_long = df['close'].ewm(span=26, adjust=False).mean()\n    macd = ema_short - ema_long\n    signal_line = macd.ewm(span=9, adjust=False).mean()\n\n    rsi_values = rsi(df['close'])\n    crossover_signal = (macd - signal_line) * df['volume']\n    \n    heuristics_matrix = (rsi_values + crossover_signal) / 2\n    \n    return heuristics_matrix",
          "objective": -0.01385,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a composite factor by combining momentum, volatility, and liquidity aspects from the given market features to predict future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate simple return\n    df['simple_return'] = df['close'].pct_change()\n    # Momentum: 12-months simple moving average return\n    df['momentum'] = df['simple_return'].rolling(window=12).mean()\n    # Volatility: standard deviation of daily returns over the last 12 months\n    df['volatility'] = df['simple_return'].rolling(window=12).std()\n    # Liquidity: ratio of volume to the 12-months average volume\n    df['avg_volume_12m'] = df['volume'].rolling(window=12).mean()\n    df['liquidity'] = df['volume'] / df['avg_volume_12m']\n    # Composite heuristic, assuming equal weighting for simplicity\n    df['heuristic'] = (df['momentum'] + 1/df['volatility'] + df['liquidity']) / 3\n    heuristics_matrix = df['heuristic'].dropna()\n    \n    return heuristics_matrix",
          "objective": -0.01277,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a composite factor by combining the momentum of the closing price over a short period with the relative difference between the average trading volume of the recent days and the long-term average, aiming to capture both price trend and liquidity signals.",
          "code": "def heuristics_v2(df):\n    # Calculate the short-term momentum (e.g., 5-day) of the close price\n    short_momentum = df['close'].pct_change(5)\n    \n    # Calculate the average volume over a recent period (e.g., 10 days) and the long-term period (e.g., 60 days)\n    avg_vol_recent = df['volume'].rolling(window=10).mean()\n    avg_vol_long_term = df['volume'].rolling(window=60).mean()\n    \n    # Compute the relative difference in volume\n    vol_diff = (avg_vol_recent - avg_vol_long_term) / avg_vol_long_term\n    \n    # Generate the heuristics matrix as a combination of momentum and volume difference\n    heuristics_matrix = (short_momentum + vol_diff) / 2\n\n    return heuristics_matrix",
          "objective": -0.01133,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a novel alpha factor by integrating moving average crossovers, momentum signals, and volume trends, outputting a single series that aims to predict future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate short (50-day) and long (200-day) simple moving averages for the close price\n    df['SMA_50'] = df['close'].rolling(window=50).mean()\n    df['SMA_200'] = df['close'].rolling(window=200).mean()\n    \n    # Momentum signal: 1 if the current close is higher than the close 10 days ago, else 0\n    df['Momentum'] = (df['close'] > df['close'].shift(10)).astype(int)\n    \n    # Volume trend: Increase in volume compared to the previous day\n    df['Volume_Trend'] = (df['volume'] - df['volume'].shift(1)) / df['volume'].shift(1)\n    \n    # Alpha factor: Combine SMA crossover, momentum, and volume trend\n    df['Alpha_Factor'] = (df['SMA_50'] > df['SMA_200']).astype(int) + df['Momentum'] + df['Volume_Trend']\n    \n    # Return the alpha factor as a Series\n    heuristics_matrix = df['Alpha_Factor']\n    return heuristics_matrix",
          "objective": -0.00989,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm generates a heuristics matrix by calculating the ratio of volume to the difference between high and low prices for each date, aiming to capture volatility-adjusted volume as an indicator.",
          "code": "def heuristics_v2(df):\n    heuristics_matrix = df['volume'] / (df['high'] - df['low'])\n    return heuristics_matrix",
          "objective": -0.00743,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm constructs a novel alpha factor by calculating the ratio of the closing price to the average of the high and low prices over a 10-day window, then applying a smoothing technique with a 5-day exponential moving average on this ratio.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    close = df['close']\n    high_low_avg = (df['high'] + df['low']) / 2\n    ratio = close / high_low_avg.rolling(window=10).mean()\n    heuristics_matrix = ratio.ewm(span=5, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.0071,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a custom alpha factor by analyzing the relative strength of close prices versus the volume, aiming to identify potential momentum in stocks.",
          "code": "def heuristics_v2(df):\n    # Calculate the ratio of close price to average volume over a 10-day window\n    df['Close_Vol_Ratio'] = df['close'] / df['volume'].rolling(window=10).mean()\n    # Calculate the 5-day moving average of the Close_Vol_Ratio\n    df['MA_5_Close_Vol_Ratio'] = df['Close_Vol_Ratio'].rolling(window=5).mean()\n    # Create the heuristic: difference between the Close_Vol_Ratio and its 5-day MA\n    heuristics_matrix = df['Close_Vol_Ratio'] - df['MA_5_Close_Vol_Ratio']\n    return heuristics_matrix",
          "objective": -0.00384,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a proprietary combination of momentum, volatility, and trading volume over different lookback periods to generate an alpha factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    momentum = df['close'].pct_change(periods=20)\n    volatility = df['close'].pct_change().rolling(window=20).std()\n    volume_trend = df['volume'].pct_change(periods=20)\n    \n    heuristics_matrix = 0.5 * momentum + 0.3 * -volatility + 0.2 * volume_trend\n    return heuristics_matrix",
          "objective": -0.00328,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a novel alpha factor by calculating the exponential moving average (EMA) of the difference between daily high and low prices, then multiplying it by the logarithm of the volume changes, aiming to capture momentum influenced by trading activity.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    ema_diff = df['high'].ewm(span=10, adjust=False).mean() - df['low'].ewm(span=10, adjust=False).mean()\n    log_volume_change = np.log(df['volume'] / df['volume'].shift(1))\n    heuristics_matrix = ema_diff * log_volume_change\n    return heuristics_matrix",
          "objective": -0.00321,
          "other_inf": null
     }
]