[
     {
          "algorithm": "The new algorithm calculates the ratio of consecutive days' closing prices to their corresponding opening prices and multiplies it by the natural logarithm of the trading volume, aiming to capture the relationship between price movements and trading activity.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the ratio of consecutive days' closing prices to their opening prices\n    close_open_ratio = (df['close'] / df['open']).pct_change().shift(-1)\n    # Apply natural logarithm to the volume\n    log_volume = np.log(df['volume'])\n    # Generate the heuristics matrix as the product of the close-open ratio and the log of volume\n    heuristics_matrix = close_open_ratio * log_volume\n    return heuristics_matrix",
          "objective": -0.23603,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of consecutive days' closing prices to the difference between high and low prices, then multiplies it by the square root of the 5-day standard deviation of volume, aiming to create a more volatility-sensitive alpha factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the ratio of consecutive days' closing prices\n    close_ratio = df['close'].pct_change().shift(-1)\n    # Calculate the difference between high and low prices\n    hl_diff = df['high'] - df['low']\n    # Calculate the 5-day standard deviation of volume\n    vol_std = df['volume'].rolling(window=5).std()\n    # Generate the heuristics matrix as the product of the close ratio divided by the HL difference and the square root of volume standard deviation\n    heuristics_matrix = (close_ratio / hl_diff) * vol_std.pow(0.5)\n    return heuristics_matrix",
          "objective": -0.20131,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies patterns in the ratio of consecutive day's closing prices to the average of their trading volumes, aiming to generate a heuristics-based alpha factor by mapping these ratios through a series of non-linear transformations.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the ratio of consecutive days' closing prices\n    close_ratio = df['close'].pct_change().shift(-1)\n    # Calculate the rolling mean of volume over a 5-day window\n    volume_mean = df['volume'].rolling(window=5).mean()\n    # Apply a non-linear transformation to the close ratio and volume mean\n    transformed_close_ratio = (close_ratio - close_ratio.min()) / (close_ratio.max() - close_ratio.min())\n    transformed_volume_mean = (volume_mean - volume_mean.min()) / (volume_mean.max() - volume_mean.min())\n    # Generate the heuristics matrix as the product of the two transformed values\n    heuristics_matrix = transformed_close_ratio * transformed_volume_mean\n    return heuristics_matrix",
          "objective": -0.08257,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the difference between high and low prices to the trading volume, applying non-linear transformations, and then generates a heuristics-based alpha factor as the sum of these transformed values.",
          "code": "def heuristics_v2(df):\n    # Calculate the ratio of the difference between high and low prices to the trading volume\n    price_diff_to_volume = (df['high'] - df['low']) / df['volume']\n    # Apply a non-linear transformation to the price difference to volume ratio\n    transformed_price_diff_to_volume = (price_diff_to_volume - price_diff_to_volume.min()) / (price_diff_to_volume.max() - price_diff_to_volume.min())\n    # Generate the heuristics matrix as the sum of the transformed value with itself to emphasize the signal\n    heuristics_matrix = transformed_price_diff_to_volume + transformed_price_diff_to_volume\n    return heuristics_matrix",
          "objective": -0.04888,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a novel alpha factor by computing the difference between the 20-day simple moving average (SMA) of the logarithm of the low prices and the 50-day simple moving average (SMA) of the logarithm of the close prices, to capture the potential shifts in long-term trends.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the natural logarithm of the close and low prices\n    df['log_close'] = np.log(df['close'])\n    df['log_low'] = np.log(df['low'])\n    \n    # Calculate the 20-day Simple Moving Average (SMA) for log_low\n    df['SMA_20_log_low'] = df['log_low'].rolling(window=20).mean()\n    \n    # Calculate the 50-day Simple Moving Average (SMA) for log_close\n    df['SMA_50_log_close'] = df['log_close'].rolling(window=50).mean()\n    \n    # Create the heuristic: difference between SMA_20_log_low and SMA_50_log_close\n    heuristics_matrix = df['SMA_20_log_low'] - df['SMA_50_log_close']\n    \n    return heuristics_matrix",
          "objective": -0.02628,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a novel alpha factor by computing the difference between the 30-day exponential moving average (EMA) of the logarithm of the high prices and the 30-day weighted moving average (WMA) of the logarithm of the close prices, using an exponentially decreasing weight scheme, to enhance the detection of momentum and potential trend shifts.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the natural logarithm of the close and high prices\n    df['log_close'] = np.log(df['close'])\n    df['log_high'] = np.log(df['high'])\n    \n    # Calculate the 30-day Exponential Moving Average (EMA) for log_high\n    df['EMA_30_log_high'] = df['log_high'].ewm(span=30, adjust=False).mean()\n    \n    # Define weights for Weighted Moving Average (WMA) with an exponentially decreasing weight scheme\n    exp_weights = np.exp(np.linspace(1, -1, 30))\n    exp_weights /= exp_weights.sum()\n    \n    # Calculate the 30-day Weighted Moving Average (WMA) for log_close\n    df['WMA_30_log_close'] = df['log_close'].rolling(window=30).apply(lambda x: (x * exp_weights[::-1]).sum(), raw=True)\n    \n    # Create the heuristic: difference between EMA_30_log_high and WMA_30_log_close\n    heuristics_matrix = df['EMA_30_log_high'] - df['WMA_30_log_close']\n    \n    return heuristics_matrix",
          "objective": -0.02612,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a novel alpha factor by computing the difference between the 30-day simple moving average (SMA) of the logarithm of the high prices and the 30-day weighted moving average (WMA) of the logarithm of the close prices, using an exponentially decreasing weight scheme.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the natural logarithm of the close and high prices\n    df['log_close'] = np.log(df['close'])\n    df['log_high'] = np.log(df['high'])\n    \n    # Calculate the 30-day Simple Moving Average (SMA) for log_high\n    df['SMA_30_log_high'] = df['log_high'].rolling(window=30).mean()\n    \n    # Define weights for Weighted Moving Average (WMA) with exponential decay\n    weights = np.exp(np.linspace(0.1, 1, 30))\n    weights = weights / weights.sum()\n    \n    # Calculate the 30-day Weighted Moving Average (WMA) for log_close\n    df['WMA_30_log_close'] = df['log_close'].rolling(window=30).apply(lambda x: (x * weights).sum(), raw=True)\n    \n    # Create the heuristic: difference between SMA_30_log_high and WMA_30_log_close\n    heuristics_matrix = df['SMA_30_log_high'] - df['WMA_30_log_close']\n    \n    return heuristics_matrix",
          "objective": -0.02594,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a novel alpha factor by computing the difference between the 20-day exponential moving average (EMA) of the logarithm of the open prices and the 10-day standard deviation (STD) of the logarithm of the close prices, aiming to capture both trend and volatility aspects.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the natural logarithm of the open and close prices\n    df['log_open'] = np.log(df['open'])\n    df['log_close'] = np.log(df['close'])\n    \n    # Calculate the 20-day Exponential Moving Average (EMA) for log_open\n    df['EMA_20_log_open'] = df['log_open'].ewm(span=20, adjust=False).mean()\n    \n    # Calculate the 10-day Standard Deviation (STD) for log_close\n    df['STD_10_log_close'] = df['log_close'].rolling(window=10).std()\n    \n    # Create the heuristic: difference between EMA_20_log_open and STD_10_log_close\n    heuristics_matrix = df['EMA_20_log_open'] - df['STD_10_log_close']\n    \n    return heuristics_matrix",
          "objective": -0.02554,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a novel alpha factor by computing the ratio of the 20-day cumulative sum of the logarithm of the volume to the 20-day simple moving average (SMA) of the logarithm of the close prices, aiming to capture a more sensitive and shorter-term impact of trading activity on stock valuation.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the natural logarithm of the close prices and volume\n    df['log_close'] = np.log(df['close'])\n    df['log_volume'] = np.log(df['volume'])\n    \n    # Calculate the 20-day Simple Moving Average (SMA) for log_close\n    df['SMA_20_log_close'] = df['log_close'].rolling(window=20).mean()\n    \n    # Calculate the 20-day cumulative sum for log_volume\n    df['cumsum_20_log_volume'] = df['log_volume'].rolling(window=20).sum()\n    \n    # Create the heuristic: ratio of cumsum_20_log_volume to SMA_20_log_close\n    heuristics_matrix = df['cumsum_20_log_volume'] / df['SMA_20_log_close']\n    \n    return heuristics_matrix",
          "objective": -0.02539,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a novel alpha factor by computing the ratio of the 50-day cumulative sum of the logarithm of the volume to the 50-day simple moving average (SMA) of the logarithm of the low prices, aiming to capture the impact of trading activity on stock valuation.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the natural logarithm of the low prices and volume\n    df['log_low'] = np.log(df['low'])\n    df['log_volume'] = np.log(df['volume'])\n    \n    # Calculate the 50-day Simple Moving Average (SMA) for log_low\n    df['SMA_50_log_low'] = df['log_low'].rolling(window=50).mean()\n    \n    # Calculate the 50-day cumulative sum for log_volume\n    df['cumsum_50_log_volume'] = df['log_volume'].rolling(window=50).sum()\n    \n    # Create the heuristic: ratio of cumsum_50_log_volume to SMA_50_log_low\n    heuristics_matrix = df['cumsum_50_log_volume'] / df['SMA_50_log_low']\n    \n    return heuristics_matrix",
          "objective": -0.02432,
          "other_inf": null
     }
]