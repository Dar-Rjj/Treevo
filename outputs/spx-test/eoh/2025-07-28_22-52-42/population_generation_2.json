[
     {
          "algorithm": "The algorithm identifies patterns in the ratio of consecutive day's closing prices to the average of their trading volumes, aiming to generate a heuristics-based alpha factor by mapping these ratios through a series of non-linear transformations.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the ratio of consecutive days' closing prices\n    close_ratio = df['close'].pct_change().shift(-1)\n    # Calculate the rolling mean of volume over a 5-day window\n    volume_mean = df['volume'].rolling(window=5).mean()\n    # Apply a non-linear transformation to the close ratio and volume mean\n    transformed_close_ratio = (close_ratio - close_ratio.min()) / (close_ratio.max() - close_ratio.min())\n    transformed_volume_mean = (volume_mean - volume_mean.min()) / (volume_mean.max() - volume_mean.min())\n    # Generate the heuristics matrix as the product of the two transformed values\n    heuristics_matrix = transformed_close_ratio * transformed_volume_mean\n    return heuristics_matrix",
          "objective": -0.08257,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a novel alpha factor by computing the difference between the 30-day simple moving average (SMA) of the logarithm of the high prices and the 30-day weighted moving average (WMA) of the logarithm of the close prices, using an exponentially decreasing weight scheme.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the natural logarithm of the close and high prices\n    df['log_close'] = np.log(df['close'])\n    df['log_high'] = np.log(df['high'])\n    \n    # Calculate the 30-day Simple Moving Average (SMA) for log_high\n    df['SMA_30_log_high'] = df['log_high'].rolling(window=30).mean()\n    \n    # Define weights for Weighted Moving Average (WMA) with exponential decay\n    weights = np.exp(np.linspace(0.1, 1, 30))\n    weights = weights / weights.sum()\n    \n    # Calculate the 30-day Weighted Moving Average (WMA) for log_close\n    df['WMA_30_log_close'] = df['log_close'].rolling(window=30).apply(lambda x: (x * weights).sum(), raw=True)\n    \n    # Create the heuristic: difference between SMA_30_log_high and WMA_30_log_close\n    heuristics_matrix = df['SMA_30_log_high'] - df['WMA_30_log_close']\n    \n    return heuristics_matrix",
          "objective": -0.02594,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a novel alpha factor by computing the difference between the 20-day simple moving average (SMA) of the logarithm of the high prices and the 20-day weighted moving average (WMA) of the logarithm of the close prices, using a linearly decreasing weight scheme, to enhance the detection of momentum and potential trend shifts.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the natural logarithm of the close and high prices\n    df['log_close'] = np.log(df['close'])\n    df['log_high'] = np.log(df['high'])\n    \n    # Calculate the 20-day Simple Moving Average (SMA) for log_high\n    df['SMA_20_log_high'] = df['log_high'].rolling(window=20).mean()\n    \n    # Define weights for Weighted Moving Average (WMA)\n    weights = np.arange(1, 21)\n    weights = weights / weights.sum()\n    \n    # Calculate the 20-day Weighted Moving Average (WMA) for log_close\n    df['WMA_20_log_close'] = df['log_close'].rolling(window=20).apply(lambda x: (x * weights).sum(), raw=True)\n    \n    # Create the heuristic: difference between SMA_20_log_high and WMA_20_log_close\n    heuristics_matrix = df['SMA_20_log_high'] - df['WMA_20_log_close']\n    \n    return heuristics_matrix",
          "objective": -0.02425,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a novel alpha factor by considering the weighted difference between the logarithm of the closing price and the average logarithm of the high and low prices over a 20-day period, aiming to capture the relative strength and potential reversal signals.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the natural logarithm of the close, high, and low prices\n    df['log_close'] = np.log(df['close'])\n    df['log_high'] = np.log(df['high'])\n    df['log_low'] = np.log(df['low'])\n    \n    # Calculate the average of the logarithms of the high and low prices over a 20-day window\n    df['avg_log_high_low'] = (df['log_high'] + df['log_low']) / 2\n    df['MA_20_avg_log_high_low'] = df['avg_log_high_low'].rolling(window=20).mean()\n    \n    # Create the heuristic: weighted difference between log_close and MA_20_avg_log_high_low\n    heuristics_matrix = df['log_close'] - 1.5 * df['MA_20_avg_log_high_low']\n    \n    return heuristics_matrix",
          "objective": -0.02294,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the factor by integrating the momentum of price changes, the volatility relative to the average volume, and the directional movement indicated by the difference between the highest and lowest prices over a set period.",
          "code": "def heuristics_v2(df):\n    # Momentum: 14-day change in closing price\n    momentum = df['close'] - df['close'].shift(14)\n    \n    # Volatility: 20-day standard deviation of closing price\n    vol = df['close'].rolling(window=20).std()\n    \n    # Volume ratio: current volume compared to its 30-day moving average\n    avg_vol_30d = df['volume'].rolling(window=30).mean()\n    vol_ratio = df['volume'] / avg_vol_30d\n    \n    # Directional movement: difference between 20-day high and low\n    high_20d = df['high'].rolling(window=20).max()\n    low_20d = df['low'].rolling(window=20).min()\n    dir_movement = (high_20d - low_20d) / df['close']\n    \n    # Composite heuristic\n    heuristics_matrix = (momentum + (vol * vol_ratio) + dir_movement) / 3\n    \n    return heuristics_matrix",
          "objective": -0.02005,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a novel alpha factor by incorporating the exponential moving average (EMA) of the logarithm of the closing price and subtracting it from the smoothed (using a simple moving average, SMA) version of the logarithm of the high prices over a 20-day period, aiming to capture momentum and potential trend reversals.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the natural logarithm of the close and high prices\n    df['log_close'] = np.log(df['close'])\n    df['log_high'] = np.log(df['high'])\n    \n    # Calculate the 20-day Exponential Moving Average (EMA) for log_close\n    df['EMA_20_log_close'] = df['log_close'].ewm(span=20, adjust=False).mean()\n    \n    # Calculate the 20-day Simple Moving Average (SMA) for log_high\n    df['SMA_20_log_high'] = df['log_high'].rolling(window=20).mean()\n    \n    # Create the heuristic: difference between SMA_20_log_high and EMA_20_log_close\n    heuristics_matrix = df['SMA_20_log_high'] - df['EMA_20_log_close']\n    \n    return heuristics_matrix",
          "objective": -0.01937,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the factor by taking the ratio of the 20-day and 50-day simple moving averages of the closing price, then subtracting this ratio from 1 and multiplying the result by the standard deviation of the closing prices over a 20-day window.",
          "code": "def heuristics_v2(df):\n    sma_20 = df['close'].rolling(window=20).mean()\n    sma_50 = df['close'].rolling(window=50).mean()\n    ratio_sma = sma_20 / sma_50\n    std_close = df['close'].rolling(window=20).std()\n    heuristics_matrix = (1 - ratio_sma) * std_close\n    return heuristics_matrix",
          "objective": -0.01829,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the factor by taking the difference between the 20-day and 50-day simple moving averages of the closing price, then dividing this difference by the standard deviation of the closing prices over a 20-day window.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    sma_20 = df['close'].rolling(window=20).mean()\n    sma_50 = df['close'].rolling(window=50).mean()\n    diff_sma = sma_20 - sma_50\n    std_close = df['close'].rolling(window=20).std()\n    heuristics_matrix = diff_sma / std_close\n    return heuristics_matrix",
          "objective": -0.01778,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the factor by combining the momentum of price changes over a 15-day period, the volatility relative to the average volume over a 30-day period, and the directional movement indicated by the difference between the highest and lowest prices over a 5-day period, with updated weights for each component.",
          "code": "def heuristics_v2(df):\n    # Momentum: 15-day change in closing price\n    momentum = df['close'] - df['close'].shift(15)\n    \n    # Volatility: 30-day standard deviation of closing price\n    vol = df['close'].rolling(window=30).std()\n    \n    # Volume ratio: current volume compared to its 30-day moving average\n    avg_vol_30d = df['volume'].rolling(window=30).mean()\n    vol_ratio = df['volume'] / avg_vol_30d\n    \n    # Directional movement: difference between 5-day high and low\n    high_5d = df['high'].rolling(window=5).max()\n    low_5d = df['low'].rolling(window=5).min()\n    dir_movement = (high_5d - low_5d) / df['close']\n    \n    # Composite heuristic with different weights\n    heuristics_matrix = (momentum * 0.5 + (vol * vol_ratio) * 0.2 + dir_movement * 0.3)\n    \n    return heuristics_matrix",
          "objective": -0.01763,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the factor by taking the ratio of the 30-day and 60-day simple moving averages of the closing price, then subtracting this ratio from 1 and multiplying the result by the standard deviation of the closing prices over a 30-day window.",
          "code": "def heuristics_v2(df):\n    sma_30 = df['close'].rolling(window=30).mean()\n    sma_60 = df['close'].rolling(window=60).mean()\n    ratio_sma = sma_30 / sma_60\n    std_close = df['close'].rolling(window=30).std()\n    heuristics_matrix = (1 - ratio_sma) * std_close\n    return heuristics_matrix",
          "objective": -0.01736,
          "other_inf": null
     }
]