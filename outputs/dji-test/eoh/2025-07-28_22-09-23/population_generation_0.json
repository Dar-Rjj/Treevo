[
     {
          "algorithm": "The algorithm computes a heuristic factor by averaging the difference between the highest and lowest stock prices over a rolling window, then dividing it by the closing price to create a ratio that reflects volatility relative to the close.",
          "code": "def heuristics_v2(df):\n    def calculate_heuristic(row):\n        return (row['high'] - row['low']) / row['close']\n    \n    df['heuristic'] = df.apply(calculate_heuristic, axis=1)\n    heuristics_matrix = df['heuristic'].rolling(window=30).mean()\n    return heuristics_matrix",
          "objective": -0.04239,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a custom alpha factor for each date by combining moving averages of different lengths and price-to-volume ratios, aiming to identify momentum and value aspects.",
          "code": "def heuristics_v2(df):\n    ma_short = df['close'].rolling(window=10).mean()\n    ma_long = df['close'].rolling(window=50).mean()\n    price_to_volume = df['close'] / df['volume']\n    heuristics_matrix = (ma_short - ma_long) + price_to_volume\n    return heuristics_matrix",
          "objective": -0.02845,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a custom technical indicator by combining moving average convergence divergence (MACD) with a weighted sum of the last n days' closing prices, aiming to generate an interpretable alpha factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate MACD\n    exp1 = df['close'].ewm(span=12, adjust=False).mean()\n    exp2 = df['close'].ewm(span=26, adjust=False).mean()\n    macd = exp1 - exp2\n    signal = macd.ewm(span=9, adjust=False).mean()\n    macd_diff = macd - signal\n    \n    # Calculate weighted sum of the last 5 days' closing prices\n    weights = [0.15, 0.2, 0.25, 0.3, 0.1]\n    weighted_sum = df['close'].rolling(window=len(weights)).apply(lambda x: (x * weights).sum(), raw=True)\n    \n    # Combine MACD and weighted sum for the final heuristic\n    heuristics_matrix = macd_diff + weighted_sum.shift(1)\n    return heuristics_matrix",
          "objective": -0.02292,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm constructs a novel alpha factor by calculating the moving average convergence divergence (MACD) of the closing price and then applying a weighted sum of volume and the MACD to generate a heuristics matrix.",
          "code": "def heuristics_v2(df):\n    short_window = 12\n    long_window = 26\n    signal_window = 9\n    \n    # Calculate MACD\n    short_ema = df['close'].ewm(span=short_window, adjust=False).mean()\n    long_ema = df['close'].ewm(span=long_window, adjust=False).mean()\n    macd_line = short_ema - long_ema\n    signal_line = macd_line.ewm(span=signal_window, adjust=False).mean()\n    macd_histogram = macd_line - signal_line\n    \n    # Weighted sum of volume and MACD histogram\n    heuristics_matrix = (df['volume'] * 0.5) + (macd_histogram * 0.5)\n    \n    return heuristics_matrix",
          "objective": -0.01607,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a novel heuristic factor by combining the momentum and volatility of stock prices, then adjusting for trading volume, to predict future returns.",
          "code": "def heuristics_v2(df):\n    momentum = df['close'].pct_change(periods=20)\n    volatility = df['close'].rolling(window=20).std()\n    volume_adjustment = df['volume'] / df['volume'].rolling(window=20).mean()\n    heuristics_matrix = (momentum + 1) * (volatility + 1) * volume_adjustment\n    return heuristics_matrix",
          "objective": -0.01583,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies patterns in the relationship between trading volume and price changes, calculating a weighted score for each day based on these patterns to predict future returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def calculate_price_change(row):\n        return (row['close'] - row['open']) / row['open']\n\n    df['price_change'] = df.apply(calculate_price_change, axis=1)\n    df['volume_shift'] = df['volume'].shift(1)\n    df['weighted_score'] = (df['price_change'] * df['volume_shift']).rolling(window=5).mean()\n    heuristics_matrix = df['weighted_score'].dropna()\n    return heuristics_matrix",
          "objective": -0.01295,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a weighted sum of the percentage changes in open, high, low, and close prices, with additional weight on volume increase, to create an interpretable alpha factor.",
          "code": "def heuristics_v2(df):\n    price_changes = df[['open', 'high', 'low', 'close']].pct_change().fillna(0)\n    volume_change = (df['volume'] - df['volume'].shift(1)).fillna(0)\n    weights = [0.25, 0.25, 0.25, 0.25, 0.5]  # Weights for open, high, low, close, and volume change\n    heuristics_matrix = (price_changes * weights[:4]).sum(axis=1) + volume_change * weights[4]\n    return heuristics_matrix",
          "objective": -0.01246,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm, termed Heuristic Momentum Divergence (HMD), computes a momentum-based factor by comparing the current close price to an exponentially weighted moving average of past prices and then applying a divergence adjustment based on the volume changes over the same period.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def exp_weighted_moving_avg(series, span=10):\n        return series.ewm(span=span, adjust=False).mean()\n    \n    # Calculate the exponentially weighted moving average of the closing price\n    ewma_close = exp_weighted_moving_avg(df['close'])\n    \n    # Momentum factor: current close price divided by the EWMA of the close price\n    momentum_factor = df['close'] / ewma_close\n    \n    # Volume change: current volume divided by the EWMA of the volume\n    ewma_volume = exp_weighted_moving_avg(df['volume'])\n    volume_change = df['volume'] / ewma_volume\n    \n    # Divergence adjustment: if the volume is increasing, we slightly increase the momentum factor, and vice versa\n    divergence_adjustment = 1 + (volume_change - 1) * 0.1\n    adjusted_momentum = momentum_factor * divergence_adjustment\n    \n    # Output as a Series with the same index as input\n    heuristics_matrix = pd.Series(adjusted_momentum, name='HeuristicFactor')\n    \n    return heuristics_matrix",
          "objective": -0.00979,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a novel alpha factor by combining the relative strength index (RSI) of the closing price with the volume-weighted moving average (VWMA), capturing momentum and volume trends, to predict future returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def rsi(series, n=14):\n        delta = series.diff(1)\n        gain = (delta.where(delta > 0, 0)).rolling(window=n).mean()\n        loss = (-delta.where(delta < 0, 0)).rolling(window=n).mean()\n        rs = gain / loss\n        return 100 - (100 / (1 + rs))\n    \n    def vwma(df, window=20):\n        return df['close'].rolling(window=window).mean() * df['volume'].rolling(window=window).mean()\n\n    close_rsi = rsi(df['close'])\n    close_vwma = vwma(df)\n    heuristics_matrix = (close_rsi + close_vwma) / 2\n    return heuristics_matrix",
          "objective": -0.00958,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates the rate of change between the highest and lowest prices over a 10-day period, then combines this with the volume changes to generate an interpretable alpha factor.",
          "code": "def heuristics_v2(df):\n    df['high_low_change'] = (df['high'].rolling(window=10).max() - df['low'].rolling(window=10).min()) / df['close']\n    df['volume_change'] = df['volume'].pct_change()\n    heuristics_matrix = df['high_low_change'] * df['volume_change']\n    return heuristics_matrix",
          "objective": -0.00664,
          "other_inf": null
     }
]