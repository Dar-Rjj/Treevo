[
     {
          "algorithm": "The new algorithm calculates a heuristic factor by summing the product of the daily return and the relative difference between the day's closing price and the 60-day moving average, then dividing this sum by the 60-day standard deviation of the daily returns.",
          "code": "def heuristics_v2(df):\n    df['daily_return'] = df['close'].pct_change()\n    df['moving_avg_60'] = df['close'].rolling(window=60).mean()\n    df['relative_diff'] = (df['close'] - df['moving_avg_60']) / df['moving_avg_60']\n    df['weighted_diff'] = df['daily_return'] * df['relative_diff']\n    heuristics_matrix = df['weighted_diff'].rolling(window=60).sum() / df['daily_return'].rolling(window=60).std()\n    return heuristics_matrix",
          "objective": -0.05509,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a heuristic factor by averaging the difference between the highest and lowest stock prices over a 60-day rolling window, then dividing it by the average closing price of the same window to create a ratio that reflects relative volatility.",
          "code": "def heuristics_v2(df):\n    def calculate_heuristic(row):\n        return (row['high'] - row['low']) / row['close']\n    \n    df['heuristic'] = df.apply(calculate_heuristic, axis=1)\n    heuristics_matrix = df['heuristic'].rolling(window=60).mean() / df['close'].rolling(window=60).mean()\n    return heuristics_matrix",
          "objective": -0.05424,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a heuristic factor by averaging the difference between the highest and lowest stock prices over a 30-day rolling window, then dividing it by the average closing price of the same window to create a ratio that reflects relative short-term volatility.",
          "code": "def heuristics_v2(df):\n    def calculate_heuristic(row):\n        return (row['high'] - row['low']) / row['close']\n    \n    df['heuristic'] = df.apply(calculate_heuristic, axis=1)\n    heuristics_matrix = df['heuristic'].rolling(window=30).mean() / df['close'].rolling(window=30).mean()\n    return heuristics_matrix",
          "objective": -0.05256,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a heuristic factor by averaging the difference between the highest and lowest stock prices over a 20-day rolling window, then dividing it by the average closing price of the same window to create a ratio that reflects relative short-term volatility.",
          "code": "def heuristics_v2(df):\n    def calculate_heuristic(row):\n        return (row['high'] - row['low']) / row['close']\n    \n    df['heuristic'] = df.apply(calculate_heuristic, axis=1)\n    heuristics_matrix = df['heuristic'].rolling(window=20).mean() / df['close'].rolling(window=20).mean()\n    return heuristics_matrix",
          "objective": -0.05119,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a heuristic factor by averaging the difference between the highest and lowest stock prices over a 20-day rolling window, then dividing it by the median closing price of the same window to create a ratio that reflects relative short-term volatility.",
          "code": "def heuristics_v2(df):\n    def calculate_heuristic(row):\n        return (row['high'] - row['low']) / row['close']\n    \n    df['heuristic'] = df.apply(calculate_heuristic, axis=1)\n    heuristics_matrix = df['heuristic'].rolling(window=20).mean() / df['close'].rolling(window=20).median()\n    return heuristics_matrix",
          "objective": -0.05118,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by taking the median of the trading volume over a 90-day rolling window, then dividing this median by the minimum low price over the same window to create a ratio that reflects liquidity relative to the minimum low.",
          "code": "def heuristics_v2(df):\n    df['volume_median'] = df['volume'].rolling(window=90).median()\n    df['low_min'] = df['low'].rolling(window=90).min()\n    heuristics_matrix = df['volume_median'] / df['low_min']\n    return heuristics_matrix",
          "objective": -0.04757,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by taking the ratio of the average trading volume to the average closing price over a 90-day rolling window, providing insight into the relationship between liquidity and average price levels.",
          "code": "def heuristics_v2(df):\n    df['volume_avg'] = df['volume'].rolling(window=90).mean()\n    df['close_avg'] = df['close'].rolling(window=90).mean()\n    heuristics_matrix = df['volume_avg'] / df['close_avg']\n    return heuristics_matrix",
          "objective": -0.04585,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by first determining the difference between the highest and lowest stock prices over a 60-day rolling window, then dividing this difference by the median closing price over the same window, aiming to provide a robust measure of relative volatility.",
          "code": "def heuristics_v2(df):\n    df['heuristic'] = df['high'] - df['low']\n    heuristics_matrix = df['heuristic'].rolling(window=60).mean() / df['close'].rolling(window=60).median()\n    return heuristics_matrix",
          "objective": -0.04578,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a heuristic factor by averaging the trading volume over a rolling window, then dividing this average by the minimum closing price over the same window to create a ratio that reflects liquidity relative to the minimum close.",
          "code": "def heuristics_v2(df):\n    df['volume_avg'] = df['volume'].rolling(window=30).mean()\n    df['close_min'] = df['close'].rolling(window=30).min()\n    heuristics_matrix = df['volume_avg'] / df['close_min']\n    return heuristics_matrix",
          "objective": -0.04556,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by summing the trading volume over a 60-day rolling window, then dividing this sum by the average high price over the same window to create a ratio that reflects liquidity relative to the average high.",
          "code": "def heuristics_v2(df):\n    df['volume_sum'] = df['volume'].rolling(window=60).sum()\n    df['high_avg'] = df['high'].rolling(window=60).mean()\n    heuristics_matrix = df['volume_sum'] / df['high_avg']\n    return heuristics_matrix",
          "objective": -0.04551,
          "other_inf": null
     }
]