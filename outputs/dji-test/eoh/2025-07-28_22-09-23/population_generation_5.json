[
     {
          "algorithm": "The new algorithm calculates a heuristic factor by summing the product of the daily return and the relative difference between the day's closing price and the 60-day moving average, then dividing this sum by the 60-day range (difference between the maximum and minimum close prices) instead of the standard deviation.",
          "code": "def heuristics_v2(df):\n    df['daily_return'] = df['close'].pct_change()\n    df['moving_avg_60'] = df['close'].rolling(window=60).mean()\n    df['relative_diff'] = (df['close'] - df['moving_avg_60']) / df['moving_avg_60']\n    df['weighted_diff'] = df['daily_return'] * df['relative_diff']\n    range_60 = df['close'].rolling(window=60).max() - df['close'].rolling(window=60).min()\n    heuristics_matrix = df['weighted_diff'].rolling(window=60).sum() / range_60\n    return heuristics_matrix",
          "objective": -0.06846,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by averaging the product of the daily return and the relative difference between the day's closing price and the 60-day mean, then adjusting this average by dividing it with the 60-day standard deviation of the closing prices.",
          "code": "def heuristics_v2(df):\n    df['daily_return'] = df['close'].pct_change()\n    df['mean_60'] = df['close'].rolling(window=60).mean()\n    df['relative_diff'] = (df['close'] - df['mean_60']) / df['mean_60']\n    df['weighted_diff'] = df['daily_return'] * df['relative_diff']\n    df['std_60'] = df['close'].rolling(window=60).std()\n    heuristics_matrix = df['weighted_diff'].rolling(window=60).mean() / df['std_60']\n    return heuristics_matrix",
          "objective": -0.06811,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by summing the product of the daily return and the relative difference between the day's closing price and the 60-day median, then dividing this sum by the 60-day range (difference between the highest and lowest prices) over the same period.",
          "code": "def heuristics_v2(df):\n    df['daily_return'] = df['close'].pct_change()\n    df['median_60'] = df['close'].rolling(window=60).median()\n    df['relative_diff'] = (df['close'] - df['median_60']) / df['median_60']\n    df['weighted_diff'] = df['daily_return'] * df['relative_diff']\n    df['range_60'] = df['high'].rolling(window=60).max() - df['low'].rolling(window=60).min()\n    heuristics_matrix = df['weighted_diff'].rolling(window=60).sum() / df['range_60']\n    return heuristics_matrix",
          "objective": -0.06735,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by summing the product of the daily return and the relative difference between the day's closing price and the 60-day moving average, then dividing this sum by the 60-day standard deviation of the daily returns.",
          "code": "def heuristics_v2(df):\n    df['daily_return'] = df['close'].pct_change()\n    df['moving_avg_60'] = df['close'].rolling(window=60).mean()\n    df['relative_diff'] = (df['close'] - df['moving_avg_60']) / df['moving_avg_60']\n    df['weighted_diff'] = df['daily_return'] * df['relative_diff']\n    heuristics_matrix = df['weighted_diff'].rolling(window=60).sum() / df['daily_return'].rolling(window=60).std()\n    return heuristics_matrix",
          "objective": -0.05509,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a heuristic factor by averaging the difference between the highest and lowest stock prices over a 60-day rolling window, then dividing it by the average closing price of the same window to create a ratio that reflects relative volatility.",
          "code": "def heuristics_v2(df):\n    def calculate_heuristic(row):\n        return (row['high'] - row['low']) / row['close']\n    \n    df['heuristic'] = df.apply(calculate_heuristic, axis=1)\n    heuristics_matrix = df['heuristic'].rolling(window=60).mean() / df['close'].rolling(window=60).mean()\n    return heuristics_matrix",
          "objective": -0.05424,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a heuristic factor by averaging the difference between the highest and lowest stock prices over a 30-day rolling window, then dividing it by the average closing price of the same window to create a ratio that reflects relative short-term volatility.",
          "code": "def heuristics_v2(df):\n    def calculate_heuristic(row):\n        return (row['high'] - row['low']) / row['close']\n    \n    df['heuristic'] = df.apply(calculate_heuristic, axis=1)\n    heuristics_matrix = df['heuristic'].rolling(window=30).mean() / df['close'].rolling(window=30).mean()\n    return heuristics_matrix",
          "objective": -0.05256,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a heuristic factor by averaging the difference between the highest and lowest stock prices over a 20-day rolling window, then dividing it by the average closing price of the same window to create a ratio that reflects relative short-term volatility.",
          "code": "def heuristics_v2(df):\n    def calculate_heuristic(row):\n        return (row['high'] - row['low']) / row['close']\n    \n    df['heuristic'] = df.apply(calculate_heuristic, axis=1)\n    heuristics_matrix = df['heuristic'].rolling(window=20).mean() / df['close'].rolling(window=20).mean()\n    return heuristics_matrix",
          "objective": -0.05119,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a heuristic factor by averaging the difference between the highest and lowest stock prices over a 20-day rolling window, then dividing it by the median closing price of the same window to create a ratio that reflects relative short-term volatility.",
          "code": "def heuristics_v2(df):\n    def calculate_heuristic(row):\n        return (row['high'] - row['low']) / row['close']\n    \n    df['heuristic'] = df.apply(calculate_heuristic, axis=1)\n    heuristics_matrix = df['heuristic'].rolling(window=20).mean() / df['close'].rolling(window=20).median()\n    return heuristics_matrix",
          "objective": -0.05118,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by summing the difference between the highest and lowest stock prices over a 10-day rolling window, then dividing it by the sum of the closing prices within the same window to assess the relative short-term volatility.",
          "code": "def heuristics_v2(df):\n    def calculate_heuristic(row):\n        return (row['high'] - row['low']) / row['close']\n    \n    df['heuristic'] = df.apply(calculate_heuristic, axis=1)\n    heuristics_matrix = df['heuristic'].rolling(window=10).sum() / df['close'].rolling(window=10).sum()\n    return heuristics_matrix",
          "objective": -0.05081,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by averaging the product of the daily return and the relative difference between the day's closing price and the 30-day mean, then adjusting this average by dividing it with the 30-day standard deviation of the closing prices.",
          "code": "def heuristics_v2(df):\n    df['daily_return'] = df['close'].pct_change()\n    df['mean_30'] = df['close'].rolling(window=30).mean()\n    df['relative_diff'] = (df['close'] - df['mean_30']) / df['mean_30']\n    df['weighted_diff'] = df['daily_return'] * df['relative_diff']\n    df['std_30'] = df['close'].rolling(window=30).std()\n    heuristics_matrix = df['weighted_diff'].rolling(window=30).mean() / df['std_30']\n    return heuristics_matrix",
          "objective": -0.05017,
          "other_inf": null
     }
]