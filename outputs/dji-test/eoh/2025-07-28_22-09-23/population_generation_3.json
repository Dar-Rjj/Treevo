[
     {
          "algorithm": "The new algorithm computes a heuristic factor by averaging the difference between the highest and lowest stock prices over a 60-day rolling window, then dividing it by the average closing price of the same window to create a ratio that reflects relative volatility.",
          "code": "def heuristics_v2(df):\n    def calculate_heuristic(row):\n        return (row['high'] - row['low']) / row['close']\n    \n    df['heuristic'] = df.apply(calculate_heuristic, axis=1)\n    heuristics_matrix = df['heuristic'].rolling(window=60).mean() / df['close'].rolling(window=60).mean()\n    return heuristics_matrix",
          "objective": -0.05424,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a heuristic factor by averaging the difference between the highest and lowest stock prices over a 30-day rolling window, then dividing it by the average closing price of the same window to create a ratio that reflects relative short-term volatility.",
          "code": "def heuristics_v2(df):\n    def calculate_heuristic(row):\n        return (row['high'] - row['low']) / row['close']\n    \n    df['heuristic'] = df.apply(calculate_heuristic, axis=1)\n    heuristics_matrix = df['heuristic'].rolling(window=30).mean() / df['close'].rolling(window=30).mean()\n    return heuristics_matrix",
          "objective": -0.05256,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a heuristic factor by averaging the difference between the highest and lowest stock prices over a 20-day rolling window, then dividing it by the average closing price of the same window to create a ratio that reflects relative short-term volatility.",
          "code": "def heuristics_v2(df):\n    def calculate_heuristic(row):\n        return (row['high'] - row['low']) / row['close']\n    \n    df['heuristic'] = df.apply(calculate_heuristic, axis=1)\n    heuristics_matrix = df['heuristic'].rolling(window=20).mean() / df['close'].rolling(window=20).mean()\n    return heuristics_matrix",
          "objective": -0.05119,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by first determining the difference between the highest and lowest stock prices over a 60-day rolling window, then dividing this difference by the median closing price over the same window, aiming to provide a robust measure of relative volatility.",
          "code": "def heuristics_v2(df):\n    df['heuristic'] = df['high'] - df['low']\n    heuristics_matrix = df['heuristic'].rolling(window=60).mean() / df['close'].rolling(window=60).median()\n    return heuristics_matrix",
          "objective": -0.04578,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a heuristic factor by averaging the trading volume over a rolling window, then dividing this average by the minimum closing price over the same window to create a ratio that reflects liquidity relative to the minimum close.",
          "code": "def heuristics_v2(df):\n    df['volume_avg'] = df['volume'].rolling(window=30).mean()\n    df['close_min'] = df['close'].rolling(window=30).min()\n    heuristics_matrix = df['volume_avg'] / df['close_min']\n    return heuristics_matrix",
          "objective": -0.04556,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by summing the trading volume over a 60-day rolling window, then dividing this sum by the average high price over the same window to create a ratio that reflects liquidity relative to the average high.",
          "code": "def heuristics_v2(df):\n    df['volume_sum'] = df['volume'].rolling(window=60).sum()\n    df['high_avg'] = df['high'].rolling(window=60).mean()\n    heuristics_matrix = df['volume_sum'] / df['high_avg']\n    return heuristics_matrix",
          "objective": -0.04551,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by first computing the ratio of the difference between the highest and lowest stock prices to the average of the opening and closing prices over a 60-day rolling window, then averaging these ratios.",
          "code": "def heuristics_v2(df):\n    def calculate_heuristic(row):\n        return (row['high'] - row['low']) / ((row['open'] + row['close']) / 2)\n    \n    df['heuristic'] = df.apply(calculate_heuristic, axis=1)\n    heuristics_matrix = df['heuristic'].rolling(window=60).mean()\n    return heuristics_matrix",
          "objective": -0.04515,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by averaging the trading volume over a 30-day rolling window, then dividing this average by the median high price over the same window to create a ratio that reflects liquidity relative to the median high.",
          "code": "def heuristics_v2(df):\n    df['volume_avg'] = df['volume'].rolling(window=30).mean()\n    df['high_median'] = df['high'].rolling(window=30).median()\n    heuristics_matrix = df['volume_avg'] / df['high_median']\n    return heuristics_matrix",
          "objective": -0.04489,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a heuristic factor by summing the trading volume over a rolling window, then dividing this sum by the average closing price over the same window to create a ratio that reflects liquidity relative to the average close.",
          "code": "def heuristics_v2(df):\n    df['volume_sum'] = df['volume'].rolling(window=30).sum()\n    df['close_avg'] = df['close'].rolling(window=30).mean()\n    heuristics_matrix = df['volume_sum'] / df['close_avg']\n    return heuristics_matrix",
          "objective": -0.04487,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by first determining the difference between the highest and lowest stock prices over a 60-day rolling window, then dividing this difference by the average of the open and close prices over the same period to create a ratio that reflects relative volatility with a focus on daily price range.",
          "code": "def heuristics_v2(df):\n    df['heuristic'] = df['high'] - df['low']\n    heuristics_matrix = df['heuristic'].rolling(window=60).mean() / (df['open'].rolling(window=60).mean() + df['close'].rolling(window=60).mean()) * 0.5\n    return heuristics_matrix",
          "objective": -0.04475,
          "other_inf": null
     }
]