[
     {
          "algorithm": "The new algorithm computes a heuristic factor by averaging the difference between the highest and lowest stock prices over a 60-day rolling window, then dividing it by the average closing price of the same window to create a ratio that reflects relative volatility.",
          "code": "def heuristics_v2(df):\n    def calculate_heuristic(row):\n        return (row['high'] - row['low']) / row['close']\n    \n    df['heuristic'] = df.apply(calculate_heuristic, axis=1)\n    heuristics_matrix = df['heuristic'].rolling(window=60).mean() / df['close'].rolling(window=60).mean()\n    return heuristics_matrix",
          "objective": -0.05424,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a heuristic factor by averaging the difference between the highest and lowest stock prices over a rolling window, then dividing it by the closing price to create a ratio that reflects volatility relative to the close.",
          "code": "def heuristics_v2(df):\n    def calculate_heuristic(row):\n        return (row['high'] - row['low']) / row['close']\n    \n    df['heuristic'] = df.apply(calculate_heuristic, axis=1)\n    heuristics_matrix = df['heuristic'].rolling(window=30).mean()\n    return heuristics_matrix",
          "objective": -0.04239,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a modified heuristic factor by averaging the ratio of the difference between the highest and lowest stock prices to the average of the opening and closing prices over a rolling window, aiming to provide a more balanced measure of intraday price volatility.",
          "code": "def heuristics_v2(df):\n    def calculate_heuristic(row):\n        return (row['high'] - row['low']) / ((row['open'] + row['close']) / 2)\n    \n    df['heuristic'] = df.apply(calculate_heuristic, axis=1)\n    heuristics_matrix = df['heuristic'].rolling(window=30).mean()\n    return heuristics_matrix",
          "objective": -0.04236,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a custom alpha factor for each date by combining moving averages of different lengths and price-to-volume ratios, aiming to identify momentum and value aspects.",
          "code": "def heuristics_v2(df):\n    ma_short = df['close'].rolling(window=10).mean()\n    ma_long = df['close'].rolling(window=50).mean()\n    price_to_volume = df['close'] / df['volume']\n    heuristics_matrix = (ma_short - ma_long) + price_to_volume\n    return heuristics_matrix",
          "objective": -0.02845,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm integrates the rate of change (ROC) of the closing price with the accumulation/distribution line (ADL) to capture momentum and buying/selling pressure.",
          "code": "def heuristics_v2(df):\n    def roc(series, n=14):\n        return (series / series.shift(n) - 1) * 100\n    \n    def adl(df):\n        money_flow_multiplier = ((df['close'] - df['low']) - (df['high'] - df['close'])) / (df['high'] - df['low'])\n        money_flow_volume = money_flow_multiplier * df['volume']\n        return money_flow_volume.cumsum()\n    \n    close_roc = roc(df['close'])\n    adl_line = adl(df)\n    heuristics_matrix = (close_roc + adl_line) / 2\n    return heuristics_matrix",
          "objective": -0.02581,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm modifies the original by using a 21-period ROC and a 21-period EMA for the ADL, aiming to capture medium-term momentum and buying/selling pressure.",
          "code": "def heuristics_v2(df):\n    def roc(series, n=21):\n        return (series / series.shift(n) - 1) * 100\n    \n    def adl_smoothed(df, n=21):\n        money_flow_multiplier = ((df['close'] - df['low']) - (df['high'] - df['close'])) / (df['high'] - df['low'])\n        money_flow_volume = money_flow_multiplier * df['volume']\n        adl_ema = money_flow_volume.ewm(span=n, adjust=False).mean()\n        return adl_ema.cumsum()\n    \n    close_roc = roc(df['close'])\n    adl_line = adl_smoothed(df)\n    heuristics_matrix = (close_roc + adl_line) / 2\n    return heuristics_matrix",
          "objective": -0.02565,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm integrates the rate of change (ROC) of the closing price with a modified accumulation/distribution line (ADL) that uses exponential moving averages to capture momentum and smoothed buying/selling pressure.",
          "code": "def heuristics_v2(df):\n    def roc(series, n=14):\n        return (series / series.shift(n) - 1) * 100\n    \n    def adl_smoothed(df, n=14):\n        money_flow_multiplier = ((df['close'] - df['low']) - (df['high'] - df['close'])) / (df['high'] - df['low'])\n        money_flow_volume = money_flow_multiplier * df['volume']\n        adl_ema = money_flow_volume.ewm(span=n, adjust=False).mean()\n        return adl_ema.cumsum()\n    \n    close_roc = roc(df['close'])\n    adl_line = adl_smoothed(df)\n    heuristics_matrix = (close_roc + adl_line) / 2\n    return heuristics_matrix",
          "objective": -0.0255,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm modifies the original by changing the RSI computation parameters, adjusting the long-term average period, and incorporating a factor based on volume to better capture market sentiment.",
          "code": "def heuristics_v2(df):\n    delta = df['close'].diff()\n    up = delta.clip(lower=0)\n    down = -1 * delta.clip(upper=0)\n    ema_up = up.ewm(com=9, adjust=False).mean()\n    ema_down = down.ewm(com=9, adjust=False).mean()\n    rs = ema_up / ema_down\n    rsi = 100 - (100 / (1 + rs))\n    avg_price_long = df['close'].rolling(window=100).mean()\n    price_to_avg_long = df['close'] / avg_price_long\n    high_low_diff = df['high'] - df['low']\n    volume_factor = df['volume'].rolling(window=30).mean() / df['volume']\n    heuristics_matrix = rsi * price_to_avg_long * high_low_diff * volume_factor\n    return heuristics_matrix",
          "objective": -0.02543,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes an alpha factor by integrating the relative strength index (RSI) and the ratio of current price to the average price over a long period, adjusted by the difference between daily high and low prices, to capture both momentum and volatility.",
          "code": "def heuristics_v2(df):\n    delta = df['close'].diff()\n    up = delta.clip(lower=0)\n    down = -1 * delta.clip(upper=0)\n    ema_up = up.ewm(com=13, adjust=False).mean()\n    ema_down = down.ewm(com=13, adjust=False).mean()\n    rs = ema_up / ema_down\n    rsi = 100 - (100 / (1 + rs))\n    avg_price_long = df['close'].rolling(window=50).mean()\n    price_to_avg_long = df['close'] / avg_price_long\n    high_low_diff = df['high'] - df['low']\n    heuristics_matrix = rsi * price_to_avg_long * high_low_diff\n    return heuristics_matrix",
          "objective": -0.02528,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a novel alpha factor by integrating the exponential moving average (EMA) of the closing price with the money flow index (MFI), focusing on both trend and buying/selling pressure.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def ema(series, span=14):\n        return series.ewm(span=span, adjust=False).mean()\n    \n    def mfi(df, n=14):\n        typical_price = (df['high'] + df['low'] + df['close']) / 3\n        raw_money_flow = typical_price * df['volume']\n        positive_flow = raw_money_flow.where(typical_price > typical_price.shift(1), 0)\n        negative_flow = raw_money_flow.where(typical_price < typical_price.shift(1), 0)\n        money_ratio = positive_flow.rolling(window=n).sum() / negative_flow.rolling(window=n).sum()\n        return 100 - (100 / (1 + money_ratio))\n    \n    close_ema = ema(df['close'])\n    close_mfi = mfi(df)\n    heuristics_matrix = (close_ema + close_mfi) / 2\n    return heuristics_matrix",
          "objective": -0.02461,
          "other_inf": null
     }
]