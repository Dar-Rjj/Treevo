[
     {
          "algorithm": "The new algorithm computes a heuristic factor by averaging the difference between the highest and lowest stock prices over a 60-day rolling window, then dividing it by the average closing price of the same window to create a ratio that reflects relative volatility.",
          "code": "def heuristics_v2(df):\n    def calculate_heuristic(row):\n        return (row['high'] - row['low']) / row['close']\n    \n    df['heuristic'] = df.apply(calculate_heuristic, axis=1)\n    heuristics_matrix = df['heuristic'].rolling(window=60).mean() / df['close'].rolling(window=60).mean()\n    return heuristics_matrix",
          "objective": -0.05424,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a heuristic factor by averaging the difference between the highest and lowest stock prices over a 30-day rolling window, then dividing it by the average closing price of the same window to create a ratio that reflects relative short-term volatility.",
          "code": "def heuristics_v2(df):\n    def calculate_heuristic(row):\n        return (row['high'] - row['low']) / row['close']\n    \n    df['heuristic'] = df.apply(calculate_heuristic, axis=1)\n    heuristics_matrix = df['heuristic'].rolling(window=30).mean() / df['close'].rolling(window=30).mean()\n    return heuristics_matrix",
          "objective": -0.05256,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by first determining the difference between the highest and lowest stock prices over a 60-day rolling window, then dividing this difference by the median closing price over the same window, aiming to provide a robust measure of relative volatility.",
          "code": "def heuristics_v2(df):\n    df['heuristic'] = df['high'] - df['low']\n    heuristics_matrix = df['heuristic'].rolling(window=60).mean() / df['close'].rolling(window=60).median()\n    return heuristics_matrix",
          "objective": -0.04578,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by summing the trading volume over a 60-day rolling window, then dividing this sum by the average high price over the same window to create a ratio that reflects liquidity relative to the average high.",
          "code": "def heuristics_v2(df):\n    df['volume_sum'] = df['volume'].rolling(window=60).sum()\n    df['high_avg'] = df['high'].rolling(window=60).mean()\n    heuristics_matrix = df['volume_sum'] / df['high_avg']\n    return heuristics_matrix",
          "objective": -0.04551,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a heuristic factor by summing the trading volume over a rolling window, then dividing this sum by the average closing price over the same window to create a ratio that reflects liquidity relative to the average close.",
          "code": "def heuristics_v2(df):\n    df['volume_sum'] = df['volume'].rolling(window=30).sum()\n    df['close_avg'] = df['close'].rolling(window=30).mean()\n    heuristics_matrix = df['volume_sum'] / df['close_avg']\n    return heuristics_matrix",
          "objective": -0.04487,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by first determining the difference between the highest and lowest stock prices over a 60-day rolling window, then dividing this difference by the average of the open and close prices over the same period to create a ratio that reflects relative volatility with a focus on daily price range.",
          "code": "def heuristics_v2(df):\n    df['heuristic'] = df['high'] - df['low']\n    heuristics_matrix = df['heuristic'].rolling(window=60).mean() / (df['open'].rolling(window=60).mean() + df['close'].rolling(window=60).mean()) * 0.5\n    return heuristics_matrix",
          "objective": -0.04475,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a heuristic factor by first calculating the exponentially weighted moving average (EWMA) of the trading volume, then dividing this EWMA by the simple moving average of the closing price over the same window to capture more recent trading activity relative to the average closing price.",
          "code": "def heuristics_v2(df):\n    df['volume_ewma'] = df['volume'].ewm(span=30).mean()\n    df['close_avg'] = df['close'].rolling(window=30).mean()\n    heuristics_matrix = df['volume_ewma'] / df['close_avg']\n    return heuristics_matrix",
          "objective": -0.04392,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a heuristic factor by first calculating the exponentially weighted moving average (EWMA) of the trading volume with a span of 20, then dividing this EWMA by the simple moving average of the closing price over a window of 20 days to focus on more recent trading activity and price movements.",
          "code": "def heuristics_v2(df):\n    df['volume_ewma'] = df['volume'].ewm(span=20).mean()\n    df['close_avg'] = df['close'].rolling(window=20).mean()\n    heuristics_matrix = df['volume_ewma'] / df['close_avg']\n    return heuristics_matrix",
          "objective": -0.04318,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a heuristic factor by averaging the difference between the highest and lowest stock prices over a rolling window, then dividing it by the closing price to create a ratio that reflects volatility relative to the close.",
          "code": "def heuristics_v2(df):\n    def calculate_heuristic(row):\n        return (row['high'] - row['low']) / row['close']\n    \n    df['heuristic'] = df.apply(calculate_heuristic, axis=1)\n    heuristics_matrix = df['heuristic'].rolling(window=30).mean()\n    return heuristics_matrix",
          "objective": -0.04239,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by using the 30-day rolling window to determine the difference between the highest and lowest stock prices, then dividing this by the average of the open and close prices over the same 30-day period.",
          "code": "def heuristics_v2(df):\n    df['heuristic'] = df['high'] - df['low']\n    heuristics_matrix = df['heuristic'].rolling(window=30).mean() / (df['open'].rolling(window=30).mean() + df['close'].rolling(window=30).mean()) * 0.5\n    return heuristics_matrix",
          "objective": -0.04238,
          "other_inf": null
     }
]