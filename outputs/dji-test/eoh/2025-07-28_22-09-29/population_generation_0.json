[
     {
          "algorithm": "The algorithm calculates a momentum-based alpha factor by first computing the average daily return over a short window, then subtracting the average daily return over a longer window to identify the acceleration in the stock's price trend.",
          "code": "def heuristics_v2(df):\n    short_window = 5\n    long_window = 20\n    df['short_momentum'] = df['close'].pct_change().rolling(window=short_window).mean()\n    df['long_momentum'] = df['close'].pct_change().rolling(window=long_window).mean()\n    heuristics_matrix = df['short_momentum'] - df['long_momentum']\n    return heuristics_matrix",
          "objective": -0.02851,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a composite factor by calculating the moving average convergence divergence (MACD) between the closing price and its exponential moving average, then adjusting it based on the relative strength index (RSI) of the volume, aiming to generate interpretable alpha factors for stock return prediction.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def macd_line(price, fast=12, slow=26):\n        ema_fast = price.ewm(span=fast, adjust=False).mean()\n        ema_slow = price.ewm(span=slow, adjust=False).mean()\n        return ema_fast - ema_slow\n    \n    def rsi(series, periods=14):\n        delta = series.diff(1)\n        up, down = delta.copy(), delta.copy()\n        up[up < 0] = 0\n        down[down > 0] = 0\n        roll_up = up.rolling(window=periods).mean()\n        roll_down = down.abs().rolling(window=periods).mean()\n        rs = roll_up / roll_down\n        return 100.0 - (100.0 / (1.0 + rs))\n    \n    macd_signal = macd_line(df['close'])\n    rsi_volume = rsi(df['volume'])\n    heuristics_matrix = (macd_signal * rsi_volume).rename('heuristic_factor')\n    \n    return heuristics_matrix",
          "objective": -0.02559,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a novel factor by combining momentum, volatility, and trading volume indicators to generate a heuristics matrix that could predict future stock returns.",
          "code": "def heuristics_v2(df):\n    # Calculate 10-day return (momentum)\n    df['Momentum'] = df['close'].pct_change(10)\n    \n    # Calculate 10-day standard deviation (volatility)\n    df['Volatility'] = df['close'].rolling(window=10).std()\n    \n    # Calculate 10-day average volume\n    df['Volume_avg'] = df['volume'].rolling(window=10).mean()\n    \n    # Generate the heuristics factor\n    df['Heuristic_Factor'] = (df['Momentum'] / df['Volatility']) * df['Volume_avg']\n    \n    heuristics_matrix = df['Heuristic_Factor'].dropna()\n    return heuristics_matrix",
          "objective": -0.0195,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates the average of the positive and negative differences between the close price and a moving average of the high and low prices, then subtracts the result from the volume to create a heuristic factor.",
          "code": "def heuristics_v2(df):\n    ma_high_low = (df['high'] + df['low']) / 2\n    positive_diff = (df['close'] - ma_high_low).apply(lambda x: x if x > 0 else 0)\n    negative_diff = (df['close'] - ma_high_low).apply(lambda x: x if x < 0 else 0)\n    avg_positive = positive_diff.rolling(window=10).mean()\n    avg_negative = negative_diff.rolling(window=10).mean()\n    heuristics_matrix = df['volume'] - (avg_positive + avg_negative) / 2\n    return heuristics_matrix",
          "objective": -0.01607,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates the momentum of the closing price over a 20-day period and combines it with the 5-day moving average of the trading volume to create a novel alpha factor.",
          "code": "def heuristics_v2(df):\n    close_momentum = df['close'].pct_change(periods=20)\n    volume_avg_5 = df['volume'].rolling(window=5).mean()\n    heuristics_matrix = (close_momentum + volume_avg_5.shift(1)).dropna()\n    return heuristics_matrix",
          "objective": -0.01516,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates the weighted moving average of price and volume changes over different time periods to generate alpha factors, with weights adjusted based on market volatility.",
          "code": "def heuristics_v2(df):\n    # Calculate the daily return and change in volume\n    df['return'] = df['close'].pct_change()\n    df['volume_change'] = df['volume'].pct_change()\n    \n    # Calculate the standard deviation (volatility) of returns for a given window\n    df['volatility'] = df['return'].rolling(window=30).std()\n    \n    # Adjusted weights for the moving averages based on inverse of volatility\n    df['weight'] = 1 / df['volatility']\n    \n    # Creating a series of heuristic factors by combining weighted moving averages of price and volume changes\n    heuristics_matrix = (df['return'].rolling(window=5).mean() * df['weight']).fillna(0) + (df['volume_change'].rolling(window=5).mean() * df['weight']).fillna(0)\n    \n    return heuristics_matrix",
          "objective": -0.01489,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates the weighted moving average of price and volume differences, then applies a custom heuristic to generate a predictive factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the difference between close and open prices\n    price_diff = df['close'] - df['open']\n    # Calculate the daily change in volume\n    volume_diff = df['volume'].diff(1)\n    # Compute a simple weighted combination for demonstration\n    combined = 0.7 * price_diff + 0.3 * volume_diff\n    # Apply a custom heuristic (e.g., square root for non-linearity)\n    heuristics_matrix = combined.apply(lambda x: x**0.5 if x > 0 else -(-x)**0.5)\n    return heuristics_matrix",
          "objective": -0.01227,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm involves calculating a novel heuristic score for each date by combining the relative strength of the close price with volume, and adjusting it based on the deviation from the average high and low prices over a rolling window.",
          "code": "def heuristics_v2(df):\n    heuristics_matrix = (df['close'] - df['open']) / df['open'] * df['volume'] + (df['high'].rolling(window=10).mean() - df['low'].rolling(window=10).mean())\n    return heuristics_matrix",
          "objective": -0.00984,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a novel heuristic factor based on the relationship between volume and price movement, using a rolling window to capture recent trends and integrating it with the rate of change in closing prices.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the rate of change (ROC) for the closing prices\n    roc = df['close'].pct_change()\n    \n    # Calculate the rolling mean of the volume over a 10-day window\n    vol_mean = df['volume'].rolling(window=10).mean()\n    \n    # Compute the volume trend by comparing current volume to its 10-day average\n    vol_trend = df['volume'] / vol_mean\n    \n    # Combine ROC and volume trend to create the heuristics matrix\n    heuristics_matrix = (roc + vol_trend) / 2\n    \n    return heuristics_matrix",
          "objective": -0.00429,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm, named AlphaHeuristics, constructs novel alpha factors by combining price and volume data through a series of weighted moving averages and their ratios to capture momentum and reversal signals in the market.",
          "code": "def heuristics_v2(df):\n    short_window = 5\n    long_window = 20\n    close_prices = df['close']\n    volumes = df['volume']\n    \n    short_mavg_close = close_prices.rolling(window=short_window).mean()\n    long_mavg_close = close_prices.rolling(window=long_window).mean()\n    short_mavg_volume = volumes.rolling(window=short_window).mean()\n    long_mavg_volume = volumes.rolling(window=long_window).mean()\n    \n    close_momentum = (short_mavg_close - long_mavg_close) / long_mavg_close\n    volume_momentum = (short_mavg_volume - long_mavg_volume) / long_mavg_volume\n    \n    heuristics_matrix = (close_momentum * volume_momentum).dropna()\n    \n    return heuristics_matrix",
          "objective": -0.00397,
          "other_inf": null
     }
]