[
     {
          "algorithm": "The new algorithm calculates a composite factor by combining the difference between the fast and slow exponential moving averages of the closing price (MACD line) with the rate of change (ROC) of the high price, then adjusting this combined value by its own exponential moving average to generate a smoothed heuristic factor.",
          "code": "def heuristics_v2(df):\n    def macd_line(price, fast=10, slow=30):\n        ema_fast = price.ewm(span=fast, adjust=False).mean()\n        ema_slow = price.ewm(span=slow, adjust=False).mean()\n        return ema_fast - ema_slow\n\n    def roc(series, periods=20):\n        return series.pct_change(periods=periods)\n\n    macd_signal = macd_line(df['close'])\n    roc_high = roc(df['high'])\n    combined_factor = (macd_signal + roc_high).rename('combined_factor')\n    heuristics_matrix = combined_factor.ewm(span=18, adjust=False).mean().rename('heuristic_factor')\n\n    return heuristics_matrix",
          "objective": -0.0339,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm introduces a smoothing effect on the momentum and volatility through exponential moving averages, then combines these with a weighted average volume over 10 days to generate a more stable heuristic factor.",
          "code": "def heuristics_v2(df):\n    # Calculate 10-day exponential moving average for return (momentum)\n    df['Momentum'] = df['close'].pct_change().ewm(span=10, adjust=False).mean()\n    \n    # Calculate 10-day exponential moving average for standard deviation (volatility)\n    df['Volatility'] = df['close'].rolling(window=10).std().ewm(span=10, adjust=False).mean()\n    \n    # Calculate 10-day weighted average volume\n    df['Volume_avg'] = df['volume'].ewm(span=10, adjust=False).mean()\n    \n    # Generate the heuristics factor\n    df['Heuristic_Factor'] = (df['Momentum'] / df['Volatility']) * df['Volume_avg']\n    \n    heuristics_matrix = df['Heuristic_Factor'].dropna()\n    return heuristics_matrix",
          "objective": -0.03267,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by combining the difference between the fast and slow exponential moving averages of the closing price (MACD line) with the rate of change (ROC) of the volume, then adjusting this combined value by its own exponential moving average to generate a smoothed heuristic factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def macd_line(price, fast=12, slow=26):\n        ema_fast = price.ewm(span=fast, adjust=False).mean()\n        ema_slow = price.ewm(span=slow, adjust=False).mean()\n        return ema_fast - ema_slow\n\n    def roc(series, periods=14):\n        return series.pct_change(periods=periods)\n\n    macd_signal = macd_line(df['close'])\n    roc_volume = roc(df['volume'])\n    combined_factor = (macd_signal + roc_volume).rename('combined_factor')\n    heuristics_matrix = combined_factor.ewm(span=9, adjust=False).mean().rename('heuristic_factor')\n\n    return heuristics_matrix",
          "objective": -0.03049,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a momentum-based alpha factor by first computing the exponential moving average (EMA) of daily returns over a short window, then subtracting the EMA of daily returns over a longer window to highlight the trend acceleration.",
          "code": "def heuristics_v2(df):\n    short_window = 5\n    long_window = 20\n    df['short_ema_momentum'] = df['close'].pct_change().ewm(span=short_window, adjust=False).mean()\n    df['long_ema_momentum'] = df['close'].pct_change().ewm(span=long_window, adjust=False).mean()\n    heuristics_matrix = df['short_ema_momentum'] - df['long_ema_momentum']\n    return heuristics_matrix",
          "objective": -0.02987,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a momentum-based alpha factor by first computing the average daily return over a short window, then subtracting the average daily return over a longer window to identify the acceleration in the stock's price trend.",
          "code": "def heuristics_v2(df):\n    short_window = 5\n    long_window = 20\n    df['short_momentum'] = df['close'].pct_change().rolling(window=short_window).mean()\n    df['long_momentum'] = df['close'].pct_change().rolling(window=long_window).mean()\n    heuristics_matrix = df['short_momentum'] - df['long_momentum']\n    return heuristics_matrix",
          "objective": -0.02851,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a composite factor by computing the MACD between the closing price and its exponential moving average, then multiplying it by the RSI of the adjusted volume, using a different set of parameters for the MACD and RSI calculations.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def macd_line(price, fast=9, slow=21):\n        ema_fast = price.ewm(span=fast, adjust=False).mean()\n        ema_slow = price.ewm(span=slow, adjust=False).mean()\n        return ema_fast - ema_slow\n    \n    def rsi(series, periods=9):\n        delta = series.diff(1)\n        up, down = delta.copy(), delta.copy()\n        up[up < 0] = 0\n        down[down > 0] = 0\n        roll_up = up.rolling(window=periods).mean()\n        roll_down = down.abs().rolling(window=periods).mean()\n        rs = roll_up / roll_down\n        return 100.0 - (100.0 / (1.0 + rs))\n    \n    macd_signal = macd_line(df['close'])\n    rsi_volume = rsi(df['volume'])\n    heuristics_matrix = (macd_signal * rsi_volume).rename('heuristic_factor')\n    \n    return heuristics_matrix",
          "objective": -0.02594,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a composite factor by calculating the moving average convergence divergence (MACD) between the closing price and its exponential moving average, then adjusting it based on the relative strength index (RSI) of the volume, aiming to generate interpretable alpha factors for stock return prediction.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def macd_line(price, fast=12, slow=26):\n        ema_fast = price.ewm(span=fast, adjust=False).mean()\n        ema_slow = price.ewm(span=slow, adjust=False).mean()\n        return ema_fast - ema_slow\n    \n    def rsi(series, periods=14):\n        delta = series.diff(1)\n        up, down = delta.copy(), delta.copy()\n        up[up < 0] = 0\n        down[down > 0] = 0\n        roll_up = up.rolling(window=periods).mean()\n        roll_down = down.abs().rolling(window=periods).mean()\n        rs = roll_up / roll_down\n        return 100.0 - (100.0 / (1.0 + rs))\n    \n    macd_signal = macd_line(df['close'])\n    rsi_volume = rsi(df['volume'])\n    heuristics_matrix = (macd_signal * rsi_volume).rename('heuristic_factor')\n    \n    return heuristics_matrix",
          "objective": -0.02559,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a 20-day exponential moving average for momentum, a 20-day exponential moving average for volatility, and incorporates a 20-day weighted average volume to form a more refined heuristic factor.",
          "code": "def heuristics_v2(df):\n    # Calculate 20-day exponential moving average for return (momentum)\n    df['Momentum'] = df['close'].pct_change().ewm(span=20, adjust=False).mean()\n    \n    # Calculate 20-day exponential moving average for standard deviation (volatility)\n    df['Volatility'] = df['close'].rolling(window=20).std().ewm(span=20, adjust=False).mean()\n    \n    # Calculate 20-day weighted average volume\n    df['Volume_avg'] = df['volume'].ewm(span=20, adjust=False).mean()\n    \n    # Generate the heuristics factor\n    df['Heuristic_Factor'] = (df['Momentum'] / df['Volatility']) * df['Volume_avg']\n    \n    heuristics_matrix = df['Heuristic_Factor'].dropna()\n    return heuristics_matrix",
          "objective": -0.02439,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm introduces a smoothing effect on the momentum and volatility through exponential moving averages over 20 days, then combines these with a weighted average volume over 30 days to generate a more stable heuristic factor.",
          "code": "def heuristics_v2(df):\n    # Calculate 20-day exponential moving average for return (momentum)\n    df['Momentum'] = df['close'].pct_change().ewm(span=20, adjust=False).mean()\n    \n    # Calculate 20-day exponential moving average for standard deviation (volatility)\n    df['Volatility'] = df['close'].rolling(window=20).std().ewm(span=20, adjust=False).mean()\n    \n    # Calculate 30-day weighted average volume\n    df['Volume_avg'] = df['volume'].ewm(span=30, adjust=False).mean()\n    \n    # Generate the heuristics factor\n    df['Heuristic_Factor'] = (df['Momentum'] / df['Volatility']) * df['Volume_avg']\n    \n    heuristics_matrix = df['Heuristic_Factor'].dropna()\n    return heuristics_matrix",
          "objective": -0.02423,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a volatility-adjusted relative strength index (RSI) by first calculating the RSI, then scaling it by the average true range (ATR) over a specified period.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the price change and its absolute value\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).fillna(0)\n    loss = (-delta.where(delta < 0, 0)).fillna(0)\n    \n    # Calculate the average gain and loss over a 14-day period\n    avg_gain = gain.rolling(window=14).mean()\n    avg_loss = loss.rolling(window=14).mean()\n    \n    # Compute the RS and RSI\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate the True Range\n    tr1 = df['high'] - df['low']\n    tr2 = abs(df['high'] - df['close'].shift())\n    tr3 = abs(df['low'] - df['close'].shift())\n    true_range = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)\n    \n    # Calculate the Average True Range (ATR) over a 14-day period\n    atr = true_range.rolling(window=14).mean()\n    \n    # Scale the RSI by the ATR to get the final heuristic matrix\n    heuristics_matrix = rsi / atr\n    return heuristics_matrix",
          "objective": -0.02405,
          "other_inf": null
     }
]