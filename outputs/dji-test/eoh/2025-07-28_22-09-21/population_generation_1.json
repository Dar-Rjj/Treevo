[
     {
          "algorithm": "The new algorithm integrates the rate of change in closing prices with a modified volume RSI, calculated using the median and interquartile range instead of mean and standard deviation, then scales it by ATR to forecast future stock returns.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change()\n    df['volume_median'] = df['volume'].rolling(window=14).median()\n    q1 = df['volume'].rolling(window=14).quantile(0.25)\n    q3 = df['volume'].rolling(window=14).quantile(0.75)\n    iqr = q3 - q1\n    df['volume_rsi'] = 100 - (100 / (1 + (df['volume_median'] / iqr)))\n    df['atr'] = df['high'].rolling(window=14).max() - df['low'].rolling(window=14).min()\n    heuristics_matrix = (df['price_change'].shift(-1) * df['volume_rsi']) / df['atr']\n    return heuristics_matrix",
          "objective": -0.29009,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a novel factor by integrating the rate of change in closing prices with the relative strength index (RSI) of trading volumes, then scales it using the average true range (ATR) to predict future stock returns.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change()\n    df['volume_rsi'] = 100 - (100 / (1 + (df['volume'].rolling(window=14).mean() / df['volume'].rolling(window=14).std())))\n    df['atr'] = df['high'].rolling(window=14).max() - df['low'].rolling(window=14).min()\n    heuristics_matrix = (df['price_change'].shift(-1) * df['volume_rsi']) / df['atr']\n    return heuristics_matrix",
          "objective": -0.28909,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor by combining the 5-day momentum of price changes with the 10-day average trading volume, adjusted for 30-day volatility, to predict future stock returns.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change(periods=5)\n    df['avg_volume'] = df['volume'].rolling(window=10).mean()\n    df['volatility'] = df['close'].rolling(window=30).std()\n    heuristics_matrix = (df['price_change'].shift(-1) * df['avg_volume']) / df['volatility']\n    return heuristics_matrix",
          "objective": -0.12723,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm involves calculating a novel factor by combining the momentum of price changes with trading volume variations, then adjusting for volatility, to forecast future stock returns.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change()\n    df['volume_change'] = df['volume'].pct_change()\n    df['volatility'] = df['close'].rolling(window=20).std()\n    heuristics_matrix = (df['price_change'].shift(-1) * df['volume_change']) / df['volatility']\n    return heuristics_matrix",
          "objective": -0.07263,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm generates a factor by combining the 20-day and 50-day simple moving averages (SMA) of the closing prices, then adjusts it with the ratio of the current day's volume to the 10-day SMA of volumes, to capture both long-term price trends and short-term trading activity.",
          "code": "def heuristics_v2(df):\n    close_prices = df['close']\n    volumes = df['volume']\n    \n    sma_20_close = close_prices.rolling(window=20).mean()\n    sma_50_close = close_prices.rolling(window=50).mean()\n    sma_10_volume = volumes.rolling(window=10).mean()\n    \n    volume_ratio = volumes / sma_10_volume\n    \n    heuristics_matrix = (sma_20_close - sma_50_close) * volume_ratio\n    \n    return heuristics_matrix",
          "objective": -0.03953,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a novel factor by integrating the momentum of closing prices with the volume rate-of-change, then scales it using the mean true range (MTR) to predict future stock returns.",
          "code": "def heuristics_v2(df):\n    df['price_momentum'] = df['close'].pct_change(periods=5)\n    df['volume_roc'] = df['volume'].pct_change(periods=10)\n    df['mtr'] = (df['high'] - df['low']).rolling(window=14).mean()\n    heuristics_matrix = (df['price_momentum'].shift(-1) * df['volume_roc']) / df['mtr']\n    return heuristics_matrix",
          "objective": -0.03921,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the factor by taking the ratio of the 30-day exponential moving average (EMA) of the closing prices to the standard deviation of the closing prices over a 40-day window, aiming to capture a smoother trend-to-volatility relationship.",
          "code": "def heuristics_v2(df):\n    close_prices = df['close']\n    \n    ema_30_close = close_prices.ewm(span=30, adjust=False).mean()\n    std_40_close = close_prices.rolling(window=40).std()\n    \n    heuristics_matrix = ema_30_close / std_40_close\n    \n    return heuristics_matrix",
          "objective": -0.03768,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm creates a factor by combining the 20-day and 50-day simple moving averages (SMA) of the closing prices, adjusted by the ratio of the current day's volume to the 10-day EMA of volumes, to reflect long-term price trends with short-term trading activity.",
          "code": "def heuristics_v2(df):\n    close_prices = df['close']\n    volumes = df['volume']\n    \n    sma_20_close = close_prices.rolling(window=20).mean()\n    sma_50_close = close_prices.rolling(window=50).mean()\n    ema_10_volume = volumes.ewm(span=10, adjust=False).mean()\n    \n    volume_ratio = volumes / ema_10_volume\n    \n    heuristics_matrix = (sma_20_close - sma_50_close) * volume_ratio\n    \n    return heuristics_matrix",
          "objective": -0.03756,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes the factor by taking the ratio of the 20-day exponential moving average (EMA) of the closing prices to the standard deviation of the closing prices over a 30-day window, aiming to capture a trend-to-volatility relationship.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    close_prices = df['close']\n    \n    ema_20_close = close_prices.ewm(span=20, adjust=False).mean()\n    std_30_close = close_prices.rolling(window=30).std()\n    \n    heuristics_matrix = ema_20_close / std_30_close\n    \n    return heuristics_matrix",
          "objective": -0.03708,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm generates a factor by calculating the difference between the 20-day and 50-day simple moving averages of closing prices, then multiplying this difference by the ratio of the 10-day EMA of high prices to the 10-day EMA of low prices, to capture the relationship between long-term price trends and short-term price volatility.",
          "code": "def heuristics_v2(df):\n    close_prices = df['close']\n    high_prices = df['high']\n    low_prices = df['low']\n    \n    sma_20_close = close_prices.rolling(window=20).mean()\n    sma_50_close = close_prices.rolling(window=50).mean()\n    ema_10_high = high_prices.ewm(span=10, adjust=False).mean()\n    ema_10_low = low_prices.ewm(span=10, adjust=False).mean()\n    \n    price_volatility_ratio = ema_10_high / ema_10_low\n    \n    heuristics_matrix = (sma_20_close - sma_50_close) * price_volatility_ratio\n    \n    return heuristics_matrix",
          "objective": -0.03431,
          "other_inf": null
     }
]