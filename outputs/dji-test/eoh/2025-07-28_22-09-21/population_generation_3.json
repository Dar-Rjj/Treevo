[
     {
          "algorithm": "The new algorithm integrates the rate of change in closing prices with a modified volume RSI, using the 30-day rolling window for calculations and adjusting the final score by dividing it with the ATR calculated over a 28-day period.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change()\n    df['volume_median'] = df['volume'].rolling(window=30).median()\n    q1 = df['volume'].rolling(window=30).quantile(0.25)\n    q3 = df['volume'].rolling(window=30).quantile(0.75)\n    iqr = q3 - q1\n    df['volume_rsi'] = 100 - (100 / (1 + (df['volume_median'] / iqr)))\n    df['atr'] = df['high'].rolling(window=28).max() - df['low'].rolling(window=28).min()\n    heuristics_matrix = (df['price_change'].shift(-1) * df['volume_rsi']) / df['atr']\n    return heuristics_matrix",
          "objective": -0.29307,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm integrates the rate of change in closing prices with a modified volume ratio, using a 30-day rolling window for calculations and adjusting the final score by dividing it with the standard deviation of closing prices over a 28-day period.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change()\n    df['volume_median'] = df['volume'].rolling(window=30).median()\n    df['volume_mean'] = df['volume'].rolling(window=30).mean()\n    df['volume_ratio'] = df['volume_median'] / df['volume_mean']\n    df['std_dev_close'] = df['close'].rolling(window=28).std()\n    heuristics_matrix = (df['price_change'].shift(-1) * df['volume_ratio']) / df['std_dev_close']\n    return heuristics_matrix",
          "objective": -0.29134,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a modified volume RSI using the interquartile range of volumes, combines it with the rate of change in closing prices, and adjusts the final score by dividing it with the ATR calculated over a 14-day period.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change()\n    df['volume_median'] = df['volume'].rolling(window=30).median()\n    q1 = df['volume'].rolling(window=30).quantile(0.25)\n    q3 = df['volume'].rolling(window=30).quantile(0.75)\n    iqr = q3 - q1\n    df['volume_rsi'] = 100 - (100 / (1 + (df['volume_median'] / iqr)))\n    df['atr'] = df['high'].rolling(window=14).max() - df['low'].rolling(window=14).min()\n    heuristics_matrix = (df['price_change'].shift(-1) * df['volume_rsi']) / df['atr']\n    return heuristics_matrix",
          "objective": -0.29087,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the rate of change in closing prices, then constructs a modified volume RSI using the 20-day median and interquartile range, and scales it by the 10-day ATR to predict future stock returns.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change()\n    df['volume_median'] = df['volume'].rolling(window=20).median()\n    q1 = df['volume'].rolling(window=20).quantile(0.25)\n    q3 = df['volume'].rolling(window=20).quantile(0.75)\n    iqr = q3 - q1\n    df['volume_rsi'] = 100 - (100 / (1 + (df['volume_median'] / iqr)))\n    df['atr'] = (df['high'].rolling(window=10).max() - df['low'].rolling(window=10).min()) / 10\n    heuristics_matrix = (df['price_change'].shift(-1) * df['volume_rsi']) / df['atr']\n    return heuristics_matrix",
          "objective": -0.29065,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm integrates the rate of change in closing prices with a modified volume ratio, using a 20-day rolling window for calculations and adjusting the final score by dividing it with the standard deviation of closing prices over a 25-day period.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change()\n    df['volume_median'] = df['volume'].rolling(window=20).median()\n    df['volume_mean'] = df['volume'].rolling(window=20).mean()\n    df['volume_ratio'] = df['volume_median'] / df['volume_mean']\n    df['std_dev_close'] = df['close'].rolling(window=25).std()\n    heuristics_matrix = (df['price_change'].shift(-1) * df['volume_ratio']) / df['std_dev_close']\n    return heuristics_matrix",
          "objective": -0.29036,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm integrates the rate of change in closing prices with a modified volume RSI, calculated using the median and interquartile range instead of mean and standard deviation, then scales it by ATR to forecast future stock returns.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change()\n    df['volume_median'] = df['volume'].rolling(window=14).median()\n    q1 = df['volume'].rolling(window=14).quantile(0.25)\n    q3 = df['volume'].rolling(window=14).quantile(0.75)\n    iqr = q3 - q1\n    df['volume_rsi'] = 100 - (100 / (1 + (df['volume_median'] / iqr)))\n    df['atr'] = df['high'].rolling(window=14).max() - df['low'].rolling(window=14).min()\n    heuristics_matrix = (df['price_change'].shift(-1) * df['volume_rsi']) / df['atr']\n    return heuristics_matrix",
          "objective": -0.29009,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes the rate of change in closing prices, calculates a modified volume RSI using the 20th and 80th percentiles, and scales the result by ATR to predict stock returns.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change()\n    df['volume_median'] = df['volume'].rolling(window=14).median()\n    q8 = df['volume'].rolling(window=14).quantile(0.8)\n    q2 = df['volume'].rolling(window=14).quantile(0.2)\n    idr = q8 - q2\n    df['volume_rsi'] = 100 - (100 / (1 + (df['volume_median'] / idr)))\n    df['atr'] = (df['high'].rolling(window=14).max() - df['low'].rolling(window=14).min()) / 2\n    heuristics_matrix = (df['price_change'].shift(-1) * df['volume_rsi']) / df['atr']\n    return heuristics_matrix",
          "objective": -0.2891,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a novel factor by integrating the rate of change in closing prices with the relative strength index (RSI) of trading volumes, then scales it using the average true range (ATR) to predict future stock returns.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change()\n    df['volume_rsi'] = 100 - (100 / (1 + (df['volume'].rolling(window=14).mean() / df['volume'].rolling(window=14).std())))\n    df['atr'] = df['high'].rolling(window=14).max() - df['low'].rolling(window=14).min()\n    heuristics_matrix = (df['price_change'].shift(-1) * df['volume_rsi']) / df['atr']\n    return heuristics_matrix",
          "objective": -0.28909,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes the rate of change in closing prices, calculates a modified volume RSI using the 50th percentile and interdecile range, and scales the result by ATR to predict stock returns.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change()\n    df['volume_median'] = df['volume'].rolling(window=14).median()\n    q9 = df['volume'].rolling(window=14).quantile(0.9)\n    q10 = df['volume'].rolling(window=14).quantile(0.1)\n    idr = q9 - q10\n    df['volume_rsi'] = 100 - (100 / (1 + (df['volume_median'] / idr)))\n    df['atr'] = (df['high'].rolling(window=14).max() - df['low'].rolling(window=14).min()) / 2\n    heuristics_matrix = (df['price_change'].shift(-1) * df['volume_rsi']) / df['atr']\n    return heuristics_matrix",
          "objective": -0.28621,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm combines the rate of change in closing prices with a measure of volume consistency, adjusted by the average true range (ATR) over a 20-day window to predict future stock returns.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change()\n    df['volume_consistency'] = 1 / (df['volume'].rolling(window=20).std() + 1e-6)\n    df['atr'] = (df['high'] - df['low']).rolling(window=20).mean()\n    heuristics_matrix = (df['price_change'].shift(-1) * df['volume_consistency']) / df['atr']\n    return heuristics_matrix",
          "objective": -0.27993,
          "other_inf": null
     }
]