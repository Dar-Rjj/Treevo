[
     {
          "algorithm": "The new algorithm modifies the original by incorporating a 21-day average true range (ATR) and adjusting the VWAP calculation to weigh more on the closing price.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change()\n    df['vwap'] = (df['volume'] * (df['high'] + df['low'] + 2*df['close']) / 4).cumsum() / df['volume'].cumsum()\n    df['atr'] = df[['high', 'low']].diff().abs().max(axis=1).rolling(window=21).mean()\n    heuristics_matrix = (df['price_change'].shift(-1) * df['vwap']) / df['atr']\n    return heuristics_matrix",
          "objective": -0.38011,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm integrates the rate of change in closing prices with a modified volume-weighted average price (VWAP) and scales it by the average true range (ATR) over a 14-day period.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change()\n    df['vwap'] = (df['volume'] * (df['high'] + df['low'] + df['close']) / 3).cumsum() / df['volume'].cumsum()\n    df['atr'] = df[['high', 'low']].diff().abs().max(axis=1).rolling(window=14).mean()\n    heuristics_matrix = (df['price_change'].shift(-1) * df['vwap']) / df['atr']\n    return heuristics_matrix",
          "objective": -0.37794,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm integrates the rate of change in closing prices with a modified volume-weighted average price (VWAP), calculated over a 14-day window, and adjusts the final score by dividing it with the range (high minus low) over the same period.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change()\n    df['vwap'] = (df['volume'] * (df['high'] + df['low'] + df['close']) / 3).rolling(window=14).sum() / df['volume'].rolling(window=14).sum()\n    df['range'] = df['high'].rolling(window=14).max() - df['low'].rolling(window=14).min()\n    heuristics_matrix = (df['price_change'].shift(-1) * df['vwap']) / df['range']\n    return heuristics_matrix",
          "objective": -0.3709,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a novel factor by combining the rate of change in closing prices with the ratio of the current volume to the 30-day moving average of volumes, and then weights it by the 14-day exponential moving average (EMA) of the true range, aiming to capture more dynamic volatility adjustments.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change()\n    df['volume_ma'] = df['volume'].rolling(window=30).mean()\n    df['volume_ratio'] = df['volume'] / df['volume_ma']\n    df['true_range'] = df['high'] - df['low']\n    df['atr_ema'] = df['true_range'].ewm(span=14, adjust=False).mean()\n    heuristics_matrix = (df['price_change'].shift(-1) * df['volume_ratio']) * df['atr_ema']\n    return heuristics_matrix",
          "objective": -0.30907,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm integrates the rate of change in closing prices with a modified volume-weighted average price (VWAP) and scales it by the 14-day standard deviation of daily returns.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change()\n    df['vwap'] = (df['volume'] * (df['high'] + df['low'] + df['close']) / 3).cumsum() / df['volume'].cumsum()\n    df['std_dev'] = df['close'].pct_change().rolling(window=14).std()\n    heuristics_matrix = (df['price_change'].shift(-1) * df['vwap']) / df['std_dev']\n    return heuristics_matrix",
          "objective": -0.30471,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the weighted rate of change in closing prices, constructs a modified volume RSI using the 20-day mean and standard deviation, and scales it by the 10-day True Range to predict future stock returns.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change() * (df['volume'] / df['volume'].rolling(window=20).mean())\n    df['volume_mean'] = df['volume'].rolling(window=20).mean()\n    df['volume_std'] = df['volume'].rolling(window=20).std()\n    df['volume_rsi'] = 100 - (100 / (1 + (df['volume_mean'] / df['volume_std'])))\n    df['true_range'] = df[['high', 'low']].diff().abs().max(axis=1).rolling(window=10).sum()\n    heuristics_matrix = (df['price_change'].shift(-1) * df['volume_rsi']) / df['true_range']\n    return heuristics_matrix",
          "objective": -0.30456,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a novel factor by combining the rate of change in closing prices with the ratio of the current volume to the 30-day moving average of volumes, and then scales it using the 14-day average true range (ATR).",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change()\n    df['volume_ma'] = df['volume'].rolling(window=30).mean()\n    df['volume_ratio'] = df['volume'] / df['volume_ma']\n    df['atr'] = (df['high'] - df['low']).rolling(window=14).mean()\n    heuristics_matrix = (df['price_change'].shift(-1) * df['volume_ratio']) / df['atr']\n    return heuristics_matrix",
          "objective": -0.29938,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm integrates the rate of change in closing prices with a modified volume RSI, using a 60-day rolling window for calculations and adjusting the final score by dividing it with the ATR calculated over a 56-day period.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change()\n    df['volume_median'] = df['volume'].rolling(window=60).median()\n    q1 = df['volume'].rolling(window=60).quantile(0.25)\n    q3 = df['volume'].rolling(window=60).quantile(0.75)\n    iqr = q3 - q1\n    df['volume_rsi'] = 100 - (100 / (1 + (df['volume_median'] / iqr)))\n    df['atr'] = df['high'].rolling(window=56).max() - df['low'].rolling(window=56).min()\n    heuristics_matrix = (df['price_change'].shift(-1) * df['volume_rsi']) / df['atr']\n    return heuristics_matrix",
          "objective": -0.2978,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm integrates the rate of change in closing prices with a modified volume RSI, using the 30-day rolling window for calculations and adjusting the final score by dividing it with the ATR calculated over a 28-day period.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change()\n    df['volume_median'] = df['volume'].rolling(window=30).median()\n    q1 = df['volume'].rolling(window=30).quantile(0.25)\n    q3 = df['volume'].rolling(window=30).quantile(0.75)\n    iqr = q3 - q1\n    df['volume_rsi'] = 100 - (100 / (1 + (df['volume_median'] / iqr)))\n    df['atr'] = df['high'].rolling(window=28).max() - df['low'].rolling(window=28).min()\n    heuristics_matrix = (df['price_change'].shift(-1) * df['volume_rsi']) / df['atr']\n    return heuristics_matrix",
          "objective": -0.29307,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the exponential moving average (EMA) of price changes over a 15-day span and a modified volume ratio using a 30-day EMA, then adjusts the final score using the standard deviation of closing prices over a 20-day period.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change()\n    df['volume_ema'] = df['volume'].ewm(span=30, adjust=False).mean()\n    df['volume_ratio'] = df['volume'] / df['volume_ema']\n    df['std_dev_close'] = df['close'].rolling(window=20).std()\n    heuristics_matrix = (df['price_change'].shift(-1) * df['volume_ratio']) / df['std_dev_close']\n    return heuristics_matrix",
          "objective": -0.29258,
          "other_inf": null
     }
]