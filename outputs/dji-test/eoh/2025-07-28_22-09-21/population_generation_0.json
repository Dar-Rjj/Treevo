[
     {
          "algorithm": "The algorithm involves calculating a novel factor by combining the momentum of price changes with trading volume variations, then adjusting for volatility, to forecast future stock returns.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change()\n    df['volume_change'] = df['volume'].pct_change()\n    df['volatility'] = df['close'].rolling(window=20).std()\n    heuristics_matrix = (df['price_change'].shift(-1) * df['volume_change']) / df['volatility']\n    return heuristics_matrix",
          "objective": -0.07263,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies momentum and volatility patterns by combining price movement and volume data, generating a heuristics matrix that serves as an alpha factor for predicting future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the return from the close price\n    returns = df['close'].pct_change()\n    # Calculate the volume weighted average price (VWAP) for each day\n    vwap = (df['volume'] * (df['high'] + df['low']) / 2).cumsum() / df['volume'].cumsum()\n    # Generate the momentum heuristic using the 10-day and 30-day returns\n    momentum_10d = returns.rolling(window=10).mean()\n    momentum_30d = returns.rolling(window=30).mean()\n    # Generate the volatility heuristic using the 10-day returns standard deviation\n    volatility = returns.rolling(window=10).std()\n    # Combine heuristics into a single score\n    heuristics_matrix = momentum_10d - momentum_30d + volatility - vwap.pct_change()\n    return heuristics_matrix",
          "objective": -0.02357,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a heuristic factor based on the combination of moving average crossovers and relative strength index (RSI), where the factor values are determined by the interaction between short-term and long-term moving averages along with RSI to predict momentum and mean-reversion signals.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    short_window = 10\n    long_window = 50\n    rsi_window = 14\n    \n    # Calculate Short and Long Moving Averages\n    df['SMA_Short'] = df['close'].rolling(window=short_window, min_periods=1).mean()\n    df['SMA_Long'] = df['close'].rolling(window=long_window, min_periods=1).mean()\n    \n    # Calculate Daily Price Change\n    delta = df['close'].diff(1)\n    \n    # Make two series: one for lower closes and one for higher closes\n    up, down = delta.copy(), delta.copy()\n    up[up < 0] = 0\n    down[down > 0] = 0\n    \n    # Calculate Average Gain and Loss\n    avg_gain = up.rolling(window=rsi_window, min_periods=1).mean()\n    avg_loss = abs(down.rolling(window=rsi_window, min_periods=1).mean())\n    \n    # Calculate Relative Strength (RS) and RSI\n    rs = avg_gain / avg_loss\n    rsi = 100.0 - (100.0 / (1.0 + rs))\n    \n    # Define Heuristic Factor\n    heuristics_matrix = (df['SMA_Short'] - df['SMA_Long']) * rsi\n    \n    return heuristics_matrix",
          "objective": -0.02355,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies unique patterns in the historical price and volume data to construct a set of alpha factors by calculating the difference between the 10-day exponential moving average (EMA) of the closing prices and the 30-day EMA, then multiplying this difference by the 5-day EMA of the trading volumes, to generate a heuristics matrix.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    close_prices = df['close']\n    volumes = df['volume']\n    \n    ema_10_close = close_prices.ewm(span=10, adjust=False).mean()\n    ema_30_close = close_prices.ewm(span=30, adjust=False).mean()\n    ema_5_volume = volumes.ewm(span=5, adjust=False).mean()\n    \n    heuristics_matrix = (ema_10_close - ema_30_close) * ema_5_volume\n    \n    return heuristics_matrix",
          "objective": -0.01805,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies patterns in historical market data by calculating the difference between the average of the last n days' closing prices and the current day's closing price, then divides this difference by the standard deviation of the closing prices over the last n days to generate alpha factors.",
          "code": "def heuristics_v2(df):\n    n = 5  # example lookback period; can be adjusted\n    heuristics_matrix = (df['close'].rolling(window=n).mean() - df['close']) / df['close'].rolling(window=n).std()\n    return heuristics_matrix",
          "objective": -0.01539,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates the average of the positive and negative differences between the closing price and a moving average of the high and low prices, then scales this difference by the volume, to generate a novel alpha factor.",
          "code": "def heuristics_v2(df):\n    window = 20  # Define moving average window\n    ma_high_low = (df['high'] + df['low']) / 2.0  # Calculate simple moving average of high and low\n    ma_high_low = ma_high_low.rolling(window=window).mean()  # Apply rolling window to get actual moving average\n    diff = df['close'] - ma_high_low  # Difference between close and moving average\n    pos_diff = diff.apply(lambda x: x if x > 0 else 0)  # Positive part of the difference\n    neg_diff = diff.apply(lambda x: -x if x < 0 else 0)  # Negative part of the difference\n    avg_diff = (pos_diff + neg_diff) / 2.0  # Average of positive and negative differences\n    heuristics_matrix = avg_diff * df['volume']  # Scale by volume\n    return heuristics_matrix",
          "objective": -0.007,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies potential alpha factors by calculating the ratio of average trading volume over a 20-day period to the moving average convergence divergence (MACD) over the same period, aiming to capture momentum and liquidity signals.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    avg_volume = df['volume'].rolling(window=20).mean()\n    exp1 = df['close'].ewm(span=12, adjust=False).mean()\n    exp2 = df['close'].ewm(span=26, adjust=False).mean()\n    macd = exp1 - exp2\n    heuristics_matrix = avg_volume / macd\n    return heuristics_matrix",
          "objective": -0.00571,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm leverages a combination of moving average crossovers, momentum indicators, and volatility measures to generate a composite alpha factor without normalizing the data.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate short and long moving averages\n    short_ma = df['close'].rolling(window=5).mean()\n    long_ma = df['close'].rolling(window=20).mean()\n    \n    # Calculate momentum\n    momentum = df['close'].pct_change(periods=10)\n    \n    # Calculate ATR (Average True Range) for volatility\n    tr1 = df['high'] - df['low']\n    tr2 = abs(df['high'] - df['close'].shift())\n    tr3 = abs(df['low'] - df['close'].shift())\n    true_range = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)\n    atr = true_range.rolling(window=14).mean()\n    \n    # Composite heuristics factor\n    heuristics_matrix = (short_ma - long_ma) + momentum - atr\n    \n    return heuristics_matrix",
          "objective": -0.00444,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies patterns in the relationship between trading volume and price movements to generate alpha factors, by calculating the ratio of the difference between closing and opening prices to the average trading volume over a specified period.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'] - df['open']\n    df['avg_volume'] = df['volume'].rolling(window=10).mean()\n    heuristics_matrix = (df['price_change'] / df['avg_volume']).dropna()\n    return heuristics_matrix",
          "objective": -0.00376,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates the weighted moving average of the closing price with a dynamic window size based on the volume, and subtracts this from the simple moving average of the opening price over a fixed window, creating a novel alpha factor that aims to capture momentum and volatility elements.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Define a dynamic window size for the closing price WMA, influenced by daily volume\n    dynamic_window = (df['volume'].rolling(window=10).mean() / df['volume']).apply(lambda x: 5 if x > 1 else 10)\n    \n    # Calculate the Weighted Moving Average (WMA) of the close price using the dynamic window\n    wma_close = df['close'].rolling(window=dynamic_window.min()).apply(lambda x: (x * list(range(1, len(x)+1))).sum() / sum(list(range(1, len(x)+1))), raw=True)\n    \n    # Calculate the Simple Moving Average (SMA) of the open price over a fixed 10 day window\n    sma_open = df['open'].rolling(window=10).mean()\n    \n    # Compute the alpha factor as the difference between SMA of open and WMA of close\n    heuristics_matrix = sma_open - wma_close\n    \n    return heuristics_matrix",
          "objective": -0.00317,
          "other_inf": null
     }
]