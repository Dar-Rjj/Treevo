[
     {
          "algorithm": "The new algorithm integrates the rate of change in closing prices with a modified volume RSI, using the 30-day rolling window for calculations and adjusting the final score by dividing it with the ATR calculated over a 28-day period.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change()\n    df['volume_median'] = df['volume'].rolling(window=30).median()\n    q1 = df['volume'].rolling(window=30).quantile(0.25)\n    q3 = df['volume'].rolling(window=30).quantile(0.75)\n    iqr = q3 - q1\n    df['volume_rsi'] = 100 - (100 / (1 + (df['volume_median'] / iqr)))\n    df['atr'] = df['high'].rolling(window=28).max() - df['low'].rolling(window=28).min()\n    heuristics_matrix = (df['price_change'].shift(-1) * df['volume_rsi']) / df['atr']\n    return heuristics_matrix",
          "objective": -0.29307,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm integrates the rate of change in closing prices with a modified volume RSI, calculated using the median and interquartile range instead of mean and standard deviation, then scales it by ATR to forecast future stock returns.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change()\n    df['volume_median'] = df['volume'].rolling(window=14).median()\n    q1 = df['volume'].rolling(window=14).quantile(0.25)\n    q3 = df['volume'].rolling(window=14).quantile(0.75)\n    iqr = q3 - q1\n    df['volume_rsi'] = 100 - (100 / (1 + (df['volume_median'] / iqr)))\n    df['atr'] = df['high'].rolling(window=14).max() - df['low'].rolling(window=14).min()\n    heuristics_matrix = (df['price_change'].shift(-1) * df['volume_rsi']) / df['atr']\n    return heuristics_matrix",
          "objective": -0.29009,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a novel factor by integrating the rate of change in closing prices with the relative strength index (RSI) of trading volumes, then scales it using the average true range (ATR) to predict future stock returns.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change()\n    df['volume_rsi'] = 100 - (100 / (1 + (df['volume'].rolling(window=14).mean() / df['volume'].rolling(window=14).std())))\n    df['atr'] = df['high'].rolling(window=14).max() - df['low'].rolling(window=14).min()\n    heuristics_matrix = (df['price_change'].shift(-1) * df['volume_rsi']) / df['atr']\n    return heuristics_matrix",
          "objective": -0.28909,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes the rate of change in closing prices, calculates a modified volume RSI using the 50th percentile and interdecile range, and scales the result by ATR to predict stock returns.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change()\n    df['volume_median'] = df['volume'].rolling(window=14).median()\n    q9 = df['volume'].rolling(window=14).quantile(0.9)\n    q10 = df['volume'].rolling(window=14).quantile(0.1)\n    idr = q9 - q10\n    df['volume_rsi'] = 100 - (100 / (1 + (df['volume_median'] / idr)))\n    df['atr'] = (df['high'].rolling(window=14).max() - df['low'].rolling(window=14).min()) / 2\n    heuristics_matrix = (df['price_change'].shift(-1) * df['volume_rsi']) / df['atr']\n    return heuristics_matrix",
          "objective": -0.28621,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor by combining the momentum of price changes with the average trading volume over the last 20 days, then adjusts for volatility to forecast future stock returns.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change()\n    df['avg_volume'] = df['volume'].rolling(window=20).mean()\n    df['volatility'] = df['close'].rolling(window=20).std()\n    heuristics_matrix = (df['price_change'].shift(-1) * df['avg_volume']) / df['volatility']\n    return heuristics_matrix",
          "objective": -0.21216,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor by combining the 5-day momentum of price changes with the 20-day average trading volume, adjusted for the 60-day volatility, to predict future stock returns.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change(periods=5)\n    df['avg_volume'] = df['volume'].rolling(window=20).mean()\n    df['volatility'] = df['close'].rolling(window=60).std()\n    heuristics_matrix = (df['price_change'].shift(-1) * df['avg_volume']) / df['volatility']\n    return heuristics_matrix",
          "objective": -0.1329,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor by combining the 5-day momentum of price changes with the 10-day average trading volume, adjusted for 30-day volatility, to predict future stock returns.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change(periods=5)\n    df['avg_volume'] = df['volume'].rolling(window=10).mean()\n    df['volatility'] = df['close'].rolling(window=30).std()\n    heuristics_matrix = (df['price_change'].shift(-1) * df['avg_volume']) / df['volatility']\n    return heuristics_matrix",
          "objective": -0.12723,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm integrates the momentum of closing prices, measured by the rate of change over a 14-day period, with the normalized trading volume's relative strength index (RSI), and adjusts the result using the average true range (ATR) over the same period to produce a predictive factor for future stock returns.",
          "code": "def heuristics_v2(df):\n    df['momentum'] = df['close'].pct_change(14)\n    df['volume_rsi'] = 100 - (100 / (1 + (df['volume'].rolling(window=14).mean() / df['volume'].rolling(window=14).std())))\n    df['atr'] = (df['high'].rolling(window=14).max() - df['low'].rolling(window=14).min()) / 2\n    heuristics_matrix = (df['momentum'].shift(-1) * df['volume_rsi']) / df['atr']\n    return heuristics_matrix",
          "objective": -0.10594,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor by combining the 10-day momentum of price changes with the average trading volume over the last 30 days, and then adjusts for the 10-day volatility to forecast future stock returns.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change(periods=10)\n    df['avg_volume'] = df['volume'].rolling(window=30).mean()\n    df['volatility'] = df['close'].rolling(window=10).std()\n    heuristics_matrix = (df['price_change'].shift(-1) * df['avg_volume']) / df['volatility']\n    return heuristics_matrix",
          "objective": -0.09377,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor by combining the 10-day momentum of price changes with the 5-day average trading volume, adjusted for 20-day volatility, to predict future stock returns.",
          "code": "def heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change(periods=10)\n    df['avg_volume'] = df['volume'].rolling(window=5).mean()\n    df['volatility'] = df['close'].rolling(window=20).std()\n    heuristics_matrix = (df['price_change'].shift(-1) * df['avg_volume']) / df['volatility']\n    return heuristics_matrix",
          "objective": -0.0859,
          "other_inf": null
     }
]