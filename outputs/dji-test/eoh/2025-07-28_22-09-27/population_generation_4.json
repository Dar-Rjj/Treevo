[
     {
          "algorithm": "The new algorithm calculates a composite factor by first determining the ratio of the volume to the closing price, then subtracting the 100-day Exponential Moving Average (EMA) of this ratio from the 30-day EMA, capturing short-term deviations from a longer-term trend.",
          "code": "def heuristics_v2(df):\n    volume_price_ratio = df['volume'] / df['close']\n    ema_30 = volume_price_ratio.ewm(span=30, adjust=False).mean()\n    ema_100 = volume_price_ratio.ewm(span=100, adjust=False).mean()\n    heuristics_matrix = ema_30 - ema_100\n    return heuristics_matrix",
          "objective": -0.0511,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm modifies the EMA span to 20, changes the SMA window for mean reversion to 50 days, and alters the liquidity calculation to use a 90-day sum of volumes, adjusting the weights in the heuristics matrix.",
          "code": "def heuristics_v2(df):\n    # Calculate exponential moving average of returns with an adjusted span for momentum\n    returns = df['close'].pct_change()\n    ema_returns = returns.ewm(span=20, adjust=False).mean()\n    \n    # Mean reversion factor based on deviation from a 50-day SMA\n    sma_close = df['close'].rolling(window=50).mean()\n    mean_reversion_factor = (df['close'] - sma_close) / sma_close\n    \n    # Adjusted liquidity: sum of 90-day volumes divided by close price\n    liquidity = (df['volume'].rolling(window=90).sum() / df['close'])\n    \n    # Heuristics matrix with new weights\n    heuristics_matrix = 0.5 * ema_returns - 0.3 * mean_reversion_factor + 0.2 * liquidity\n    \n    return heuristics_matrix",
          "objective": -0.04685,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm adjusts the calculation of momentum by using a different span for EMA, adds a mean reversion factor based on the deviation of closing prices from their rolling mean, and revises the liquidity measure to consider the sum of volumes over a longer period, then combines these into a heuristics matrix with a new set of weights.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate exponential moving average of returns for adjusted momentum\n    returns = df['close'].pct_change()\n    ema_returns = returns.ewm(span=10, adjust=False).mean()\n    \n    # Calculate mean reversion factor as the difference between close price and 30-day SMA\n    sma_close = df['close'].rolling(window=30).mean()\n    mean_reversion_factor = (df['close'] - sma_close) / sma_close\n    \n    # Adjusted liquidity calculation: sum of volumes over 60 days divided by close price\n    liquidity = (df['volume'].rolling(window=60).sum() / df['close'])\n    \n    # Combine factors into a heuristics matrix using a weighted sum\n    heuristics_matrix = 0.4 * ema_returns - 0.4 * mean_reversion_factor + 0.2 * liquidity\n    \n    return heuristics_matrix",
          "objective": -0.04665,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by determining the ratio of the volume to the weighted average price (using different weights for high, low, and close prices), then applies a 50-day Exponential Moving Average (EMA) to this ratio.",
          "code": "def heuristics_v2(df):\n    w_avg_price = (0.3 * df['high'] + 0.2 * df['low'] + 0.5 * df['close'])\n    volume_w_avg_ratio = df['volume'] / w_avg_price\n    heuristics_matrix = volume_w_avg_ratio.ewm(span=50, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.04512,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by determining the ratio of the volume to the adjusted average price (using high, low, and twice the close price), then applies a 30-day Exponential Moving Average (EMA) to this ratio.",
          "code": "def heuristics_v2(df):\n    adj_avg_price = (df['high'] + df['low'] + 2 * df['close']) / 4\n    volume_adj_avg_ratio = df['volume'] / adj_avg_price\n    heuristics_matrix = volume_adj_avg_ratio.ewm(span=30, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.04429,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates alpha factors including momentum (exponential moving average of returns), volatility (average true range over a period), and liquidity (volume turnover ratio), then combines these into a heuristics matrix using a weighted sum with updated weights.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate exponential moving average of returns for momentum\n    returns = df['close'].pct_change()\n    ema_returns = returns.ewm(span=20, adjust=False).mean()\n    \n    # Calculate average true range for volatility\n    tr1 = df['high'] - df['low']\n    tr2 = (df['high'] - df['close'].shift()).abs()\n    tr3 = (df['low'] - df['close'].shift()).abs()\n    true_range = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)\n    atr = true_range.rolling(window=20).mean()\n    \n    # Calculate liquidity (volume divided by close price, then averaged over 20 days)\n    liquidity = (df['volume'] / df['close']).rolling(window=20).mean()\n    \n    # Combine factors into a heuristics matrix using a simple weighted sum\n    heuristics_matrix = 0.5 * ema_returns + 0.3 * atr + 0.2 * liquidity\n    \n    return heuristics_matrix",
          "objective": -0.04362,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by determining the ratio of the volume to the closing price, then applies a 20-day Exponential Moving Average (EMA) to this ratio.",
          "code": "def heuristics_v2(df):\n    volume_price_ratio = df['volume'] / df['close']\n    heuristics_matrix = volume_price_ratio.ewm(span=20, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.04359,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by determining the ratio of the volume to the average price, then applies a 20-day Exponential Moving Average (EMA) to this ratio.",
          "code": "def heuristics_v2(df):\n    avg_price = (df['high'] + df['low'] + df['close']) / 3\n    volume_avg_ratio = df['volume'] / avg_price\n    heuristics_matrix = volume_avg_ratio.ewm(span=20, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.04358,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by first determining the ratio of the volume to the opening price, then applies a 20-day Exponential Moving Average (EMA) to this ratio.",
          "code": "def heuristics_v2(df):\n    volume_price_ratio = df['volume'] / df['open']\n    heuristics_matrix = volume_price_ratio.ewm(span=20, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.04356,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by determining the ratio of the volume to the adjusted high price, where the adjusted high price is the average of the high and open prices, then applies a 20-day Exponential Moving Average (EMA) to this modified ratio.",
          "code": "def heuristics_v2(df):\n    adj_high = (df['high'] + df['open']) / 2\n    volume_adj_high_ratio = df['volume'] / adj_high\n    heuristics_matrix = volume_adj_high_ratio.ewm(span=20, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.04355,
          "other_inf": null
     }
]