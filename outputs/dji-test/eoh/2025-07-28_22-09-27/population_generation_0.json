[
     {
          "algorithm": "The algorithm calculates a set of alpha factors including momentum, volatility, and liquidity measures, then combines them using a weighted sum to produce the final heuristics matrix.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate simple return for momentum\n    returns = df['close'].pct_change()\n    \n    # Calculate volatility (standard deviation of returns)\n    volatility = returns.rolling(window=20).std()\n    \n    # Calculate liquidity (volume divided by close price)\n    liquidity = df['volume'] / df['close']\n    \n    # Combine factors into a heuristics matrix using a simple weighted sum\n    heuristics_matrix = 0.4 * returns + 0.4 * volatility + 0.2 * liquidity\n    \n    return heuristics_matrix",
          "objective": -0.04185,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a momentum-based alpha factor by calculating the average return over the last 5 days and then subtracting the average return over the previous 20 days, aiming to capture short-term versus medium-term market sentiment.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    short_term = df['close'].pct_change(5).rolling(window=5).mean()\n    long_term = df['close'].pct_change(20).rolling(window=20).mean()\n    heuristics_matrix = short_term - long_term\n    return heuristics_matrix",
          "objective": -0.03669,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a custom weighted sum of selected market features, then applies a moving window to smooth the values, aiming to identify trends that could predict future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate a custom weighted sum of features (example: 2*open + high - low + close)\n    weighted_sum = 2*df['open'] + df['high'] - df['low'] + df['close']\n    # Apply a 7-day moving average to smooth the series and potentially highlight trends\n    heuristics_matrix = weighted_sum.rolling(window=7).mean()\n    return heuristics_matrix",
          "objective": -0.02284,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a novel alpha factor by first computing the exponential moving average (EMA) of the close prices, then subtracting the EMA of the volume, and finally, multiplying this difference by the ratio of the high price to the low price for each day.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    ema_close = df['close'].ewm(span=10, adjust=False).mean()\n    ema_volume = df['volume'].ewm(span=10, adjust=False).mean()\n    high_low_ratio = df['high'] / df['low']\n    heuristics_matrix = (ema_close - ema_volume) * high_low_ratio\n    return heuristics_matrix",
          "objective": -0.01769,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a heuristic factor by calculating the difference between the moving average of closing prices over a short window and a long window, combined with the ratio of today's volume to the average volume over the long window, aiming to capture both momentum and volume anomalies.",
          "code": "def heuristics_v2(df):\n    short_window = 5\n    long_window = 20\n    close_prices = df['close']\n    volumes = df['volume']\n    \n    # Calculate moving averages for close prices\n    short_ma = close_prices.rolling(window=short_window).mean()\n    long_ma = close_prices.rolling(window=long_window).mean()\n    \n    # Calculate the average volume over the long window\n    avg_volume_long = volumes.rolling(window=long_window).mean()\n    \n    # Compute the heuristics factor\n    heuristics_matrix = (short_ma - long_ma) + (volumes / avg_volume_long)\n    \n    return heuristics_matrix",
          "objective": -0.01626,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm, named AlphaHeuristics, computes a unique heuristic factor by analyzing the relationship between trading volume and price volatility, then applying a weighted moving average to smooth out short-term fluctuations, aiming to capture long-term trends.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate daily returns\n    df['daily_return'] = df['close'].pct_change()\n    \n    # Calculate daily volatility (standard deviation of daily returns over a rolling window)\n    df['volatility'] = df['daily_return'].rolling(window=20).std()\n    \n    # Calculate the weighted moving average of volume, giving more weight to recent days\n    weights = np.arange(1, 21)  # Weights for the last 20 days\n    df['wma_volume'] = df['volume'].rolling(window=20).apply(lambda x: np.sum(weights * x) / np.sum(weights), raw=True)\n    \n    # Create the heuristic factor by combining volatility and wma_volume\n    df['heuristics_factor'] = (df['volatility'] / df['wma_volume']) * 100  # Scale for interpretability\n    \n    heuristics_matrix = df['heuristics_factor']\n    \n    return heuristics_matrix",
          "objective": -0.0107,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a heuristic factor based on the weighted combination of price volatility, trading volume momentum, and price change relative to the moving average, capturing market sentiment and trend strength.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily return\n    df['daily_return'] = df['close'].pct_change()\n    \n    # Calculate price volatility as standard deviation of daily returns over the last 30 days\n    df['volatility'] = df['daily_return'].rolling(window=30).std()\n    \n    # Calculate volume momentum as the rate of change in volume over the last 10 days\n    df['volume_momentum'] = df['volume'].pct_change(periods=10)\n    \n    # Calculate 50-day moving average\n    df['ma_50'] = df['close'].rolling(window=50).mean()\n    \n    # Calculate the percentage difference between the current close price and its 50-day moving average\n    df['price_vs_ma'] = (df['close'] - df['ma_50']) / df['ma_50']\n    \n    # Combine the three factors into one using equal weights\n    df['heuristics_factor'] = (df['volatility'] + df['volume_momentum'] + df['price_vs_ma']) / 3\n    \n    heuristics_matrix = df['heuristics_factor'].copy()\n    \n    return heuristics_matrix",
          "objective": -0.00763,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm, called Adaptive Momentum Heuristics, computes a weighted sum of the difference between closing and opening prices over the past n days, with weights dynamically adjusted based on volume changes, to generate a novel alpha factor.",
          "code": "def heuristics_v2(df):\n    n = 10  # Number of days to consider for the calculation\n    df['price_diff'] = df['close'] - df['open']\n    df['volume_change'] = df['volume'].pct_change()\n    df['weight'] = (df['volume_change'] + 1).cumprod()  # Adjusting weights dynamically\n    heuristics_matrix = df['price_diff'].rolling(window=n).apply(lambda x: (x * df.loc[x.index, 'weight']).sum(), raw=False)\n    return heuristics_matrix",
          "objective": -0.00681,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a heuristic factor based on the weighted combination of price movement and volume change, where the weights are determined by the historical consistency of each feature's predictive power.",
          "code": "def heuristics_v2(df):\n    # Calculate simple returns\n    simple_returns = df['close'].pct_change()\n    \n    # Calculate volume change\n    volume_change = df['volume'].pct_change()\n    \n    # Historical consistency score for simple returns\n    consistency_score_returns = (simple_returns > 0).rolling(window=20).mean()\n    \n    # Historical consistency score for volume change\n    consistency_score_volume = (volume_change > 0).rolling(window=20).mean()\n    \n    # Normalized consistency scores\n    total_consistency = consistency_score_returns + consistency_score_volume\n    weight_returns = consistency_score_returns / total_consistency\n    weight_volume = 1 - weight_returns\n    \n    # Heuristic factor\n    heuristics_matrix = weight_returns * simple_returns + weight_volume * volume_change\n    return heuristics_matrix",
          "objective": -0.00529,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm leverages a combination of moving average crossovers and volume changes over time to generate a unique alpha factor, where the main steps include calculating short- and long-term moving averages for closing prices, evaluating the rate of change in trading volumes, and combining these insights into a predictive heuristics matrix.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    short_window = 10\n    long_window = 50\n    df['short_mavg'] = df['close'].rolling(window=short_window, min_periods=short_window).mean()\n    df['long_mavg'] = df['close'].rolling(window=long_window, min_periods=long_window).mean()\n    df['volume_change'] = df['volume'].pct_change().fillna(0)\n    df['heuristics_factor'] = (df['short_mavg'] - df['long_mavg']) * df['volume_change']\n    heuristics_matrix = df['heuristics_factor']\n    return heuristics_matrix",
          "objective": -0.00444,
          "other_inf": null
     }
]