[
     {
          "algorithm": "The new algorithm calculates a composite factor by determining the ratio of the volume to the adjusted average price (using high, low, and twice the close price), then applies a 30-day Exponential Moving Average (EMA) to this ratio.",
          "code": "def heuristics_v2(df):\n    adj_avg_price = (df['high'] + df['low'] + 2 * df['close']) / 4\n    volume_adj_avg_ratio = df['volume'] / adj_avg_price\n    heuristics_matrix = volume_adj_avg_ratio.ewm(span=30, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.04429,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates alpha factors including momentum (exponential moving average of returns), volatility (average true range over a period), and liquidity (volume turnover ratio), then combines these into a heuristics matrix using a weighted sum with updated weights.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate exponential moving average of returns for momentum\n    returns = df['close'].pct_change()\n    ema_returns = returns.ewm(span=20, adjust=False).mean()\n    \n    # Calculate average true range for volatility\n    tr1 = df['high'] - df['low']\n    tr2 = (df['high'] - df['close'].shift()).abs()\n    tr3 = (df['low'] - df['close'].shift()).abs()\n    true_range = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)\n    atr = true_range.rolling(window=20).mean()\n    \n    # Calculate liquidity (volume divided by close price, then averaged over 20 days)\n    liquidity = (df['volume'] / df['close']).rolling(window=20).mean()\n    \n    # Combine factors into a heuristics matrix using a simple weighted sum\n    heuristics_matrix = 0.5 * ema_returns + 0.3 * atr + 0.2 * liquidity\n    \n    return heuristics_matrix",
          "objective": -0.04362,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by determining the ratio of the volume to the closing price, then applies a 20-day Exponential Moving Average (EMA) to this ratio.",
          "code": "def heuristics_v2(df):\n    volume_price_ratio = df['volume'] / df['close']\n    heuristics_matrix = volume_price_ratio.ewm(span=20, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.04359,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by determining the ratio of the volume to the average price, then applies a 20-day Exponential Moving Average (EMA) to this ratio.",
          "code": "def heuristics_v2(df):\n    avg_price = (df['high'] + df['low'] + df['close']) / 3\n    volume_avg_ratio = df['volume'] / avg_price\n    heuristics_matrix = volume_avg_ratio.ewm(span=20, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.04358,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by first determining the ratio of the volume to the high price, then applies a 20-day Exponential Moving Average (EMA) to this ratio.",
          "code": "def heuristics_v2(df):\n    volume_high_ratio = df['volume'] / df['high']\n    heuristics_matrix = volume_high_ratio.ewm(span=20, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.04354,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by first determining the ratio of the volume to the closing price, then subtracting the 50-day Exponential Moving Average (EMA) of this ratio from the 20-day EMA, capturing short-term deviations from the long-term trend.",
          "code": "def heuristics_v2(df):\n    volume_price_ratio = df['volume'] / df['close']\n    ema_20 = volume_price_ratio.ewm(span=20, adjust=False).mean()\n    ema_50 = volume_price_ratio.ewm(span=50, adjust=False).mean()\n    heuristics_matrix = ema_20 - ema_50\n    return heuristics_matrix",
          "objective": -0.04268,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by first determining the ratio of the volume to the closing price, then applies a 10-day Simple Moving Average (SMA) to this ratio.",
          "code": "def heuristics_v2(df):\n    volume_price_ratio = df['volume'] / df['close']\n    heuristics_matrix = volume_price_ratio.rolling(window=10).mean()\n    return heuristics_matrix",
          "objective": -0.04255,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by first determining the ratio of the volume to the closing price, then applies a 10-day Exponential Moving Average (EMA) to this ratio.",
          "code": "def heuristics_v2(df):\n    volume_price_ratio = df['volume'] / df['close']\n    heuristics_matrix = volume_price_ratio.ewm(span=10, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.04253,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes an alpha factor by first calculating the difference between the simple moving average (SMA) of the closing prices and the SMA of the volume, and then dividing this difference by the standard deviation of the closing prices over a specified period to incorporate a measure of volatility.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    sma_close = df['close'].rolling(window=10).mean()\n    sma_volume = df['volume'].rolling(window=10).mean()\n    std_close = df['close'].rolling(window=10).std()\n    heuristics_matrix = (sma_close - sma_volume) / std_close\n    return heuristics_matrix",
          "objective": -0.04213,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a set of alpha factors including momentum, volatility, and liquidity measures, then combines them using a weighted sum to produce the final heuristics matrix.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate simple return for momentum\n    returns = df['close'].pct_change()\n    \n    # Calculate volatility (standard deviation of returns)\n    volatility = returns.rolling(window=20).std()\n    \n    # Calculate liquidity (volume divided by close price)\n    liquidity = df['volume'] / df['close']\n    \n    # Combine factors into a heuristics matrix using a simple weighted sum\n    heuristics_matrix = 0.4 * returns + 0.4 * volatility + 0.2 * liquidity\n    \n    return heuristics_matrix",
          "objective": -0.04185,
          "other_inf": null
     }
]