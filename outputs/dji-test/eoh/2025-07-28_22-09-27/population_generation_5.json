[
     {
          "algorithm": "The new algorithm calculates a composite factor by computing the difference between the 20-day Exponential Moving Average (EMA) of the ratio of volume to the closing price and the 100-day EMA of the same ratio, to identify short-term deviations.",
          "code": "def heuristics_v2(df):\n    volume_close_ratio = df['volume'] / df['close']\n    ema_20 = volume_close_ratio.ewm(span=20, adjust=False).mean()\n    ema_100 = volume_close_ratio.ewm(span=100, adjust=False).mean()\n    heuristics_matrix = ema_20 - ema_100\n    return heuristics_matrix",
          "objective": -0.05171,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by first determining the ratio of the volume to the average of the high and low prices, then subtracts the 100-day Exponential Moving Average (EMA) of this ratio from the 30-day EMA, aiming to capture short-term deviations from a longer-term trend.",
          "code": "def heuristics_v2(df):\n    volume_price_ratio = df['volume'] / ((df['high'] + df['low']) / 2)\n    ema_30 = volume_price_ratio.ewm(span=30, adjust=False).mean()\n    ema_100 = volume_price_ratio.ewm(span=100, adjust=False).mean()\n    heuristics_matrix = ema_30 - ema_100\n    return heuristics_matrix",
          "objective": -0.05115,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by first determining the ratio of the volume to the closing price, then subtracting the 100-day Exponential Moving Average (EMA) of this ratio from the 30-day EMA, capturing short-term deviations from a longer-term trend.",
          "code": "def heuristics_v2(df):\n    volume_price_ratio = df['volume'] / df['close']\n    ema_30 = volume_price_ratio.ewm(span=30, adjust=False).mean()\n    ema_100 = volume_price_ratio.ewm(span=100, adjust=False).mean()\n    heuristics_matrix = ema_30 - ema_100\n    return heuristics_matrix",
          "objective": -0.0511,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by first determining the ratio of the volume to the closing price, then subtracts the 200-day Exponential Moving Average (EMA) of this ratio from the 50-day EMA, aiming to capture short-term deviations from a longer-term trend.",
          "code": "def heuristics_v2(df):\n    volume_price_ratio = df['volume'] / df['close']\n    ema_50 = volume_price_ratio.ewm(span=50, adjust=False).mean()\n    ema_200 = volume_price_ratio.ewm(span=200, adjust=False).mean()\n    heuristics_matrix = ema_50 - ema_200\n    return heuristics_matrix",
          "objective": -0.04913,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by computing the difference between the 50-day Exponential Moving Average (EMA) of the ratio of volume to the open price and the 200-day EMA of the same ratio, to identify medium-term deviations.",
          "code": "def heuristics_v2(df):\n    volume_open_ratio = df['volume'] / df['open']\n    ema_50 = volume_open_ratio.ewm(span=50, adjust=False).mean()\n    ema_200 = volume_open_ratio.ewm(span=200, adjust=False).mean()\n    heuristics_matrix = ema_50 - ema_200\n    return heuristics_matrix",
          "objective": -0.04912,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm modifies the EMA span to 20, changes the SMA window for mean reversion to 50 days, and alters the liquidity calculation to use a 90-day sum of volumes, adjusting the weights in the heuristics matrix.",
          "code": "def heuristics_v2(df):\n    # Calculate exponential moving average of returns with an adjusted span for momentum\n    returns = df['close'].pct_change()\n    ema_returns = returns.ewm(span=20, adjust=False).mean()\n    \n    # Mean reversion factor based on deviation from a 50-day SMA\n    sma_close = df['close'].rolling(window=50).mean()\n    mean_reversion_factor = (df['close'] - sma_close) / sma_close\n    \n    # Adjusted liquidity: sum of 90-day volumes divided by close price\n    liquidity = (df['volume'].rolling(window=90).sum() / df['close'])\n    \n    # Heuristics matrix with new weights\n    heuristics_matrix = 0.5 * ema_returns - 0.3 * mean_reversion_factor + 0.2 * liquidity\n    \n    return heuristics_matrix",
          "objective": -0.04685,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm adjusts the calculation of momentum by using a different span for EMA, adds a mean reversion factor based on the deviation of closing prices from their rolling mean, and revises the liquidity measure to consider the sum of volumes over a longer period, then combines these into a heuristics matrix with a new set of weights.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate exponential moving average of returns for adjusted momentum\n    returns = df['close'].pct_change()\n    ema_returns = returns.ewm(span=10, adjust=False).mean()\n    \n    # Calculate mean reversion factor as the difference between close price and 30-day SMA\n    sma_close = df['close'].rolling(window=30).mean()\n    mean_reversion_factor = (df['close'] - sma_close) / sma_close\n    \n    # Adjusted liquidity calculation: sum of volumes over 60 days divided by close price\n    liquidity = (df['volume'].rolling(window=60).sum() / df['close'])\n    \n    # Combine factors into a heuristics matrix using a weighted sum\n    heuristics_matrix = 0.4 * ema_returns - 0.4 * mean_reversion_factor + 0.2 * liquidity\n    \n    return heuristics_matrix",
          "objective": -0.04665,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by determining the ratio of the volume to the weighted average price (using different weights for high, low, and close prices), then applies a 50-day Exponential Moving Average (EMA) to this ratio.",
          "code": "def heuristics_v2(df):\n    w_avg_price = (0.3 * df['high'] + 0.2 * df['low'] + 0.5 * df['close'])\n    volume_w_avg_ratio = df['volume'] / w_avg_price\n    heuristics_matrix = volume_w_avg_ratio.ewm(span=50, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.04512,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by summing the ratio of the closing price to the highest high over the last 50 days and the ratio of the lowest low over the last 50 days to the closing price, then applies a 10-day Exponential Moving Average (EMA) to this sum.",
          "code": "def heuristics_v2(df):\n    highest_high = df['high'].rolling(window=50).max()\n    lowest_low = df['low'].rolling(window=50).min()\n    close_to_highest_high_ratio = df['close'] / highest_high\n    lowest_low_to_close_ratio = lowest_low / df['close']\n    composite_factor = close_to_highest_high_ratio + lowest_low_to_close_ratio\n    heuristics_matrix = composite_factor.ewm(span=10, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.04498,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by determining the ratio of the volume to the adjusted average price (using high, low, and twice the close price), then applies a 30-day Exponential Moving Average (EMA) to this ratio.",
          "code": "def heuristics_v2(df):\n    adj_avg_price = (df['high'] + df['low'] + 2 * df['close']) / 4\n    volume_adj_avg_ratio = df['volume'] / adj_avg_price\n    heuristics_matrix = volume_adj_avg_ratio.ewm(span=30, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.04429,
          "other_inf": null
     }
]