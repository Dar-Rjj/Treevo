[
     {
          "algorithm": "The new algorithm calculates a composite factor by determining the ratio of the volume to the closing price, then applies a 20-day Exponential Moving Average (EMA) to this ratio.",
          "code": "def heuristics_v2(df):\n    volume_price_ratio = df['volume'] / df['close']\n    heuristics_matrix = volume_price_ratio.ewm(span=20, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.04359,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by first determining the ratio of the volume to the high price, then applies a 20-day Exponential Moving Average (EMA) to this ratio.",
          "code": "def heuristics_v2(df):\n    volume_high_ratio = df['volume'] / df['high']\n    heuristics_matrix = volume_high_ratio.ewm(span=20, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.04354,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by first determining the ratio of the volume to the closing price, then applies a 10-day Simple Moving Average (SMA) to this ratio.",
          "code": "def heuristics_v2(df):\n    volume_price_ratio = df['volume'] / df['close']\n    heuristics_matrix = volume_price_ratio.rolling(window=10).mean()\n    return heuristics_matrix",
          "objective": -0.04255,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by first determining the ratio of the volume to the closing price, then applies a 10-day Exponential Moving Average (EMA) to this ratio.",
          "code": "def heuristics_v2(df):\n    volume_price_ratio = df['volume'] / df['close']\n    heuristics_matrix = volume_price_ratio.ewm(span=10, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.04253,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes an alpha factor by first calculating the difference between the simple moving average (SMA) of the closing prices and the SMA of the volume, and then dividing this difference by the standard deviation of the closing prices over a specified period to incorporate a measure of volatility.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    sma_close = df['close'].rolling(window=10).mean()\n    sma_volume = df['volume'].rolling(window=10).mean()\n    std_close = df['close'].rolling(window=10).std()\n    heuristics_matrix = (sma_close - sma_volume) / std_close\n    return heuristics_matrix",
          "objective": -0.04213,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a set of alpha factors including momentum, volatility, and liquidity measures, then combines them using a weighted sum to produce the final heuristics matrix.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate simple return for momentum\n    returns = df['close'].pct_change()\n    \n    # Calculate volatility (standard deviation of returns)\n    volatility = returns.rolling(window=20).std()\n    \n    # Calculate liquidity (volume divided by close price)\n    liquidity = df['volume'] / df['close']\n    \n    # Combine factors into a heuristics matrix using a simple weighted sum\n    heuristics_matrix = 0.4 * returns + 0.4 * volatility + 0.2 * liquidity\n    \n    return heuristics_matrix",
          "objective": -0.04185,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a momentum-based alpha factor by calculating the average return over the last 5 days and then subtracting the average return over the previous 20 days, aiming to capture short-term versus medium-term market sentiment.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    short_term = df['close'].pct_change(5).rolling(window=5).mean()\n    long_term = df['close'].pct_change(20).rolling(window=20).mean()\n    heuristics_matrix = short_term - long_term\n    return heuristics_matrix",
          "objective": -0.03669,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a modified composite factor by first determining the ratio of the difference between the highest and lowest prices to the average price, then applies a 20-day Exponential Moving Average (EMA) to this ratio.",
          "code": "def heuristics_v2(df):\n    high_low_range = df['high'] - df['low']\n    avg_price = (df['high'] + df['low'] + df['close']) / 3\n    price_ratio = high_low_range / avg_price\n    heuristics_matrix = price_ratio.ewm(span=20, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.0343,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a modified composite factor by first determining the ratio of the difference between the highest and lowest prices to the closing price, then applies a 20-day Exponential Moving Average (EMA) to this ratio.",
          "code": "def heuristics_v2(df):\n    high_low_range = df['high'] - df['low']\n    price_ratio = high_low_range / df['close']\n    heuristics_matrix = price_ratio.ewm(span=20, adjust=False).mean()\n    return heuristics_matrix",
          "objective": -0.03425,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a set of alpha factors including momentum, volatility, and liquidity, then combines these factors using a weighted product with different weights to generate the final heuristics matrix.",
          "code": "def heuristics_v2(df):\n    # Calculate simple return for momentum\n    returns = df['close'].pct_change().fillna(0)\n    \n    # Calculate volatility (standard deviation of returns)\n    volatility = returns.rolling(window=20).std().fillna(0)\n    \n    # Calculate liquidity (volume divided by close price)\n    liquidity = (df['volume'] / df['close']).fillna(0)\n    \n    # Combine factors into a heuristics matrix using a weighted product with different weights\n    heuristics_matrix = (returns + 1) ** 0.5 * (volatility + 1) ** 0.3 * (liquidity + 1) ** 0.2 - 1\n    \n    return heuristics_matrix",
          "objective": -0.0314,
          "other_inf": null
     }
]