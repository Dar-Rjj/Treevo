[
     {
          "algorithm": "The new algorithm calculates the alpha factor by taking the difference between the 20-day simple moving average (SMA) of the closing price and the 50-day exponentially weighted moving average (EWMA) of the high price, capturing a smoothed support level relative to the average high price.",
          "code": "def heuristics_v2(df):\n    sma_20_close = df['close'].rolling(window=20).mean()\n    ewma_50_high = df['high'].ewm(span=50, adjust=False).mean()\n    heuristics_matrix = sma_20_close - ewma_50_high\n    return heuristics_matrix",
          "objective": -0.03874,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm generates an alpha factor by calculating the difference between the 20-day simple moving average (SMA) of the high price and the 50-day exponentially weighted moving average (EWMA) of the closing price, reflecting the smoothed resistance level relative to the average closing price.",
          "code": "def heuristics_v2(df):\n    sma_20_high = df['high'].rolling(window=20).mean()\n    ewma_50_close = df['close'].ewm(span=50, adjust=False).mean()\n    heuristics_matrix = sma_20_high - ewma_50_close\n    return heuristics_matrix",
          "objective": -0.03723,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a momentum-based alpha factor by evaluating the weighted average of the past 30 days' closing prices, with more recent days having higher weights, and then subtracts the 50-day exponential moving average from this value to generate the heuristics matrix.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def weighted_moving_average(series, window=30):\n        weights = pd.Series(range(1, window+1))\n        wma = series.rolling(window=window).apply(lambda prices: (prices * weights).sum() / weights.sum(), raw=True)\n        return wma\n    \n    wma_30 = weighted_moving_average(df['close'])\n    ema_50 = df['close'].ewm(span=50, adjust=False).mean()\n    heuristics_matrix = wma_30 - ema_50\n    return heuristics_matrix",
          "objective": -0.0372,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the alpha factor by taking the difference between the 30-day simple moving average (SMA) of the closing price and the 70-day exponentially weighted moving average (EWMA) of the low price, aiming to capture a smoothed resistance level relative to the average low price.",
          "code": "def heuristics_v2(df):\n    sma_30_close = df['close'].rolling(window=30).mean()\n    ewma_70_low = df['low'].ewm(span=70, adjust=False).mean()\n    heuristics_matrix = sma_30_close - ewma_70_low\n    return heuristics_matrix",
          "objective": -0.03706,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm generates an alpha factor by calculating the difference between the 30-day simple moving average (SMA) of the low price and the 75-day exponentially weighted moving average (EWMA) of the opening price, reflecting the smoothed support level relative to the average opening price.",
          "code": "def heuristics_v2(df):\n    sma_30_low = df['low'].rolling(window=30).mean()\n    ewma_75_open = df['open'].ewm(span=75, adjust=False).mean()\n    heuristics_matrix = sma_30_low - ewma_75_open\n    return heuristics_matrix",
          "objective": -0.03531,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a momentum-based alpha factor using a 20-day weighted moving average with decreasing weights for more recent days, and subtracts a 40-day simple moving average from this value to generate the heuristics matrix.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def weighted_moving_average(series, window=20):\n        weights = pd.Series(range(window, 0, -1))\n        wma = series.rolling(window=window).apply(lambda prices: (prices * weights).sum() / weights.sum(), raw=True)\n        return wma\n    \n    wma_20 = weighted_moving_average(df['close'])\n    sma_40 = df['close'].rolling(window=40).mean()\n    heuristics_matrix = wma_20 - sma_40\n    return heuristics_matrix",
          "objective": -0.03529,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm integrates the momentum of the closing price with the relative strength of volume, using a combination of rate of change (ROC) and average true range (ATR) to generate a unique alpha factor.",
          "code": "def heuristics_v2(df):\n    # Calculate the 14-period Rate of Change (ROC) for the close price\n    roc_close = df['close'].pct_change(periods=14)\n    \n    # Calculate the 14-period Average True Range (ATR)\n    df['tr'] = df[['high', 'low']].diff(axis=1).abs().max(axis=1)\n    atr = df['tr'].rolling(window=14).mean()\n    \n    # Calculate the relative strength of volume\n    rs_volume = df['volume'] / atr\n    \n    # Heuristic combination: Weighted sum of ROC and relative strength of volume\n    heuristics_matrix = 0.7 * roc_close + 0.3 * rs_volume\n    return heuristics_matrix",
          "objective": -0.0342,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm adjusts the lookback period for ROC and ATR to 21, and modifies the weightage of ROC and relative strength of volume to 0.6 and 0.4 respectively, aiming to capture longer-term price momentum and more pronounced volume strength.",
          "code": "def heuristics_v2(df):\n    # Calculate the 21-period Rate of Change (ROC) for the close price\n    roc_close = df['close'].pct_change(periods=21)\n    \n    # Calculate the 21-period Average True Range (ATR)\n    df['tr'] = df[['high', 'low']].diff(axis=1).abs().max(axis=1)\n    atr = df['tr'].rolling(window=21).mean()\n    \n    # Calculate the relative strength of volume\n    rs_volume = df['volume'] / atr\n    \n    # Heuristic combination: Weighted sum of ROC and relative strength of volume\n    heuristics_matrix = 0.6 * roc_close + 0.4 * rs_volume\n    return heuristics_matrix",
          "objective": -0.03418,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm integrates the price volatility, measured through the standard deviation of returns over a 20-day period, with a momentum indicator, calculated as the difference between the current close and the 100-day simple moving average (SMA), further adjusted by the ratio of the current volume to the 50-day moving average of volume.",
          "code": "def heuristics_v2(df):\n    df['Return'] = df['close'].pct_change()\n    std_dev = df['Return'].rolling(window=20).std()\n    sma_100 = df['close'].rolling(window=100).mean()\n    momentum = df['close'] - sma_100\n    volume_ratio = df['volume'] / df['volume'].rolling(window=50).mean()\n    \n    heuristics_matrix = (std_dev * 0.5 + momentum * 0.5) * volume_ratio\n    return heuristics_matrix",
          "objective": -0.03379,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm combines the 20-day exponentially weighted moving standard deviation of returns with a momentum indicator, which is the difference between the 50-day exponential moving average (EMA) and the 100-day EMA, all further adjusted by the ratio of the current volume to the average volume over the last 50 days.",
          "code": "def heuristics_v2(df):\n    df['Return'] = df['close'].pct_change()\n    ewm_std_dev = df['Return'].ewm(span=20).std()\n    ema_50 = df['close'].ewm(span=50).mean()\n    ema_100 = df['close'].ewm(span=100).mean()\n    momentum = ema_50 - ema_100\n    volume_ratio = df['volume'] / df['volume'].rolling(window=50).mean()\n    \n    heuristics_matrix = (ewm_std_dev * 0.5 + momentum * 0.5) * volume_ratio\n    return heuristics_matrix",
          "objective": -0.03189,
          "other_inf": null
     }
]