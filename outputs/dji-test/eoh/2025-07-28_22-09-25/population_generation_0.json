[
     {
          "algorithm": "The algorithm calculates a momentum-based alpha factor by evaluating the weighted average of the past 10 days' closing prices, with more recent days having higher weights, and then subtracts the 50-day simple moving average from this value to generate the heuristics matrix.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def weighted_moving_average(series, window=10):\n        weights = pd.Series(range(1, window+1))\n        wma = series.rolling(window=window).apply(lambda prices: (prices * weights).sum() / weights.sum(), raw=True)\n        return wma\n    \n    wma_10 = weighted_moving_average(df['close'])\n    sma_50 = df['close'].rolling(window=50).mean()\n    heuristics_matrix = wma_10 - sma_50\n    return heuristics_matrix",
          "objective": -0.02739,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies patterns in the historical market data by calculating the weighted moving average convergence divergence (WMACD) for different periods and combines them with a unique heuristic to generate an interpretable alpha factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculating short and long period WMACDs\n    short_wma = df.close.rolling(window=12).mean()\n    long_wma = df.close.rolling(window=26).mean()\n    wmacd = short_wma - long_wma\n    \n    # Adding a simple daily return as another signal\n    daily_return = df.close.pct_change()\n    \n    # Heuristic combination: Weighted sum of WMACD and daily return\n    heuristics_matrix = 0.7 * wmacd + 0.3 * daily_return\n    return heuristics_matrix",
          "objective": -0.02029,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a momentum-based alpha factor by comparing the current day's closing price to the average of the past 20 days' closing prices, then applies a simple moving average over the last 10 periods to smooth out the signal.",
          "code": "def heuristics_v2(df):\n    def custom_heuristic(row):\n        # Calculate the 20-day simple moving average\n        sma_20 = df['close'].rolling(window=20).mean()\n        # Compute the difference between the current close and the 20-day SMA\n        diff = df['close'] - sma_20\n        # Apply a 10-day SMA to the differences for smoothing\n        smoothed_diff = diff.rolling(window=10).mean()\n        return smoothed_diff\n\n    heuristics_matrix = custom_heuristic(df)\n    return heuristics_matrix",
          "objective": -0.01977,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a composite factor by first calculating the moving average of the closing prices, then subtracting the minimum daily price over a specified window, and finally dividing by the volume, to generate an interpretable alpha factor.",
          "code": "def heuristics_v2(df):\n    ma = df['close'].rolling(window=20).mean()\n    min_low = df['low'].rolling(window=20).min()\n    heuristics_matrix = (ma - min_low) / df['volume']\n    return heuristics_matrix",
          "objective": -0.01579,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates the weighted sum of exponential moving averages (EMAs) for close prices, adjusted by a volatility factor, to generate daily alpha factors.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate EMA for 10 and 20 days\n    ema_10 = df['close'].ewm(span=10, adjust=False).mean()\n    ema_20 = df['close'].ewm(span=20, adjust=False).mean()\n    \n    # Volatility measure over the last 30 days\n    volatility = df['close'].rolling(window=30).std()\n    \n    # Alpha factor combining EMAs with an adjustment for recent volatility\n    heuristics_matrix = ((ema_10 - ema_20) / volatility).dropna()\n    \n    return heuristics_matrix",
          "objective": -0.01519,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates the rolling median of the ratio between the average true range and the volume over a specified window, aiming to capture volatility adjusted by liquidity as a predictive signal.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def average_true_range(high, low, close, n=14):\n        tr = pd.Series(index=high.index)\n        for i in range(len(tr)):\n            if i == 0:\n                tr[i] = high.iloc[i] - low.iloc[i]\n            else:\n                hl = high.iloc[i] - low.iloc[i]\n                hpc = abs(high.iloc[i] - close.iloc[i-1])\n                lpc = abs(low.iloc[i] - close.iloc[i-1])\n                tr[i] = max(hl, hpc, lpc)\n        \n        atr = tr.rolling(window=n).mean()\n        return atr\n    \n    atr = average_true_range(df['high'], df['low'], df['close'])\n    atr_vol_ratio = atr / df['volume']\n    heuristics_matrix = atr_vol_ratio.rolling(window=20).median().dropna()\n    \n    return heuristics_matrix",
          "objective": -0.01221,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a novel alpha factor by first calculating the relative strength index (RSI) of the closing prices over a 14-day period, then combining it with the 5-period and 20-period exponential moving averages (EMA) of the closing prices to generate a composite score, which is further adjusted based on the percentage change in volume from the previous day.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    def rsi(series, periods=14):\n        delta = series.diff()\n        up, down = delta.copy(), delta.copy()\n        up[up < 0] = 0\n        down[down > 0] = 0\n        roll_up = up.ewm(com=periods - 1, adjust=False).mean()\n        roll_down = down.abs().ewm(com=periods - 1, adjust=False).mean()\n        rs = roll_up / roll_down\n        return 100.0 - (100.0 / (1.0 + rs))\n\n    df['Close_5EMA'] = df['close'].ewm(span=5, adjust=False).mean()\n    df['Close_20EMA'] = df['close'].ewm(span=20, adjust=False).mean()\n    df['RSI'] = rsi(df['close'])\n    df['Volume_Change'] = df['volume'].pct_change()\n    \n    heuristics_matrix = (df['RSI'] * 0.4 + (df['Close_5EMA'] - df['Close_20EMA']) * 0.3 + df['Volume_Change'] * 0.3)\n    return heuristics_matrix",
          "objective": -0.00725,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a factor by calculating the difference between the 5-day and 20-day simple moving averages of the close price, then dividing this difference by the 20-day standard deviation of the close price to generate a volatility-adjusted momentum indicator.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    sma_5 = df['close'].rolling(window=5).mean()\n    sma_20 = df['close'].rolling(window=20).mean()\n    std_20 = df['close'].rolling(window=20).std()\n    heuristics_matrix = (sma_5 - sma_20) / std_20\n    return heuristics_matrix",
          "objective": -0.00688,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm involves creating an interpretable alpha factor by combining weighted differences between high and low prices with volume, and then applying a moving average to smooth out the factor for better stability.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the difference between high and low, then multiply by volume\n    raw_factor = (df['high'] - df['low']) * df['volume']\n    # Apply a simple moving average over a 10-day window to smooth the signal\n    heuristics_matrix = raw_factor.rolling(window=10).mean()\n    return heuristics_matrix",
          "objective": -0.00448,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a novel alpha factor by combining moving averages and price rate of change, then applies a heuristic to weigh these indicators based on their recent effectiveness in predicting returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate short and long term moving averages\n    ma_short = df['close'].rolling(window=10).mean()\n    ma_long = df['close'].rolling(window=50).mean()\n    \n    # Calculate the price rate of change (ROC) for a 14-day period\n    roc = df['close'].pct_change(periods=14)\n    \n    # Heuristic: If the short-term MA is above the long-term MA, give more weight to ROC\n    heuristic_weights = (ma_short > ma_long).astype(int) * 2 + 1\n    \n    # Generate the heuristic factor\n    heuristics_matrix = roc * heuristic_weights\n    \n    return heuristics_matrix",
          "objective": -0.00387,
          "other_inf": null
     }
]