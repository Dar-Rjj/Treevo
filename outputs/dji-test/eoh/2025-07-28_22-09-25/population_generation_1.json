[
     {
          "algorithm": "The new algorithm calculates a momentum-based alpha factor using a 20-day weighted moving average with decreasing weights for more recent days, and subtracts a 40-day simple moving average from this value to generate the heuristics matrix.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def weighted_moving_average(series, window=20):\n        weights = pd.Series(range(window, 0, -1))\n        wma = series.rolling(window=window).apply(lambda prices: (prices * weights).sum() / weights.sum(), raw=True)\n        return wma\n    \n    wma_20 = weighted_moving_average(df['close'])\n    sma_40 = df['close'].rolling(window=40).mean()\n    heuristics_matrix = wma_20 - sma_40\n    return heuristics_matrix",
          "objective": -0.03529,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm integrates the momentum of the closing price with the relative strength of volume, using a combination of rate of change (ROC) and average true range (ATR) to generate a unique alpha factor.",
          "code": "def heuristics_v2(df):\n    # Calculate the 14-period Rate of Change (ROC) for the close price\n    roc_close = df['close'].pct_change(periods=14)\n    \n    # Calculate the 14-period Average True Range (ATR)\n    df['tr'] = df[['high', 'low']].diff(axis=1).abs().max(axis=1)\n    atr = df['tr'].rolling(window=14).mean()\n    \n    # Calculate the relative strength of volume\n    rs_volume = df['volume'] / atr\n    \n    # Heuristic combination: Weighted sum of ROC and relative strength of volume\n    heuristics_matrix = 0.7 * roc_close + 0.3 * rs_volume\n    return heuristics_matrix",
          "objective": -0.0342,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm adjusts the lookback period for ROC and ATR to 21, and modifies the weightage of ROC and relative strength of volume to 0.6 and 0.4 respectively, aiming to capture longer-term price momentum and more pronounced volume strength.",
          "code": "def heuristics_v2(df):\n    # Calculate the 21-period Rate of Change (ROC) for the close price\n    roc_close = df['close'].pct_change(periods=21)\n    \n    # Calculate the 21-period Average True Range (ATR)\n    df['tr'] = df[['high', 'low']].diff(axis=1).abs().max(axis=1)\n    atr = df['tr'].rolling(window=21).mean()\n    \n    # Calculate the relative strength of volume\n    rs_volume = df['volume'] / atr\n    \n    # Heuristic combination: Weighted sum of ROC and relative strength of volume\n    heuristics_matrix = 0.6 * roc_close + 0.4 * rs_volume\n    return heuristics_matrix",
          "objective": -0.03418,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a momentum-based alpha factor by evaluating the weighted average of the past 20 days' closing prices, with more recent days having higher weights, and then subtracts the 40-day exponential moving average from this value to generate the heuristics matrix.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def weighted_moving_average(series, window=20):\n        weights = pd.Series(range(1, window+1))\n        wma = series.rolling(window=window).apply(lambda prices: (prices * weights).sum() / weights.sum(), raw=True)\n        return wma\n    \n    wma_20 = weighted_moving_average(df['close'])\n    ema_40 = df['close'].ewm(span=40, adjust=False).mean()\n    heuristics_matrix = wma_20 - ema_40\n    return heuristics_matrix",
          "objective": -0.03142,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates an alpha factor by combining the momentum of the 50-day price change, the relative strength index (RSI) over a 14-day period, and the 20-day simple moving average (SMA) of the volume, then adjusts this composite score based on the ratio of the current day's close to the 200-day SMA of the closing prices.",
          "code": "def heuristics_v2(df):\n    df['Momentum_50'] = df['close'] - df['close'].shift(50)\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rs = gain / loss\n    df['RSI_14'] = 100 - (100 / (1 + rs))\n    sma_volume_20 = df['volume'].rolling(window=20).mean()\n    sma_close_200 = df['close'].rolling(window=200).mean()\n    heuristics_matrix = (df['Momentum_50'] * 0.3 + df['RSI_14'] * 0.4 + sma_volume_20 * 0.3) * (df['close'] / sma_close_200)\n    return heuristics_matrix",
          "objective": -0.03139,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a momentum-based alpha factor by evaluating the weighted average of the past 10 days' closing prices, with more recent days having higher weights, and then subtracts the 50-day simple moving average from this value to generate the heuristics matrix.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def weighted_moving_average(series, window=10):\n        weights = pd.Series(range(1, window+1))\n        wma = series.rolling(window=window).apply(lambda prices: (prices * weights).sum() / weights.sum(), raw=True)\n        return wma\n    \n    wma_10 = weighted_moving_average(df['close'])\n    sma_50 = df['close'].rolling(window=50).mean()\n    heuristics_matrix = wma_10 - sma_50\n    return heuristics_matrix",
          "objective": -0.02739,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm generates an alpha factor by calculating the ratio of the 20-day exponentially weighted moving average (EWMA) of the low price to the 50-day simple moving average (SMA) of the closing price, incorporating the smoothed support level relative to the average closing price.",
          "code": "def heuristics_v2(df):\n    ewma_20_low = df['low'].ewm(span=20).mean()\n    sma_50_close = df['close'].rolling(window=50).mean()\n    heuristics_matrix = ewma_20_low / sma_50_close\n    return heuristics_matrix",
          "objective": -0.02734,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a momentum-based alpha factor by evaluating the weighted average of the past 15 days' closing prices, with more recent days having higher weights, and then subtracts the 30-day exponential moving average from this value to generate the heuristics matrix.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def weighted_moving_average(series, window=15):\n        weights = pd.Series(range(1, window+1))\n        wma = series.rolling(window=window).apply(lambda prices: (prices * weights).sum() / weights.sum(), raw=True)\n        return wma\n    \n    wma_15 = weighted_moving_average(df['close'])\n    ema_30 = df['close'].ewm(span=30, adjust=False).mean()\n    heuristics_matrix = wma_15 - ema_30\n    return heuristics_matrix",
          "objective": -0.02656,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates an alpha factor by incorporating the 10-day moving average of the closing prices, the exponential moving average (EMA) of the last 20 days' closing prices, and the 5-period volume weighted average price (VWAP), then adjusts this score based on the ratio of the latest day's volume to the 60-day moving average of volume.",
          "code": "def heuristics_v2(df):\n    df['SMA_10'] = df['close'].rolling(window=10).mean()\n    df['EMA_20'] = df['close'].ewm(span=20, adjust=False).mean()\n    vwap_5 = (df['close']*df['volume']).rolling(window=5).sum() / df['volume'].rolling(window=5).sum()\n    df['Volume_Ratio'] = df['volume'] / df['volume'].rolling(window=60).mean()\n    \n    heuristics_matrix = (df['SMA_10'] * 0.3 + df['EMA_20'] * 0.5 + vwap_5 * 0.2) * df['Volume_Ratio']\n    return heuristics_matrix",
          "objective": -0.02394,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a novel alpha factor by combining the volatility (standard deviation) of the last 20 days' closing prices, the rate of change between the current and the 30-day lagged close, and the 10-period volume weighted average price (VWAP), then scales this composite score linearly based on the ratio of the latest day's volume to the 90-day moving average of volume.",
          "code": "def heuristics_v2(df):\n    df['Volatility'] = df['close'].rolling(window=20).std()\n    df['Rate_of_Change'] = (df['close'] - df['close'].shift(30)) / df['close'].shift(30)\n    vwap_10 = (df['close']*df['volume']).rolling(window=10).sum() / df['volume'].rolling(window=10).sum()\n    df['Volume_Ratio'] = df['volume'] / df['volume'].rolling(window=90).mean()\n    \n    heuristics_matrix = (df['Volatility'] * 0.4 + df['Rate_of_Change'] * 0.4 + vwap_10 * 0.2) * df['Volume_Ratio']\n    return heuristics_matrix",
          "objective": -0.02297,
          "other_inf": null
     }
]