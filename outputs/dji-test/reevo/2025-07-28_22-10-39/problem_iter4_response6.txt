```python
def heuristics_v2(df: pd.DataFrame) -> pd.Series:
    # Calculate the difference between close and open prices
    diff_close_open = df['close'] - df['open']
    
    # Calculate the 10-day moving average of the close price
    ma_close_10 = df['close'].rolling(window=10).mean()
    
    # Calculate the distance of the current close price from its 10-day moving average
    dist_from_ma = abs(df['close'] - ma_close_10)
    
    # Calculate the 10-day standard deviation of the close price to measure volatility
    vol_10 = df['close'].rolling(window=10).std()
    
    # Calculate the 5-day and 20-day exponential moving averages of the close price
    ema_close_5 = df['close'].ewm(span=5, adjust=False).mean()
    ema_close_20 = df['close'].ewm(span=20, adjust=False).mean()
    
    # Calculate the relative strength as the ratio of the 5-day EMA to the 20-day EMA
    relative_strength = ema_close_5 / ema_close_20
    
    # Calculate the liquidity measure as the 10-day rolling sum of volume
    liquidity = df['volume'].rolling(window=10).sum()
    
    # Adaptive window for momentum based on the 10-day ATR (Average True Range)
    atr_10 = df[['high', 'low', 'close']].apply(lambda x: max(x[0] - x[1], abs(x[0] - x[2]), abs(x[1] - x[2])), axis=1).rolling(window=10).mean()
    adaptive_window = 10 + (10 * (atr_10 / atr_10.rolling(window=10).mean()))
    
    # Calculate the adaptive momentum
    momentum_adaptive = (df['close'] - df['close'].shift(adaptive_window.astype(int))) / df['close'].shift(adaptive_window.astype(int))
    
    # Alpha factor: weighted sum of (difference between close and open, distance from 10-day MA, volume, relative strength, and adaptive momentum)
    # Include volatility to normalize the impact of volume and price differences
    alpha_factor = (df['volume'] * diff_close_open) / (dist_from_ma + 1e-7) * (vol_10 + 1e-7) * relative_strength * momentum_adaptive
    
    return alpha_factor
```
