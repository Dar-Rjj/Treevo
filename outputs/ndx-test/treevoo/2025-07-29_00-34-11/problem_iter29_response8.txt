```python
import pandas as pd

def heuristics_v2(df):
    # Calculate Short-Term and Long-Term Logarithmic Return
    df['ShortTermLogReturn'] = (df['close'] / df['close'].shift(5)).apply(lambda x: 0 if x <= 0 else np.log(x))
    df['LongTermLogReturn'] = (df['close'] / df['close'].shift(20)).apply(lambda x: 0 if x <= 0 else np.log(x))
    
    # Calculate Volume-Weighted Short-Term and Long-Term Logarithmic Return
    df['VolumeWeightedShortTermLogReturn'] = df['ShortTermLogReturn'] * df['volume']
    df['VolumeWeightedLongTermLogReturn'] = df['LongTermLogReturn'] * df['volume']
    
    # Calculate Short-Term Volatility using Average True Range
    df['TrueRange'] = df[['high', 'low', 'close']].diff(axis=1).abs().max(axis=1)
    df['ShortTermVolatility'] = df['TrueRange'].rolling(window=5).mean()
    
    # Adjust for Volatility
    df['AdjustedShortTermReturn'] = (df['VolumeWeightedShortTermLogReturn'] / df['ShortTermVolatility']) - df['VolumeWeightedLongTermLogReturn']
    
    # Determine Gain and Loss
    df['Gain'] = (df['close'] - df['close'].shift(1)).apply(lambda x: x if x > 0 else 0)
    df['Loss'] = (df['close'] - df['close'].shift(1)).apply(lambda x: -x if x < 0 else 0)
    
    # Aggregate Gains and Losses
    df['SumGains'] = df['Gain'].rolling(window=14).sum()
    df['SumLosses'] = df['Loss'].rolling(window=14).sum()
    
    # Calculate Relative Strength
    df['RS'] = df['SumGains'] / df['SumLosses']
    
    # Convert to ARSI
    df['ARSI'] = 100 - (100 / (1 + df['RS']))
    df['ARSI'] = df['ARSI'] * df['volume'].rolling(window=14).mean()
    
    # Calculate Intraday Price Movement Ratio
    df['HighLowRatio'] = df['high'] / df['low']
    df['OpenCloseRatio'] = df['open'] / df['close']
    df['IntradayPriceMovementRatio'] = (df['HighLowRatio'] + df['OpenCloseRatio']) / 2
    
    # Measure Price-Volatility Alignment
    df['PriceRange'] = df['high'] - df['low']
    df['IntradayVolatility'] = df['PriceRange'] * df['volume']
    df['Sentiment'] = df['IntradayPriceMovementRatio'] - df['IntradayVolatility']
    
    # Calculate Price Oscillator
    df['PriceOscillator'] = df['ShortTermLogReturn'] - df['LongTermLogReturn']
    
    # Combine ARSI, Adjusted Returns, and Price Oscillator
    df['CombinedFactor'] = (df['ARSI'] * df['AdjustedShortTermReturn']) + df['PriceOscillator'] - df['VolumeWeightedLongTermLogReturn']
    
    # Calculate High-Low Spread
    df['HighLowSpread'] = df['high'] - df['low']
    
    # Compute VWMA of High-Low Spread
    df['VWMA_HighLowSpread'] = (df['HighLowSpread'] * df['volume']).rolling(window=14).mean() / df['volume'].rolling(window=14).mean()
    
    # Incorporate Close-to-Close Return
    df['CloseToCloseReturn'] = df['close'] - df['close'].shift(1)
    df['VWMACloseToClose'] = df['VWMA_HighLowSpread'] * df['CloseToCloseReturn']
    
    # Final Adjustment
    df['VolumeChange'] = (df['volume'] / df['volume'].shift(1)) - 1
    df['FinalFactor'] = (df['AdjustedShortTermReturn'] + df['CombinedFactor']) * df['VWMACloseToClose'] * df['VolumeChange']
    
    return df['FinalFactor']
```
