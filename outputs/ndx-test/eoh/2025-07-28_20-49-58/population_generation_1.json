[
     {
          "algorithm": "The new algorithm combines the momentum captured by the rate of change (ROC) of the closing price with the volume-weighted average price (VWAP) to generate a novel and interpretable alpha factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def calculate_roc(column, n):\n        return (column - column.shift(n)) / column.shift(n)\n\n    # Calculate ROC over a 10-day period\n    roc = calculate_roc(df['close'], 10)\n    \n    # Calculate VWAP\n    tp = (df['high'] + df['low'] + df['close']) / 3\n    vwap = (df['volume'] * tp).cumsum() / df['volume'].cumsum()\n    \n    # Combine factors\n    heuristics_matrix = roc + (vwap - df['close'])\n    \n    return heuristics_matrix",
          "objective": -0.03266,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm modifies the original by using a 20-day period for ROC and incorporating a 5-day moving average of the closing price into the VWAP calculation, aiming to smooth out short-term volatility.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def calculate_roc(column, n):\n        return (column - column.shift(n)) / column.shift(n)\n\n    # Calculate ROC over a 20-day period\n    roc = calculate_roc(df['close'], 20)\n    \n    # Calculate 5-day moving average of the closing price\n    ma_5 = df['close'].rolling(window=5).mean()\n    \n    # Calculate VWAP with 5-day moving average\n    tp = (df['high'] + df['low'] + ma_5) / 3\n    vwap = (df['volume'] * tp).cumsum() / df['volume'].cumsum()\n    \n    # Combine factors\n    heuristics_matrix = roc + (vwap - df['close'])\n    \n    return heuristics_matrix",
          "objective": -0.03226,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm combines the 20-day rate of change (ROC) of the closing price with a 5-day moving average of the volume-weighted average price (VWAP) to generate a more smoothed and interpretable alpha factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def calculate_roc(column, n):\n        return (column - column.shift(n)) / column.shift(n)\n\n    # Calculate ROC over a 20-day period\n    roc = calculate_roc(df['close'], 20)\n    \n    # Calculate VWAP\n    tp = (df['high'] + df['low'] + df['close']) / 3\n    vwap = (df['volume'] * tp).cumsum() / df['volume'].cumsum()\n    \n    # Calculate 5-day moving average of VWAP\n    vwap_ma5 = vwap.rolling(window=5).mean()\n    \n    # Combine factors\n    heuristics_matrix = roc + (vwap_ma5 - df['close'])\n    \n    return heuristics_matrix",
          "objective": -0.03217,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm combines the rate of change (ROC) of the closing price over a 20-day period with the relative difference between the VWAP and the simple moving average (SMA) of the closing price to generate a novel alpha factor.",
          "code": "def heuristics_v2(df):\n    def calculate_roc(column, n):\n        return (column - column.shift(n)) / column.shift(n)\n\n    # Calculate ROC over a 20-day period\n    roc = calculate_roc(df['close'], 20)\n    \n    # Calculate VWAP\n    tp = (df['high'] + df['low'] + df['close']) / 3\n    vwap = (df['volume'] * tp).cumsum() / df['volume'].cumsum()\n    \n    # Calculate SMA over a 10-day period\n    sma = df['close'].rolling(window=10).mean()\n    \n    # Combine factors\n    heuristics_matrix = roc + (vwap - sma) / sma\n    \n    return heuristics_matrix",
          "objective": -0.02781,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a momentum-based alpha factor by assessing the ratio of the current closing price to the average closing price over the past 60 days, aiming to capture a longer-term relative strength of recent price movements.",
          "code": "def heuristics_v2(df):\n    # Calculate the 60-day average of closing prices\n    close_avg_60 = df['close'].rolling(window=60).mean()\n    \n    # Compute the alpha factor as the ratio of the current closing price to the 60-day average of closing prices\n    heuristics_matrix = (df['close'] / close_avg_60).dropna()\n    \n    return heuristics_matrix",
          "objective": -0.0252,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the rate of change (ROC) over a 10-day period and combines it with the relative difference between the VWAP and a 20-day simple moving average (SMA) to generate an alpha factor.",
          "code": "def heuristics_v2(df):\n    def calculate_roc(column, n):\n        return (column - column.shift(n)) / column.shift(n)\n\n    # Calculate ROC over a 10-day period\n    roc = calculate_roc(df['close'], 10)\n    \n    # Calculate VWAP\n    tp = (df['high'] + df['low'] + df['close']) / 3\n    vwap = (df['volume'] * tp).cumsum() / df['volume'].cumsum()\n    \n    # Calculate SMA over a 20-day period\n    sma = df['close'].rolling(window=20).mean()\n    \n    # Combine factors\n    heuristics_matrix = roc + (vwap - sma) / sma\n    \n    return heuristics_matrix",
          "objective": -0.02502,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a volatility-adjusted alpha factor by assessing the ratio of the current closing price to the average closing price over the past 50 days, aiming to capture the relative strength with a longer-term perspective.",
          "code": "def heuristics_v2(df):\n    # Calculate the 50-day average of closing prices\n    close_avg_50 = df['close'].rolling(window=50).mean()\n    \n    # Compute the alpha factor as the ratio of the current closing price to the 50-day average of closing prices\n    heuristics_matrix = (df['close'] / close_avg_50).dropna()\n    \n    return heuristics_matrix",
          "objective": -0.02491,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a momentum-based alpha factor by assessing the ratio of the current closing price to the exponentially weighted moving average (EWMA) of the closing prices over the past 30 days, aiming to give more weight to recent price movements.",
          "code": "def heuristics_v2(df):\n    # Calculate the 30-day exponentially weighted moving average of closing prices\n    close_ewma_30 = df['close'].ewm(span=30).mean()\n    \n    # Compute the alpha factor as the ratio of the current closing price to the 30-day EWMA of closing prices\n    heuristics_matrix = (df['close'] / close_ewma_30).dropna()\n    \n    return heuristics_matrix",
          "objective": -0.02307,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of the momentum over different periods and the percentage price oscillator (PPO), with adjusted weights to emphasize longer-term momentum and PPO signals.",
          "code": "def heuristics_v2(df):\n    def calculate_momentum(column, n):\n        return column - column.shift(n)\n\n    def calculate_ppo(close, short_window=12, long_window=26):\n        short_ema = close.ewm(span=short_window, adjust=False).mean()\n        long_ema = close.ewm(span=long_window, adjust=False).mean()\n        ppo = ((short_ema - long_ema) / long_ema) * 100\n        return ppo\n\n    momentum_short = calculate_momentum(df['close'], 5)\n    momentum_medium = calculate_momentum(df['close'], 21)\n    momentum_long = calculate_momentum(df['close'], 63)\n    ppo = calculate_ppo(df['close'])\n\n    heuristics_matrix = 0.1 * momentum_short + 0.2 * momentum_medium + 0.3 * momentum_long + 0.4 * ppo\n    return heuristics_matrix",
          "objective": -0.0214,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted moving average convergence-divergence (MACD) and a relative strength index (RSI), then combines them with a simple momentum factor.",
          "code": "def heuristics_v2(df):\n    short_window = 10\n    long_window = 30\n    signal_window = 9\n    rsi_window = 14\n    momentum_window = 5\n    \n    # Calculate short and long moving averages\n    ma_short = df['close'].rolling(window=short_window, min_periods=short_window).mean()\n    ma_long = df['close'].rolling(window=long_window, min_periods=long_window).mean()\n    \n    # Calculate MACD\n    macd_line = ma_short - ma_long\n    signal_line = macd_line.rolling(window=signal_window, min_periods=signal_window).mean()\n    macd_hist = macd_line - signal_line\n    \n    # Calculate RSI\n    delta = df['close'].diff(1)\n    gain = (delta.where(delta > 0, 0)).fillna(0)\n    loss = (-delta.where(delta < 0, 0)).fillna(0)\n    avg_gain = gain.rolling(window=rsi_window, min_periods=rsi_window).mean()\n    avg_loss = loss.rolling(window=rsi_window, min_periods=rsi_window).mean()\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate Momentum\n    momentum = df['close'] - df['close'].shift(momentum_window)\n    \n    # Combine factors\n    heuristics_matrix = macd_hist + (rsi - 50) + momentum\n    \n    return heuristics_matrix",
          "objective": -0.02098,
          "other_inf": null
     }
]