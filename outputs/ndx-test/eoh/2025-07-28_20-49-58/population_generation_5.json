[
     {
          "algorithm": "The new algorithm calculates the ROC over a 30-day period, incorporates a 10-day moving average of the closing price into the VWAP calculation, and adjusts the final heuristic matrix by incorporating a momentum factor derived from a 30-day ROC, with an additional volatility adjustment based on the standard deviation of the last 10 days' close prices.",
          "code": "def heuristics_v2(df):\n    def calculate_roc(column, n):\n        return (column - column.shift(n)) / column.shift(n)\n\n    # Calculate ROC over a 30-day period\n    roc = calculate_roc(df['close'], 30)\n    \n    # Calculate 10-day moving average of the closing price\n    ma_10 = df['close'].rolling(window=10).mean()\n    \n    # Calculate VWAP with 10-day moving average\n    tp = (df['high'] + df['low'] + ma_10) / 3\n    vwap = (df['volume'] * tp).cumsum() / df['volume'].cumsum()\n    \n    # Calculate 10-day standard deviation of the closing price as a measure of volatility\n    std_dev_10 = df['close'].rolling(window=10).std()\n    \n    # Adjust the heuristics matrix with momentum and volatility\n    heuristics_matrix = roc + (vwap - df['close']) + roc.rolling(window=10).mean() - std_dev_10\n    \n    return heuristics_matrix",
          "objective": -0.03458,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes the ROC over a 20-day period, includes a 5-day moving average of the closing price in the VWAP calculation, and refines the heuristics matrix by integrating a momentum factor based on the 20-day ROC, along with an additional term that captures volatility using the standard deviation of the last 10 days' closing prices.",
          "code": "def heuristics_v2(df):\n    def calculate_roc(column, n):\n        return (column - column.shift(n)) / column.shift(n)\n    \n    # Calculate ROC over a 20-day period\n    roc = calculate_roc(df['close'], 20)\n    \n    # Calculate 5-day moving average of the closing price\n    ma_5 = df['close'].rolling(window=5).mean()\n    \n    # Calculate VWAP with 5-day moving average\n    tp = (df['high'] + df['low'] + ma_5) / 3\n    vwap = (df['volume'] * tp).cumsum() / df['volume'].cumsum()\n    \n    # Capture the 10-day volatility of the closing prices\n    vol_10 = df['close'].rolling(window=10).std()\n    \n    # Adjust the heuristics matrix with momentum and volatility\n    heuristics_matrix = roc + (vwap - df['close']) + roc.rolling(window=5).mean() - vol_10\n    \n    return heuristics_matrix",
          "objective": -0.03404,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ROC over a 10-day period, incorporates a 10-day simple moving average (SMA) of the closing price in the VWAP calculation, and adjusts the final heuristic matrix using a momentum factor based on a 10-day ROC, with a volatility adjustment from the 10-day standard deviation of close prices.",
          "code": "def heuristics_v2(df):\n    def calculate_roc(column, n):\n        return (column - column.shift(n)) / column.shift(n)\n\n    # Calculate ROC over a 10-day period\n    roc = calculate_roc(df['close'], 10)\n    \n    # Calculate 10-day SMA of the closing price\n    sma_10 = df['close'].rolling(window=10).mean()\n    \n    # Calculate VWAP with 10-day SMA\n    tp = (df['high'] + df['low'] + sma_10) / 3\n    vwap = (df['volume'] * tp).cumsum() / df['volume'].cumsum()\n    \n    # Calculate 10-day standard deviation of the closing price as a measure of volatility\n    std_dev_10 = df['close'].rolling(window=10).std()\n    \n    # Adjust the heuristics matrix with momentum and volatility\n    heuristics_matrix = roc + (vwap - df['close']) + roc.rolling(window=10).mean() - std_dev_10\n    \n    return heuristics_matrix",
          "objective": -0.03396,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the 10-day rate of change (ROC) of the closing price, combines it with the difference between a 15-day simple moving average (SMA) of the volume-weighted average price (VWAP) and the closing price, and then adds the 7-day momentum of the closing price to capture an additional layer of short-term momentum.",
          "code": "def heuristics_v2(df):\n    def calculate_roc(column, n):\n        return (column - column.shift(n)) / column.shift(n)\n    \n    # Calculate ROC over a 10-day period\n    roc = calculate_roc(df['close'], 10)\n    \n    # Calculate VWAP\n    tp = (df['high'] + df['low'] + df['close']) / 3\n    vwap = (df['volume'] * tp).cumsum() / df['volume'].cumsum()\n    \n    # Calculate 15-day SMA of VWAP\n    vwap_sma15 = vwap.rolling(window=15).mean()\n    \n    # Calculate 7-day momentum\n    momentum_7 = df['close'] - df['close'].shift(7)\n    \n    # Combine factors\n    heuristics_matrix = roc + (vwap_sma15 - df['close']) + momentum_7\n    \n    return heuristics_matrix",
          "objective": -0.03392,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ROC over a 20-day period, uses a 10-day moving average of the closing price in the VWAP calculation, and modifies the heuristics matrix by incorporating a 15-day simple moving average of the ROC for momentum, alongside a volatility term based on the average true range (ATR) of the last 21 days.",
          "code": "def heuristics_v2(df):\n    def calculate_roc(column, n):\n        return (column - column.shift(n)) / column.shift(n)\n    \n    # Calculate ROC over a 20-day period\n    roc = calculate_roc(df['close'], 20)\n    \n    # Calculate 10-day moving average of the closing price\n    ma_10 = df['close'].rolling(window=10).mean()\n    \n    # Calculate VWAP with 10-day moving average\n    tp = (df['high'] + df['low'] + ma_10) / 3\n    vwap = (df['volume'] * tp).cumsum() / df['volume'].cumsum()\n    \n    # Capture the 21-day ATR\n    atr = (df['high'] - df['low']).rolling(window=21).mean()\n    \n    # Adjust the heuristics matrix with 15-day SMA of ROC and ATR\n    heuristics_matrix = roc + (vwap - df['close']) + roc.rolling(window=15).mean() - atr\n    \n    return heuristics_matrix",
          "objective": -0.03381,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes the ROC over a 20-day period, uses a 5-day moving average of the closing price in the VWAP calculation, and modifies the heuristics matrix by incorporating a 15-day simple moving average of the ROC for momentum, alongside a volatility term based on the standard deviation (StdDev) of the last 20 days.",
          "code": "def heuristics_v2(df):\n    def calculate_roc(column, n):\n        return (column - column.shift(n)) / column.shift(n)\n    \n    # Calculate ROC over a 20-day period\n    roc = calculate_roc(df['close'], 20)\n    \n    # Calculate 5-day moving average of the closing price\n    ma_5 = df['close'].rolling(window=5).mean()\n    \n    # Calculate VWAP with 5-day moving average\n    tp = (df['high'] + df['low'] + ma_5) / 3\n    vwap = (df['volume'] * tp).cumsum() / df['volume'].cumsum()\n    \n    # Capture the 20-day StdDev\n    std_dev_20 = df['close'].rolling(window=20).std()\n    \n    # Adjust the heuristics matrix with 15-day SMA of ROC and StdDev\n    heuristics_matrix = roc + (vwap - df['close']) + roc.rolling(window=15).mean() - std_dev_20\n    \n    return heuristics_matrix",
          "objective": -0.03372,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes the ROC over a 15-day period, uses a 7-day moving average of the closing price in the VWAP calculation, and modifies the heuristics matrix by incorporating a 10-day simple moving average of the ROC for momentum, alongside a volatility term based on the average true range (ATR) of the last 14 days.",
          "code": "def heuristics_v2(df):\n    def calculate_roc(column, n):\n        return (column - column.shift(n)) / column.shift(n)\n    \n    # Calculate ROC over a 15-day period\n    roc = calculate_roc(df['close'], 15)\n    \n    # Calculate 7-day moving average of the closing price\n    ma_7 = df['close'].rolling(window=7).mean()\n    \n    # Calculate VWAP with 7-day moving average\n    tp = (df['high'] + df['low'] + ma_7) / 3\n    vwap = (df['volume'] * tp).cumsum() / df['volume'].cumsum()\n    \n    # Capture the 14-day ATR\n    atr = df['high'].combine(df['low'], max) - df['low'].combine(df['high'], min)\n    atr_14 = atr.rolling(window=14).mean()\n    \n    # Adjust the heuristics matrix with 10-day SMA of ROC and ATR\n    heuristics_matrix = roc + (vwap - df['close']) + roc.rolling(window=10).mean() - atr_14\n    \n    return heuristics_matrix",
          "objective": -0.03358,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ROC over a 15-day period, includes a 7-day exponential moving average of the closing price into the VWAP calculation, and adjusts the final heuristic matrix by incorporating a momentum factor derived from a 15-day ROC, with an additional volatility adjustment based on the standard deviation of the last 7 days' close prices.",
          "code": "def heuristics_v2(df):\n    def calculate_roc(column, n):\n        return (column - column.shift(n)) / column.shift(n)\n\n    # Calculate ROC over a 15-day period\n    roc = calculate_roc(df['close'], 15)\n    \n    # Calculate 7-day exponential moving average of the closing price\n    ema_7 = df['close'].ewm(span=7, adjust=False).mean()\n    \n    # Calculate VWAP with 7-day exponential moving average\n    tp = (df['high'] + df['low'] + ema_7) / 3\n    vwap = (df['volume'] * tp).cumsum() / df['volume'].cumsum()\n    \n    # Calculate 7-day standard deviation of the closing price as a measure of volatility\n    std_dev_7 = df['close'].rolling(window=7).std()\n    \n    # Adjust the heuristics matrix with momentum and volatility\n    heuristics_matrix = roc + (vwap - df['close']) + roc.rolling(window=7).mean() - std_dev_7\n    \n    return heuristics_matrix",
          "objective": -0.03353,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ROC over a 10-day period, includes a 30-day simple moving average (SMA) of the closing price in the VWAP calculation, and adjusts the final heuristic matrix with a momentum factor based on a 10-day ROC, supplemented by a volatility adjustment from the 30-day standard deviation of close prices.",
          "code": "def heuristics_v2(df):\n    def calculate_roc(column, n):\n        return (column - column.shift(n)) / column.shift(n)\n\n    # Calculate ROC over a 10-day period\n    roc = calculate_roc(df['close'], 10)\n    \n    # Calculate 30-day SMA of the closing price\n    sma_30 = df['close'].rolling(window=30).mean()\n    \n    # Calculate VWAP with 30-day SMA\n    tp = (df['high'] + df['low'] + sma_30) / 3\n    vwap = (df['volume'] * tp).cumsum() / df['volume'].cumsum()\n    \n    # Calculate 30-day standard deviation of the closing price as a measure of volatility\n    std_dev_30 = df['close'].rolling(window=30).std()\n    \n    # Adjust the heuristics matrix with momentum and volatility\n    heuristics_matrix = roc + (vwap - df['close']) + roc.rolling(window=10).mean() - std_dev_30\n    \n    return heuristics_matrix",
          "objective": -0.03349,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ROC over a 20-day period, includes a 20-day exponential moving average (EMA) of the closing price in the VWAP calculation, and adjusts the final heuristic matrix with a momentum factor based on a 20-day ROC, supplemented by a volatility adjustment from the 20-day standard deviation of close prices.",
          "code": "def heuristics_v2(df):\n    def calculate_roc(column, n):\n        return (column - column.shift(n)) / column.shift(n)\n\n    # Calculate ROC over a 20-day period\n    roc = calculate_roc(df['close'], 20)\n    \n    # Calculate 20-day EMA of the closing price\n    ema_20 = df['close'].ewm(span=20, adjust=False).mean()\n    \n    # Calculate VWAP with 20-day EMA\n    tp = (df['high'] + df['low'] + ema_20) / 3\n    vwap = (df['volume'] * tp).cumsum() / df['volume'].cumsum()\n    \n    # Calculate 20-day standard deviation of the closing price as a measure of volatility\n    std_dev_20 = df['close'].rolling(window=20).std()\n    \n    # Adjust the heuristics matrix with momentum and volatility\n    heuristics_matrix = roc + (vwap - df['close']) + roc.rolling(window=20).mean() - std_dev_20\n    \n    return heuristics_matrix",
          "objective": -0.03332,
          "other_inf": null
     }
]