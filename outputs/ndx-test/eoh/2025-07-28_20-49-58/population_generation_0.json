[
     {
          "algorithm": "The algorithm involves calculating a weighted combination of moving averages and relative strength index (RSI) over different time windows to generate an interpretable alpha factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    short_window = 10\n    long_window = 30\n    rsi_window = 14\n    \n    # Calculate short and long moving averages\n    ma_short = df['close'].rolling(window=short_window, min_periods=short_window).mean()\n    ma_long = df['close'].rolling(window=long_window, min_periods=long_window).mean()\n    \n    # Calculate RSI\n    delta = df['close'].diff(1)\n    gain = (delta.where(delta > 0, 0)).fillna(0)\n    loss = (-delta.where(delta < 0, 0)).fillna(0)\n    avg_gain = gain.rolling(window=rsi_window, min_periods=rsi_window).mean()\n    avg_loss = loss.rolling(window=rsi_window, min_periods=rsi_window).mean()\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Combine factors\n    heuristics_matrix = (ma_short - ma_long) + (rsi - 50)\n    \n    return heuristics_matrix",
          "objective": -0.01956,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates the momentum of the close price and combines it with the relative strength index (RSI) calculated from the same, to generate a novel alpha factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the momentum of the close price by comparing it with the close price 10 days ago\n    momentum = df['close'].pct_change(10)\n    # Calculate the RSI based on the last 14 days' close prices\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    # Combine momentum and RSI into a single heuristic\n    heuristics_matrix = 0.5 * (momentum + rsi.shift(1))\n    return heuristics_matrix",
          "objective": -0.01873,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a weighted sum of the rate of change over different periods and the relative strength index (RSI), to generate an interpretable heuristic factor for predicting future stock returns.",
          "code": "def heuristics_v2(df):\n    def calculate_roc(column, n):\n        return (column - column.shift(n)) / column.shift(n)\n\n    def calculate_rsi(close, period=14):\n        delta = close.diff()\n        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()\n        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()\n        rs = gain / loss\n        rsi = 100 - (100 / (1 + rs))\n        return rsi\n    \n    roc_short = calculate_roc(df['close'], 5)\n    roc_medium = calculate_roc(df['close'], 21)\n    roc_long = calculate_roc(df['close'], 63)\n    rsi = calculate_rsi(df['close'])\n\n    heuristics_matrix = 0.3 * roc_short + 0.3 * roc_medium + 0.3 * roc_long + 0.1 * rsi\n    return heuristics_matrix",
          "objective": -0.01731,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a custom momentum-based alpha factor using the percentage change in volume and the rate of change in closing prices over a 10-day window.",
          "code": "def heuristics_v2(df):\n    # Calculate the 10-day percentage change in volume\n    volume_change = df['volume'].pct_change(10)\n    \n    # Calculate the 10-day rate of change in closing prices\n    close_roc = df['close'].diff(10) / df['close'].shift(10)\n    \n    # Compute the alpha factor as the product of volume change and rate of change in closing prices\n    heuristics_matrix = volume_change * close_roc\n    \n    return heuristics_matrix",
          "objective": -0.01653,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm leverages a combination of moving averages and volatility to create an interpretive alpha factor, which is calculated by subtracting the long-term moving average from the short-term moving average and then dividing this difference by the rolling standard deviation of returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    short_window = 10\n    long_window = 30\n    df['short_mavg'] = df['close'].rolling(window=short_window, min_periods=short_window).mean()\n    df['long_mavg'] = df['close'].rolling(window=long_window, min_periods=long_window).mean()\n    df['volatility'] = df['close'].pct_change().rolling(window=long_window, min_periods=long_window).std()\n    heuristics_matrix = (df['short_mavg'] - df['long_mavg']) / df['volatility']\n    return heuristics_matrix",
          "objective": -0.01053,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm leverages a combination of moving averages and volatility measurements to construct a heuristics matrix, where the main steps include calculating short-term and long-term moving averages, determining daily return volatility, and combining these into a predictive factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate short-term (5 days) and long-term (30 days) moving averages for closing prices\n    df['MA_5'] = df['close'].rolling(window=5).mean()\n    df['MA_30'] = df['close'].rolling(window=30).mean()\n    \n    # Daily return calculation\n    df['Return'] = df['close'].pct_change()\n    \n    # Volatility over the last 5 days\n    df['Vol_5'] = df['Return'].rolling(window=5).std()\n    \n    # Constructing the heuristics factor: (MA_5 - MA_30) / Vol_5\n    heuristics_matrix = (df['MA_5'] - df['MA_30']) / df['Vol_5']\n    \n    return heuristics_matrix",
          "objective": -0.00892,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a novel set of heuristics based on price and volume trends, incorporating momentum, volatility, and trading activity indicators to predict future stock returns.",
          "code": "def heuristics_v2(df):\n    def momentum(df, window):\n        return df['close'].pct_change(window)\n\n    def volatility(df, window):\n        return df['close'].pct_change().rolling(window=window).std()\n\n    def trading_activity(df, window):\n        return df['volume'].rolling(window=window).mean()\n\n    mom_5 = momentum(df, 5)\n    mom_20 = momentum(df, 20)\n    vol_5 = volatility(df, 5)\n    vol_20 = volatility(df, 20)\n    act_5 = trading_activity(df, 5)\n    act_20 = trading_activity(df, 20)\n\n    heuristics_matrix = (mom_5 + mom_20 + vol_5 + vol_20 + act_5 + act_20) / 6\n    return heuristics_matrix",
          "objective": -0.0069,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes the ratio of the average of the last 5 days' closing prices to the volume, aiming to capture price momentum relative to trading activity.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    heuristics_matrix = (df['close'].rolling(window=5).mean() / df['volume']).dropna()\n    return heuristics_matrix",
          "objective": -0.00542,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm constructs an interpretable alpha factor by calculating the ratio of today's closing price to the moving average of volume over a specified window, aiming to capture the relationship between price momentum and trading activity.",
          "code": "def heuristics_v2(df):\n    window = 10  # Define the rolling window size for the moving average\n    df['Volume_MA'] = df['volume'].rolling(window=window).mean()\n    heuristics_matrix = (df['close'] / df['Volume_MA']).dropna()\n    return heuristics_matrix",
          "objective": -0.00355,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a factor value for each date by combining the momentum of the closing price and the relative change in volume, using a weighted sum where the weights are determined by the historical volatility of the close prices.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily returns\n    daily_returns = df['close'].pct_change()\n    \n    # Calculate momentum (using 10-day simple moving average return)\n    momentum = daily_returns.rolling(window=10).mean().fillna(0)\n    \n    # Calculate relative volume change\n    volume_change = df['volume'].pct_change().fillna(0)\n    \n    # Calculate historical volatility of close prices (using 30-day rolling standard deviation of daily returns)\n    volatility = daily_returns.rolling(window=30).std().fillna(0)\n    \n    # Weighted sum to generate heuristics matrix\n    heuristics_matrix = (momentum * (1 - volatility)) + (volume_change * volatility)\n    \n    return heuristics_matrix",
          "objective": -0.00136,
          "other_inf": null
     }
]