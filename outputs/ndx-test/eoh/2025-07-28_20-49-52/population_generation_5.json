[
     {
          "algorithm": "The new algorithm calculates the ratio of the volume-weighted average price (VWAP) for the last 5 days to the VWAP for the next 15 days, then applies a simple moving average (SMA) for smoothing.",
          "code": "def heuristics_v2(df):\n    # Calculate the last 5 days' VWAP\n    vwap_last_5 = ((df['close'] + df['open']) / 2 * df['volume']).rolling(window=5).sum() / df['volume'].rolling(window=5).sum()\n    # Calculate the next 15 days' VWAP\n    vwap_next_15 = ((df['close'].shift(-15) + df['open'].shift(-15)) / 2 * df['volume'].shift(-15)).rolling(window=15).sum() / df['volume'].shift(-15).rolling(window=15).sum()\n    # Calculate the factor as the ratio of the two VWAPs\n    factor_values = vwap_last_5 / vwap_next_15\n    # Apply a simple moving average for smoothing the factor values\n    smoothed_factor = factor_values.rolling(window=10).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.5377,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the sum of the last 5 days' high prices to the sum of the next 15 days' opening prices, then applies a simple moving average for smoothing.",
          "code": "def heuristics_v2(df):\n    # Calculate the sum of the last 5 days' high prices\n    sum_last_5_high = df['high'].rolling(window=5).sum()\n    # Calculate the sum of the next 15 days' opening prices\n    sum_next_15_open = df['open'].shift(-15).rolling(window=15).sum()\n    # Calculate the factor as the ratio of the two sums\n    factor_values = sum_last_5_high / sum_next_15_open\n    # Apply a simple moving average for smoothing the factor values\n    smoothed_factor = factor_values.rolling(window=10).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.49957,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes the ratio of the volume-weighted average price (VWAP) for the last 10 days to the VWAP for the next 10 days, then applies an exponential moving average for smoothing.",
          "code": "def heuristics_v2(df):\n    # Calculate the last 10 days' VWAP\n    vwap_last_10 = ((df['close'] + df['open']) / 2 * df['volume']).rolling(window=10).sum() / df['volume'].rolling(window=10).sum()\n    # Calculate the next 10 days' VWAP\n    vwap_next_10 = ((df['close'].shift(-10) + df['open'].shift(-10)) / 2 * df['volume'].shift(-10)).rolling(window=10).sum() / df['volume'].shift(-10).rolling(window=10).sum()\n    # Calculate the factor as the ratio of the two VWAPs\n    factor_values = vwap_last_10 / vwap_next_10\n    # Apply an exponential moving average for smoothing the factor values\n    smoothed_factor = factor_values.ewm(span=10, adjust=False).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.43802,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the volume-weighted average price (VWAP) for the last 20 days to the VWAP for the next 20 days, then applies a simple moving average for smoothing.",
          "code": "def heuristics_v2(df):\n    # Calculate the last 20 days' VWAP\n    vwap_last_20 = ((df['close'] + df['open']) / 2 * df['volume']).rolling(window=20).sum() / df['volume'].rolling(window=20).sum()\n    # Calculate the next 20 days' VWAP\n    vwap_next_20 = ((df['close'].shift(-20) + df['open'].shift(-20)) / 2 * df['volume'].shift(-20)).rolling(window=20).sum() / df['volume'].shift(-20).rolling(window=20).sum()\n    # Calculate the factor as the ratio of the two VWAPs\n    factor_values = vwap_last_20 / vwap_next_20\n    # Apply a simple moving average for smoothing the factor values\n    smoothed_factor = factor_values.rolling(window=10).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.42961,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the average of the last 10 days' closing prices to the average of the next 10 days' high prices, then applies an exponential moving average for smoothing.",
          "code": "def heuristics_v2(df):\n    # Calculate the average of the last 10 days' closing prices\n    avg_last_10_close = df['close'].rolling(window=10).mean()\n    # Calculate the average of the next 10 days' high prices\n    avg_next_10_high = df['high'].shift(-10).rolling(window=10).mean()\n    # Calculate the factor as the ratio of the two averages\n    factor_values = avg_last_10_close / avg_next_10_high\n    # Apply an exponential moving average for smoothing the factor values\n    smoothed_factor = factor_values.ewm(span=10, adjust=False).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.41468,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the volume-weighted average price (VWAP) for the last 5 days to the VWAP for the next 10 days, then applies a simple moving average (SMA) for smoothing.",
          "code": "def heuristics_v2(df):\n    # Calculate the last 5 days' VWAP\n    vwap_last_5 = ((df['close'] + df['open']) / 2 * df['volume']).rolling(window=5).sum() / df['volume'].rolling(window=5).sum()\n    # Calculate the next 10 days' VWAP\n    vwap_next_10 = ((df['close'].shift(-10) + df['open'].shift(-10)) / 2 * df['volume'].shift(-10)).rolling(window=10).sum() / df['volume'].shift(-10).rolling(window=10).sum()\n    # Calculate the factor as the ratio of the two VWAPs\n    factor_values = vwap_last_5 / vwap_next_10\n    # Apply a simple moving average for smoothing the factor values\n    smoothed_factor = factor_values.rolling(window=10).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.40997,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the average of the last 15 days' closing prices to the sum of the next 15 days' low and high prices, then applies a simple moving average for smoothing.",
          "code": "def heuristics_v2(df):\n    # Calculate the average of the last 15 days' closing prices\n    avg_last_15_close = df['close'].rolling(window=15).mean()\n    # Calculate the sum of the next 15 days' low and high prices\n    sum_next_15_low_high = (df['low'].shift(-15) + df['high'].shift(-15)).rolling(window=15).sum()\n    # Calculate the factor as the ratio of the two calculated values\n    factor_values = avg_last_15_close / sum_next_15_low_high\n    # Apply a simple moving average for smoothing the factor values\n    smoothed_factor = factor_values.rolling(window=10).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.39469,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the average of the last 10 days' closing prices to the average of the next 10 days' opening prices, then applies an exponential moving average for smoothing.",
          "code": "def heuristics_v2(df):\n    # Calculate the average of the last 10 days' closing prices\n    avg_last_10_close = df['close'].rolling(window=10).mean()\n    # Calculate the average of the next 10 days' opening prices\n    avg_next_10_open = df['open'].shift(-10).rolling(window=10).mean()\n    # Calculate the factor as the ratio of the two averages\n    factor_values = avg_last_10_close / avg_next_10_open\n    # Apply an exponential moving average for smoothing the factor values\n    smoothed_factor = factor_values.ewm(span=10, adjust=False).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.39425,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the average of the last 5 days' closing prices to the average of the next 5 days' low prices, then applies an exponential moving average with a span of 5 for smoothing.",
          "code": "def heuristics_v2(df):\n    avg_last_5_close = df['close'].rolling(window=5).mean()\n    avg_next_5_low = df['low'].shift(-5).rolling(window=5).mean()\n    factor_values = avg_last_5_close / avg_next_5_low\n    smoothed_factor = factor_values.ewm(span=5, adjust=False).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.3779,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the sum of the last 10 days' closing prices to the sum of the next 10 days' low prices, then applies a simple moving average for smoothing.",
          "code": "def heuristics_v2(df):\n    # Calculate the sum of the last 10 days' closing prices\n    sum_last_10_close = df['close'].rolling(window=10).sum()\n    # Calculate the sum of the next 10 days' low prices\n    sum_next_10_low = df['low'].shift(-10).rolling(window=10).sum()\n    # Calculate the factor as the ratio of the two sums\n    factor_values = sum_last_10_close / sum_next_10_low\n    # Apply a simple moving average for smoothing the factor values\n    smoothed_factor = factor_values.rolling(window=10).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.30102,
          "other_inf": null
     }
]