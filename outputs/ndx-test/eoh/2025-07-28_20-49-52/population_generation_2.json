[
     {
          "algorithm": "The new algorithm computes a modified volume-weighted average price using only the high and low prices, then calculates the ratio of this modified VWAP to the close price, and applies a simple moving average for smoothing.",
          "code": "def heuristics_v2(df):\n    # Calculate the modified Volume-Weighted Average Price (VWAP) using high and low prices\n    vwap = (df['volume'] * (df['high'] + df['low']) / 2).cumsum() / df['volume'].cumsum()\n    # Calculate the factor as the ratio of modified VWAP to close price\n    factor_values = vwap / df['close']\n    # Apply a simple moving average for smoothing the factor values\n    smoothed_factor = factor_values.rolling(window=10).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.03615,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies unique patterns in historical stock data by calculating the ratio of volume-weighted average price to the closing price, then applying a smoothing technique to generate more stable and interpretable alpha factors.",
          "code": "def heuristics_v2(df):\n    # Calculate the Volume-Weighted Average Price (VWAP)\n    vwap = (df['volume'] * (df['high'] + df['low'] + df['close']) / 3).cumsum() / df['volume'].cumsum()\n    # Calculate the factor as the ratio of VWAP to close price\n    factor_values = vwap / df['close']\n    # Apply a simple moving average for smoothing the factor values\n    smoothed_factor = factor_values.rolling(window=10).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.03613,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the volume-weighted average price (VWAP) and then computes the factor as the ratio of VWAP to the closing price, which is then smoothed using a simple moving average.",
          "code": "def heuristics_v2(df):\n    # Calculate the Volume-Weighted Average Price (VWAP)\n    vwap = (df['volume'] * (df['high'] + df['low'] + df['close']) / 3).cumsum() / df['volume'].cumsum()\n    # Calculate the factor as the ratio of VWAP to close price\n    factor_values = vwap / df['close']\n    # Apply a simple moving average for smoothing the factor values\n    smoothed_factor = factor_values.rolling(window=10, min_periods=1).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.03606,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of VWAP to the geometric mean of high, low, and close prices, then applies a simple moving average for smoothing.",
          "code": "def heuristics_v2(df):\n    # Calculate the Volume-Weighted Average Price (VWAP)\n    vwap = (df['volume'] * (df['high'] + df['low'] + df['close']) / 3).cumsum() / df['volume'].cumsum()\n    # Calculate the geometric mean of high, low, and close prices\n    geom_mean_price = (df['high'] * df['low'] * df['close']) ** (1/3)\n    # Calculate the factor as the ratio of VWAP to the geometric mean of high, low, and close prices\n    factor_values = vwap / geom_mean_price\n    # Apply a simple moving average for smoothing the factor values\n    smoothed_factor = factor_values.rolling(window=10).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.03595,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the VWAP to the mean of the high, low, and close prices, then applies a simple moving average for smoothing.",
          "code": "def heuristics_v2(df):\n    # Calculate the Volume-Weighted Average Price (VWAP)\n    vwap = (df['volume'] * (df['high'] + df['low'] + df['close']) / 3).cumsum() / df['volume'].cumsum()\n    # Calculate the factor as the ratio of VWAP to the mean of high, low, and close prices\n    mid_price = df[['high', 'low', 'close']].mean(axis=1)\n    factor_values = vwap / mid_price\n    # Apply a simple moving average for smoothing the factor values\n    smoothed_factor = factor_values.rolling(window=10).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.03594,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the volume-weighted average price (VWAP) to the mean of high and low prices, then applies a simple moving average for smoothing.",
          "code": "def heuristics_v2(df):\n    # Calculate the Volume-Weighted Average Price (VWAP)\n    vwap = (df['volume'] * (df['high'] + df['low'] + df['close']) / 3).cumsum() / df['volume'].cumsum()\n    # Calculate the mean of high and low prices\n    mean_price = (df['high'] + df['low']) / 2\n    # Calculate the factor as the ratio of VWAP to mean price\n    factor_values = vwap / mean_price\n    # Apply a simple moving average for smoothing the factor values\n    smoothed_factor = factor_values.rolling(window=10).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.03585,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the VWAP to the weighted average of the high, low, and close prices (with weights 0.5, 0.3, and 0.2 respectively), then applies a simple moving average for smoothing.",
          "code": "def heuristics_v2(df):\n    # Calculate the Volume-Weighted Average Price (VWAP)\n    vwap = (df['volume'] * (df['high'] + df['low'] + df['close']) / 3).cumsum() / df['volume'].cumsum()\n    # Calculate the weighted average of high, low, and close prices\n    weighted_avg_price = df['high'] * 0.5 + df['low'] * 0.3 + df['close'] * 0.2\n    # Calculate the factor as the ratio of VWAP to the weighted average price\n    factor_values = vwap / weighted_avg_price\n    # Apply a simple moving average for smoothing the factor values\n    smoothed_factor = factor_values.rolling(window=10).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.03584,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a modified volume-weighted average price using only the high and low prices, then calculates the ratio of this modified VWAP to the close price, and applies an exponential moving average for smoothing.",
          "code": "def heuristics_v2(df):\n    # Calculate the modified Volume-Weighted Average Price (VWAP) using high and low prices\n    vwap = (df['volume'] * (df['high'] + df['low']) / 2).cumsum() / df['volume'].cumsum()\n    # Calculate the factor as the ratio of modified VWAP to close price\n    factor_values = vwap / df['close']\n    # Apply an exponential moving average for smoothing the factor values\n    smoothed_factor = factor_values.ewm(span=10, adjust=False).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.03563,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the VWAP to the median of the high, low, and close prices, then applies an exponential moving average for smoothing.",
          "code": "def heuristics_v2(df):\n    # Calculate the Volume-Weighted Average Price (VWAP)\n    vwap = (df['volume'] * (df['high'] + df['low'] + df['close']) / 3).cumsum() / df['volume'].cumsum()\n    # Calculate the factor as the ratio of VWAP to the median of high, low, and close prices\n    mid_price = df[['high', 'low', 'close']].median(axis=1)\n    factor_values = vwap / mid_price\n    # Apply an exponential moving average for smoothing the factor values\n    smoothed_factor = factor_values.ewm(span=10, adjust=False).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.03562,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the volume-weighted average price (VWAP) to the median of the high, low, and close prices, then applies an exponential moving average for smoothing.",
          "code": "def heuristics_v2(df):\n    # Calculate the Volume-Weighted Average Price (VWAP)\n    vwap = (df['volume'] * (df['high'] + df['low'] + df['close']) / 3).cumsum() / df['volume'].cumsum()\n    # Calculate the factor as the ratio of VWAP to the median of high, low, and close prices\n    mid_price = df[['high', 'low', 'close']].median(axis=1)\n    factor_values = vwap / mid_price\n    # Apply an exponential moving average for smoothing the factor values\n    smoothed_factor = factor_values.ewm(span=10).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.03561,
          "other_inf": null
     }
]