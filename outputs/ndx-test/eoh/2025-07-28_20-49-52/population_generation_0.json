[
     {
          "algorithm": "The algorithm identifies unique patterns in historical stock data by calculating the ratio of volume-weighted average price to the closing price, then applying a smoothing technique to generate more stable and interpretable alpha factors.",
          "code": "def heuristics_v2(df):\n    # Calculate the Volume-Weighted Average Price (VWAP)\n    vwap = (df['volume'] * (df['high'] + df['low'] + df['close']) / 3).cumsum() / df['volume'].cumsum()\n    # Calculate the factor as the ratio of VWAP to close price\n    factor_values = vwap / df['close']\n    # Apply a simple moving average for smoothing the factor values\n    smoothed_factor = factor_values.rolling(window=10).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.03613,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm constructs a novel alpha factor by calculating the difference between the 20-day simple moving average of the closing price and the 5-day exponential moving average of the closing price, aiming to capture short-term momentum and mean reversion signals.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def sma(series, window):\n        return series.rolling(window=window).mean()\n\n    def ema(series, span):\n        return series.ewm(span=span, adjust=False).mean()\n    \n    df['SMA_20'] = sma(df['close'], 20)\n    df['EMA_5'] = ema(df['close'], 5)\n    heuristics_matrix = df['SMA_20'] - df['EMA_5']\n    return heuristics_matrix",
          "objective": -0.0187,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies patterns in the relationship between trading volume and price movements, using a combination of moving averages and volume shocks to generate alpha factors.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate short and long moving averages for closing prices\n    short_window = 5\n    long_window = 20\n    short_mavg = df['close'].rolling(window=short_window, min_periods=1).mean()\n    long_mavg = df['close'].rolling(window=long_window, min_periods=1).mean()\n\n    # Compute volume change\n    df['volume_change'] = df['volume'].pct_change().fillna(0)\n\n    # Identify volume shocks\n    volume_shock_threshold = 2\n    df['volume_shock'] = (df['volume_change'] > volume_shock_threshold).astype(int)\n\n    # Generate signal based on crossovers and volume shocks\n    df['signal'] = 0\n    df.loc[(short_mavg > long_mavg) & (df['volume_shock'] == 1), 'signal'] = 1\n    df.loc[(short_mavg < long_mavg) & (df['volume_shock'] == 1), 'signal'] = -1\n\n    heuristics_matrix = df['signal']\n    \n    return heuristics_matrix",
          "objective": -0.01834,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies patterns in market features by calculating the difference between the highest and lowest prices over a rolling window, then divides this difference by the closing price to generate an interpretative alpha factor.",
          "code": "def heuristics_v2(df):\n    heuristics_matrix = (df['high'].rolling(window=5).max() - df['low'].rolling(window=5).min()) / df['close']\n    return heuristics_matrix",
          "objective": -0.01794,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a set of technical indicators and statistical features from the input market data, combines them into an ensemble factor through a weighted sum approach, and outputs the resulting factor values as a pandas Series.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Compute simple moving averages\n    sma_short = df['close'].rolling(window=5).mean()\n    sma_long = df['close'].rolling(window=20).mean()\n    \n    # Calculate RSI\n    delta = df['close'].diff(1)\n    gain = (delta.where(delta > 0, 0)).fillna(0)\n    loss = (-delta.where(delta < 0, 0)).fillna(0)\n    avg_gain = gain.rolling(window=14).mean()\n    avg_loss = loss.rolling(window=14).mean()\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Compute Price Volume Trend\n    pvt = ((df['close'] - df['close'].shift(1)) / df['close'].shift(1)) * df['volume']\n    pvt = pvt.cumsum()\n    \n    # Combine factors into a weighted sum for the final heuristic\n    heuristics_matrix = (sma_short - sma_long) + rsi + pvt\n    \n    return heuristics_matrix",
          "objective": -0.01362,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm leverages the momentum and volatility of stock prices by calculating the difference between the current closing price and its moving average, then scaling it by the standard deviation of daily returns over a specified window, to generate interpretable alpha factors.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    window = 20  # Define the lookback window for moving average and std dev\n    df['Moving_Avg'] = df['close'].rolling(window=window).mean()\n    df['Std_Dev'] = df['close'].pct_change().rolling(window=window).std()\n    heuristics_matrix = (df['close'] - df['Moving_Avg']) / df['Std_Dev']\n    return heuristics_matrix",
          "objective": -0.01189,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a weighted sum of moving averages and their differences over different time horizons to create a novel alpha factor, capturing both momentum and mean reversion signals.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate short-term (10 days) and long-term (50 days) simple moving averages for 'close' price\n    df['SMA_10'] = df['close'].rolling(window=10).mean()\n    df['SMA_50'] = df['close'].rolling(window=50).mean()\n    \n    # Calculate the difference between the short-term and long-term SMAs\n    df['SMA_Diff'] = df['SMA_10'] - df['SMA_50']\n    \n    # Calculate the difference between current 'close' price and its 10-day SMA\n    df['Close_SMA_10_Diff'] = df['close'] - df['SMA_10']\n    \n    # Generate the final heuristic by combining the SMA_Diff and Close_SMA_10_Diff with weights\n    heuristics_matrix = 0.7 * df['SMA_Diff'] + 0.3 * df['Close_SMA_10_Diff']\n    \n    return heuristics_matrix",
          "objective": -0.01177,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm involves creating a composite factor by combining moving averages and volatility measures, then applying a linear combination to generate a heuristic score for each date.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate short-term and long-term moving averages\n    short_ma = df['close'].rolling(window=10).mean()\n    long_ma = df['close'].rolling(window=50).mean()\n    \n    # Calculate the difference between the short-term and long-term moving averages\n    ma_diff = short_ma - long_ma\n    \n    # Calculate the standard deviation (volatility) of the close prices over a 20-day window\n    volatility = df['close'].rolling(window=20).std()\n    \n    # Generate the heuristic score as a linear combination of the moving average difference and the volatility\n    heuristics_matrix = 0.7 * ma_diff - 0.3 * volatility\n    \n    return heuristics_matrix",
          "objective": -0.01127,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a set of heuristic alpha factors by combining moving averages, volume-weighted price changes, and price momentum indicators to predict future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    heuristics_matrix = pd.Series(index=df.index)\n    \n    # Simple Moving Averages\n    sma_5 = df['close'].rolling(window=5).mean()\n    sma_20 = df['close'].rolling(window=20).mean()\n    \n    # Volume-Weighted Price Change\n    vw_price_change = (df['close'] - df['open']) * df['volume']\n    \n    # Price Momentum\n    momentum = df['close'] / df['close'].shift(10) - 1\n    \n    # Combine heuristics into a single factor\n    heuristics_matrix = (sma_5 - sma_20) + vw_price_change + momentum\n    \n    return heuristics_matrix",
          "objective": -0.00717,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm involves calculating a weighted sum of percentage changes in close prices, volume, and the difference between high and low prices, with weights determined by their historical correlation to future returns.",
          "code": "def heuristics_v2(df):\n    df['close_change'] = df['close'].pct_change()\n    df['volume_change'] = df['volume'].pct_change()\n    df['high_low_diff'] = (df['high'] - df['low']) / df['close']\n    weights = [0.5, 0.3, 0.2]  # Example weights, can be adjusted based on further analysis\n    df['heuristic_value'] = df['close_change'] * weights[0] + df['volume_change'] * weights[1] + df['high_low_diff'] * weights[2]\n    heuristics_matrix = df['heuristic_value'].dropna()\n    return heuristics_matrix",
          "objective": -0.00708,
          "other_inf": null
     }
]