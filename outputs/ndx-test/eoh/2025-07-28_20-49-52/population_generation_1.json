[
     {
          "algorithm": "The algorithm identifies unique patterns in historical stock data by calculating the ratio of volume-weighted average price to the closing price, then applying a smoothing technique to generate more stable and interpretable alpha factors.",
          "code": "def heuristics_v2(df):\n    # Calculate the Volume-Weighted Average Price (VWAP)\n    vwap = (df['volume'] * (df['high'] + df['low'] + df['close']) / 3).cumsum() / df['volume'].cumsum()\n    # Calculate the factor as the ratio of VWAP to close price\n    factor_values = vwap / df['close']\n    # Apply a simple moving average for smoothing the factor values\n    smoothed_factor = factor_values.rolling(window=10).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.03613,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the VWAP to the mean of the high, low, and close prices, then applies a simple moving average for smoothing.",
          "code": "def heuristics_v2(df):\n    # Calculate the Volume-Weighted Average Price (VWAP)\n    vwap = (df['volume'] * (df['high'] + df['low'] + df['close']) / 3).cumsum() / df['volume'].cumsum()\n    # Calculate the factor as the ratio of VWAP to the mean of high, low, and close prices\n    mid_price = df[['high', 'low', 'close']].mean(axis=1)\n    factor_values = vwap / mid_price\n    # Apply a simple moving average for smoothing the factor values\n    smoothed_factor = factor_values.rolling(window=10).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.03594,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the volume-weighted average price (VWAP) to the median of the high, low, and close prices, then applies an exponential moving average for smoothing.",
          "code": "def heuristics_v2(df):\n    # Calculate the Volume-Weighted Average Price (VWAP)\n    vwap = (df['volume'] * (df['high'] + df['low'] + df['close']) / 3).cumsum() / df['volume'].cumsum()\n    # Calculate the factor as the ratio of VWAP to the median of high, low, and close prices\n    mid_price = df[['high', 'low', 'close']].median(axis=1)\n    factor_values = vwap / mid_price\n    # Apply an exponential moving average for smoothing the factor values\n    smoothed_factor = factor_values.ewm(span=10).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.03561,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of volume-weighted average price (VWAP) to the open price, and then applies an exponential moving average for smoothing.",
          "code": "def heuristics_v2(df):\n    # Calculate the Volume-Weighted Average Price (VWAP)\n    vwap = (df['volume'] * (df['high'] + df['low'] + df['close']) / 3).cumsum() / df['volume'].cumsum()\n    # Calculate the factor as the ratio of VWAP to open price\n    factor_values = vwap / df['open']\n    # Apply an exponential moving average for smoothing the factor values\n    smoothed_factor = factor_values.ewm(span=10, adjust=False).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.03507,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the volume-weighted average price (VWAP) and then computes the factor as the difference between VWAP and the closing price, applying an exponential moving average for smoothing.",
          "code": "def heuristics_v2(df):\n    # Calculate the Volume-Weighted Average Price (VWAP)\n    vwap = (df['volume'] * (df['high'] + df['low'] + df['close']) / 3).cumsum() / df['volume'].cumsum()\n    # Calculate the factor as the difference of VWAP and close price\n    factor_values = vwap - df['close']\n    # Apply an exponential moving average for smoothing the factor values\n    smoothed_factor = factor_values.ewm(span=10, adjust=False).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.03326,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates an alpha factor by first smoothing the closing prices using a 30-day simple moving average, then applying a 10-period rate of change (ROC) to this smoothed series to capture more gradual changes in trend momentum.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def sma(series, window):\n        return series.rolling(window=window).mean()\n\n    def roc(series, period):\n        return series.pct_change(periods=period)\n    \n    df['SMA_30'] = sma(df['close'], 30)\n    heuristics_matrix = roc(df['SMA_30'], 10)\n    return heuristics_matrix",
          "objective": -0.0319,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the current volume to the average volume over a 20-day period, and then multiplies this ratio by the exponential moving average (EMA) of the percentage change in closing price over the same period to generate an alpha factor.",
          "code": "def heuristics_v2(df):\n    # Calculate the 20-day average volume\n    df['Avg_Volume_20'] = df['volume'].rolling(window=20).mean()\n    \n    # Calculate the volume ratio\n    df['Volume_Ratio'] = df['volume'] / df['Avg_Volume_20']\n    \n    # Calculate the percentage change in closing price over 20 days\n    df['Close_Change_20'] = df['close'].pct_change(periods=20)\n    \n    # Calculate the 20-day EMA of the close change\n    df['EMA_Close_Change_20'] = df['Close_Change_20'].ewm(span=20, adjust=False).mean()\n    \n    # Generate the final heuristic by multiplying the Volume_Ratio and EMA_Close_Change_20\n    heuristics_matrix = df['Volume_Ratio'] * df['EMA_Close_Change_20']\n    \n    return heuristics_matrix",
          "objective": -0.0271,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a novel alpha factor by first smoothing the closing prices using a 10-day simple moving average, then applying a 10-period rate of change (ROC) to this smoothed series, aiming to capture more frequent changes in trend momentum.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def sma(series, window):\n        return series.rolling(window=window).mean()\n\n    def roc(series, period):\n        return series.pct_change(periods=period)\n    \n    df['SMA_10'] = sma(df['close'], 10)\n    heuristics_matrix = roc(df['SMA_10'], 10)\n    return heuristics_matrix",
          "objective": -0.02693,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates the ratio of the 20-day simple moving average to the 5-day exponential moving average of the closing price, aiming to capture a relative strength signal.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def sma(series, window):\n        return series.rolling(window=window).mean()\n\n    def ema(series, span):\n        return series.ewm(span=span, adjust=False).mean()\n    \n    df['SMA_20'] = sma(df['close'], 20)\n    df['EMA_5'] = ema(df['close'], 5)\n    heuristics_matrix = df['SMA_20'] / df['EMA_5']\n    return heuristics_matrix",
          "objective": -0.02344,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the difference between the rolling average of high and low prices over a 5-day window to the closing price, aiming to capture a smoothed version of price volatility.",
          "code": "def heuristics_v2(df):\n    heuristics_matrix = (df['high'].rolling(window=5).mean() - df['low'].rolling(window=5).mean()) / df['close']\n    return heuristics_matrix",
          "objective": -0.0231,
          "other_inf": null
     }
]