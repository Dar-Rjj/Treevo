[
     {
          "algorithm": "The new algorithm calculates the ratio of the sum of the last 7 days' closing prices to the sum of the next 7 days' low prices, then applies an exponential moving average for smoothing.",
          "code": "def heuristics_v2(df):\n    # Calculate the sum of the last 7 days' closing prices\n    sum_last_7_close = df['close'].rolling(window=7).sum()\n    # Calculate the sum of the next 7 days' low prices\n    sum_next_7_low = df['low'].shift(-7).rolling(window=7).sum()\n    # Calculate the factor as the ratio of the two sums\n    factor_values = sum_last_7_close / sum_next_7_low\n    # Apply an exponential moving average for smoothing the factor values\n    smoothed_factor = factor_values.ewm(span=14).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.29271,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the sum of the last 5 days' closing prices to the sum of the next 5 days' opening prices, then applies an exponential moving average for smoothing.",
          "code": "def heuristics_v2(df):\n    # Calculate the sum of the last 5 days' closing prices\n    sum_last_5_close = df['close'].rolling(window=5).sum()\n    # Calculate the sum of the next 5 days' opening prices\n    sum_next_5_open = df['open'].shift(-5).rolling(window=5).sum()\n    # Calculate the factor as the ratio of the two sums\n    factor_values = sum_last_5_close / sum_next_5_open\n    # Apply an exponential moving average for smoothing the factor values\n    smoothed_factor = factor_values.ewm(span=10, adjust=False).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.25545,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the average of the last 7 days' closing prices to the average of the next 7 days' opening prices, then applies a simple moving average for smoothing.",
          "code": "def heuristics_v2(df):\n    # Calculate the average of the last 7 days' closing prices\n    avg_last_7_close = df['close'].rolling(window=7).mean()\n    # Calculate the average of the next 7 days' opening prices\n    avg_next_7_open = df['open'].shift(-7).rolling(window=7).mean()\n    # Calculate the factor as the ratio of the two averages\n    factor_values = avg_last_7_close / avg_next_7_open\n    # Apply a simple moving average for smoothing the factor values\n    smoothed_factor = factor_values.rolling(window=10).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.20477,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the sum of the last 5 days' closing prices to the sum of the next 5 days' high prices, then applies a simple moving average for smoothing.",
          "code": "def heuristics_v2(df):\n    # Calculate the sum of the last 5 days' closing prices\n    sum_last_5_close = df['close'].rolling(window=5).sum()\n    # Calculate the sum of the next 5 days' high prices\n    sum_next_5_high = df['high'].shift(-5).rolling(window=5).sum()\n    # Calculate the factor as the ratio of the two sums\n    factor_values = sum_last_5_close / sum_next_5_high\n    # Apply a simple moving average for smoothing the factor values\n    smoothed_factor = factor_values.rolling(window=10).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.17107,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the average of the last 5 days' closing prices to the average of the next 5 days' opening prices, then applies a simple moving average for smoothing.",
          "code": "def heuristics_v2(df):\n    # Calculate the average of the last 5 days' closing prices\n    avg_last_5_close = df['close'].rolling(window=5).mean()\n    # Calculate the average of the next 5 days' opening prices\n    avg_next_5_open = df['open'].shift(-5).rolling(window=5).mean()\n    # Calculate the factor as the ratio of the two averages\n    factor_values = avg_last_5_close / avg_next_5_open\n    # Apply a simple moving average for smoothing the factor values\n    smoothed_factor = factor_values.rolling(window=10).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.14811,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the sum of the last 7 days' closing prices to the sum of the next 3 days' low prices, then applies an exponential moving average for smoothing.",
          "code": "def heuristics_v2(df):\n    # Calculate the sum of the last 7 days' closing prices\n    sum_last_7_close = df['close'].rolling(window=7).sum()\n    # Calculate the sum of the next 3 days' low prices\n    sum_next_3_low = df['low'].shift(-3).rolling(window=3).sum()\n    # Calculate the factor as the ratio of the two sums\n    factor_values = sum_last_7_close / sum_next_3_low\n    # Apply an exponential moving average for smoothing the factor values\n    smoothed_factor = factor_values.ewm(span=10, adjust=False).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.12202,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of the sum of the last 3 days' closing prices to the sum of the next 3 days' low prices, then applies a simple moving average for smoothing.",
          "code": "def heuristics_v2(df):\n    # Calculate the sum of the last 3 days' closing prices\n    sum_last_3_close = df['close'].rolling(window=3).sum()\n    # Calculate the sum of the next 3 days' low prices\n    sum_next_3_low = df['low'].shift(-3).rolling(window=3).sum()\n    # Calculate the factor as the ratio of the two sums\n    factor_values = sum_last_3_close / sum_next_3_low\n    # Apply a simple moving average for smoothing the factor values\n    smoothed_factor = factor_values.rolling(window=10).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.1067,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a modified volume-weighted average price using only the high and low prices, then calculates the ratio of this modified VWAP to the close price, and applies a simple moving average for smoothing.",
          "code": "def heuristics_v2(df):\n    # Calculate the modified Volume-Weighted Average Price (VWAP) using high and low prices\n    vwap = (df['volume'] * (df['high'] + df['low']) / 2).cumsum() / df['volume'].cumsum()\n    # Calculate the factor as the ratio of modified VWAP to close price\n    factor_values = vwap / df['close']\n    # Apply a simple moving average for smoothing the factor values\n    smoothed_factor = factor_values.rolling(window=10).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.03615,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies unique patterns in historical stock data by calculating the ratio of volume-weighted average price to the closing price, then applying a smoothing technique to generate more stable and interpretable alpha factors.",
          "code": "def heuristics_v2(df):\n    # Calculate the Volume-Weighted Average Price (VWAP)\n    vwap = (df['volume'] * (df['high'] + df['low'] + df['close']) / 3).cumsum() / df['volume'].cumsum()\n    # Calculate the factor as the ratio of VWAP to close price\n    factor_values = vwap / df['close']\n    # Apply a simple moving average for smoothing the factor values\n    smoothed_factor = factor_values.rolling(window=10).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.03613,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the volume-weighted average price (VWAP) and then computes the factor as the ratio of VWAP to the closing price, which is then smoothed using a simple moving average.",
          "code": "def heuristics_v2(df):\n    # Calculate the Volume-Weighted Average Price (VWAP)\n    vwap = (df['volume'] * (df['high'] + df['low'] + df['close']) / 3).cumsum() / df['volume'].cumsum()\n    # Calculate the factor as the ratio of VWAP to close price\n    factor_values = vwap / df['close']\n    # Apply a simple moving average for smoothing the factor values\n    smoothed_factor = factor_values.rolling(window=10, min_periods=1).mean()\n    heuristics_matrix = smoothed_factor.dropna()\n    return heuristics_matrix",
          "objective": -0.03606,
          "other_inf": null
     }
]