{
     "algorithm": "The new algorithm, named Modified Momentum-Trend Integration Plus, incorporates a dynamic weighting scheme between RSI and PSAR based on the volatility of the stock, and it further enhances the PSAR's sensitivity to trends by adjusting its acceleration factor dynamically according to the recent price action.",
     "code": "def heuristics_v2(df):\n    # Calculate RSI\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate Parabolic SAR with dynamically adjusted parameters\n    high = df['high']\n    low = df['low']\n    close = df['close']\n    psar = close.copy()\n    psar[0] = high[0]\n    ep = high[0]\n    acc_factor = 0.03  # Initial acceleration factor\n    max_acc_factor = 0.3  # Maximum acceleration factor\n    increment = acc_factor\n    direction = 1 if close[1] > psar[0] else -1\n    \n    for i in range(1, len(close)):\n        if direction == 1:\n            psar[i] = psar[i-1] + increment\n            if high[i] > ep:\n                ep = high[i]\n                increment = min(increment + 0.01 * (high[i] - low[i]), max_acc_factor)  # Adjust acc. factor based on price range\n            if psar[i] > low[i] or psar[i] > ep:\n                direction = -1\n                psar[i] = ep\n                ep = low[i]\n                increment = acc_factor\n        else:\n            psar[i] = psar[i-1] - increment\n            if low[i] < ep:\n                ep = low[i]\n                increment = min(increment + 0.01 * (high[i] - low[i]), max_acc_factor)  # Adjust acc. factor based on price range\n            if psar[i] < high[i] or psar[i] < ep:\n                direction = 1\n                psar[i] = ep\n                ep = high[i]\n                increment = acc_factor\n    \n    # Dynamic weight allocation based on the standard deviation of daily returns over the last 14 days\n    std_dev = close.pct_change().rolling(window=14).std()\n    weight_rsi = (std_dev.max() - std_dev) / (std_dev.max() - std_dev.min())\n    weight_psar = 1 - weight_rsi\n    heuristics_matrix = weight_rsi * rsi + weight_psar * (psar - close)\n\n    return heuristics_matrix",
     "objective": -0.03314,
     "other_inf": null
}