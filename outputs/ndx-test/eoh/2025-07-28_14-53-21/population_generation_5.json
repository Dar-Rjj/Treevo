[
     {
          "algorithm": "The new algorithm integrates the percentage change of the 50-day EMA relative to the 200-day EMA with the normalized Money Flow Index (MFI) over a 14-day period.",
          "code": "def heuristics_v2(df):\n    # Calculate 50-day and 200-day exponential moving averages\n    ema_50 = df['close'].ewm(span=50, adjust=False).mean()\n    ema_200 = df['close'].ewm(span=200, adjust=False).mean()\n    ema_diff_percentage = (ema_50 - ema_200) / ema_200\n\n    # Calculate Money Flow Index (MFI)\n    typical_price = (df['high'] + df['low'] + df['close']) / 3\n    money_flow = typical_price * df['volume']\n    positive_money_flow = money_flow.where(typical_price > typical_price.shift(1), 0)\n    negative_money_flow = money_flow.where(typical_price < typical_price.shift(1), 0)\n    positive_sum = positive_money_flow.rolling(window=14).sum()\n    negative_sum = negative_money_flow.rolling(window=14).sum()\n    mfi = 100 - (100 / (1 + (positive_sum / negative_sum)))\n\n    # Normalize MFI\n    mfi_normalized = (mfi - mfi.min()) / (mfi.max() - mfi.min())\n\n    # Combine EMA difference percentage and normalized MFI into a single heuristic factor\n    heuristics_matrix = ema_diff_percentage + mfi_normalized\n\n    return heuristics_matrix",
          "objective": -0.03615,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm, named Modified Momentum-Trend Integration Plus, incorporates a dynamic weighting scheme between RSI and PSAR based on the volatility of the stock, and it further enhances the PSAR's sensitivity to trends by adjusting its acceleration factor dynamically according to the recent price action.",
          "code": "def heuristics_v2(df):\n    # Calculate RSI\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate Parabolic SAR with dynamically adjusted parameters\n    high = df['high']\n    low = df['low']\n    close = df['close']\n    psar = close.copy()\n    psar[0] = high[0]\n    ep = high[0]\n    acc_factor = 0.03  # Initial acceleration factor\n    max_acc_factor = 0.3  # Maximum acceleration factor\n    increment = acc_factor\n    direction = 1 if close[1] > psar[0] else -1\n    \n    for i in range(1, len(close)):\n        if direction == 1:\n            psar[i] = psar[i-1] + increment\n            if high[i] > ep:\n                ep = high[i]\n                increment = min(increment + 0.01 * (high[i] - low[i]), max_acc_factor)  # Adjust acc. factor based on price range\n            if psar[i] > low[i] or psar[i] > ep:\n                direction = -1\n                psar[i] = ep\n                ep = low[i]\n                increment = acc_factor\n        else:\n            psar[i] = psar[i-1] - increment\n            if low[i] < ep:\n                ep = low[i]\n                increment = min(increment + 0.01 * (high[i] - low[i]), max_acc_factor)  # Adjust acc. factor based on price range\n            if psar[i] < high[i] or psar[i] < ep:\n                direction = 1\n                psar[i] = ep\n                ep = high[i]\n                increment = acc_factor\n    \n    # Dynamic weight allocation based on the standard deviation of daily returns over the last 14 days\n    std_dev = close.pct_change().rolling(window=14).std()\n    weight_rsi = (std_dev.max() - std_dev) / (std_dev.max() - std_dev.min())\n    weight_psar = 1 - weight_rsi\n    heuristics_matrix = weight_rsi * rsi + weight_psar * (psar - close)\n\n    return heuristics_matrix",
          "objective": -0.03314,
          "other_inf": null
     },
     {
          "algorithm": "The modified algorithm, named Momentum-Trend Integration Plus, introduces a weighted combination of RSI and PSAR, where the weights are dynamically adjusted based on the recent volatility of the stock.",
          "code": "def heuristics_v2(df):\n    # Calculate RSI\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate Parabolic SAR\n    high = df['high']\n    low = df['low']\n    close = df['close']\n    psar = close.copy()\n    psar[0] = high[0]\n    ep = high[0]\n    acc_factor = 0.02\n    max_acc_factor = 0.2\n    increment = acc_factor\n    direction = 1 if close[1] > psar[0] else -1\n    \n    for i in range(1, len(close)):\n        if direction == 1:\n            psar[i] = psar[i-1] + increment\n            if high[i] > ep:\n                ep = high[i]\n                increment = min(increment + acc_factor, max_acc_factor)\n            if psar[i] > low[i] or psar[i] > ep:\n                direction = -1\n                psar[i] = ep\n                ep = low[i]\n                increment = acc_factor\n        else:\n            psar[i] = psar[i-1] - increment\n            if low[i] < ep:\n                ep = low[i]\n                increment = min(increment + acc_factor, max_acc_factor)\n            if psar[i] < high[i] or psar[i] < ep:\n                direction = 1\n                psar[i] = ep\n                ep = high[i]\n                increment = acc_factor\n\n    # Calculate recent volatility (Standard Deviation) over a 14-day window\n    volatility = df['close'].rolling(window=14).std()\n\n    # Dynamically adjust the weights for RSI and PSAR based on recent volatility\n    weight_rsi = 1 / (1 + volatility)\n    weight_psar = 1 - weight_rsi\n\n    # Combine RSI and PSAR into a single heuristic factor with dynamic weights\n    heuristics_matrix = weight_rsi * rsi + weight_psar * (psar - close)\n\n    return heuristics_matrix",
          "objective": -0.02644,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm, named Volume-Adjusted Momentum with MACD, integrates the RSI and VWAP similarly to the original but introduces a MACD (Moving Average Convergence Divergence) component, combining all three factors using weights 0.5 for the modified RSI-VWAP mix, and 0.5 for the MACD to offer an enhanced predictive indicator.",
          "code": "def heuristics_v2(df):\n    # Calculate RSI\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=20).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=20).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate VWAP\n    tp = (df['high'] + df['low'] + df['close']) / 3\n    vwap = (tp * df['volume']).cumsum() / df['volume'].cumsum()\n    \n    # Combine RSI and VWAP into a single factor\n    rsi_vwap_mix = 0.6 * rsi + 0.4 * (vwap - df['close'])\n    \n    # Calculate MACD\n    ema_12 = df['close'].ewm(span=12, adjust=False).mean()\n    ema_26 = df['close'].ewm(span=26, adjust=False).mean()\n    macd_line = ema_12 - ema_26\n    signal_line = macd_line.ewm(span=9, adjust=False).mean()\n    macd = macd_line - signal_line\n    \n    # Final heuristic matrix combining the RSI-VWAP mix and MACD\n    heuristics_matrix = 0.5 * rsi_vwap_mix + 0.5 * macd\n    \n    return heuristics_matrix",
          "objective": -0.02574,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm combines the 14-day rate of change (ROC) with the 50-day and 200-day exponential moving average (EMA) crossover to capture momentum and trend changes.",
          "code": "def heuristics_v2(df):\n    roc = (df['close'] - df['close'].shift(14)) / df['close'].shift(14) * 100\n    ema_50 = df['close'].ewm(span=50, adjust=False).mean()\n    ema_200 = df['close'].ewm(span=200, adjust=False).mean()\n    ema_crossover = ema_50 - ema_200\n    heuristics_matrix = roc + ema_crossover\n    return heuristics_matrix",
          "objective": -0.02573,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor by integrating the 50-day and 200-day EMA crossover signals with the ratio of positive to negative money flow over a 14-day period.",
          "code": "def heuristics_v2(df):\n    # Calculate 50-day and 200-day exponential moving averages\n    ema_50 = df['close'].ewm(span=50, adjust=False).mean()\n    ema_200 = df['close'].ewm(span=200, adjust=False).mean()\n\n    # Generate EMA crossover signal\n    ema_crossover = (ema_50 > ema_200).astype(int)\n\n    # Calculate typical price and money flow\n    typical_price = (df['high'] + df['low'] + df['close']) / 3\n    money_flow = typical_price * df['volume']\n\n    # Positive and negative money flow\n    positive_money_flow = money_flow.where(typical_price > typical_price.shift(1), 0)\n    negative_money_flow = money_flow.where(typical_price < typical_price.shift(1), 0)\n\n    # Sum over 14 days\n    positive_sum = positive_money_flow.rolling(window=14).sum()\n    negative_sum = negative_money_flow.rolling(window=14).sum()\n\n    # Calculate the ratio of positive to negative money flow\n    money_flow_ratio = positive_sum / negative_sum\n\n    # Combine EMA crossover signal and money flow ratio into a single heuristic factor\n    heuristics_matrix = ema_crossover * money_flow_ratio\n\n    return heuristics_matrix",
          "objective": -0.02558,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor by integrating the difference between the 50-day exponential moving average (EMA) and the 200-day EMA with the Money Flow Index (MFI) over a 14-day period.",
          "code": "def heuristics_v2(df):\n    # Calculate 50-day and 200-day exponential moving averages\n    ema_50 = df['close'].ewm(span=50, adjust=False).mean()\n    ema_200 = df['close'].ewm(span=200, adjust=False).mean()\n    ema_diff = ema_50 - ema_200\n\n    # Calculate Money Flow Index (MFI)\n    typical_price = (df['high'] + df['low'] + df['close']) / 3\n    money_flow = typical_price * df['volume']\n    positive_money_flow = money_flow.where(typical_price > typical_price.shift(1), 0)\n    negative_money_flow = money_flow.where(typical_price < typical_price.shift(1), 0)\n    positive_sum = positive_money_flow.rolling(window=14).sum()\n    negative_sum = negative_money_flow.rolling(window=14).sum()\n    mfi = 100 - (100 / (1 + (positive_sum / negative_sum)))\n\n    # Combine EMA difference and MFI into a single heuristic factor\n    heuristics_matrix = ema_diff + mfi\n\n    return heuristics_matrix",
          "objective": -0.02556,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm, named Momentum-Trend Integration, combines the Relative Strength Index (RSI) as a measure of momentum with the Parabolic SAR (PSAR) to capture price direction and potential reversals.",
          "code": "def heuristics_v2(df):\n    # Calculate RSI\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate Parabolic SAR\n    high = df['high']\n    low = df['low']\n    close = df['close']\n    psar = close.copy()\n    psar[0] = high[0]\n    ep = high[0]\n    acc_factor = 0.02\n    max_acc_factor = 0.2\n    increment = acc_factor\n    direction = 1 if close[1] > psar[0] else -1\n    \n    for i in range(1, len(close)):\n        if direction == 1:\n            psar[i] = psar[i-1] + increment\n            if high[i] > ep:\n                ep = high[i]\n                increment = min(increment + acc_factor, max_acc_factor)\n            if psar[i] > low[i] or psar[i] > ep:\n                direction = -1\n                psar[i] = ep\n                ep = low[i]\n                increment = acc_factor\n        else:\n            psar[i] = psar[i-1] - increment\n            if low[i] < ep:\n                ep = low[i]\n                increment = min(increment + acc_factor, max_acc_factor)\n            if psar[i] < high[i] or psar[i] < ep:\n                direction = 1\n                psar[i] = ep\n                ep = high[i]\n                increment = acc_factor\n    \n    # Combine RSI and PSAR into a single heuristic factor\n    heuristics_matrix = 0.5 * rsi + 0.5 * (psar - close)\n\n    return heuristics_matrix",
          "objective": -0.02527,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm combines the 14-day and 28-day average true range (ATR) with the difference between a 50-day and 200-day weighted moving average (WMA) to capture volatility and long-term trend changes.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    high_low = df['high'] - df['low']\n    high_close = abs(df['high'] - df['close'].shift())\n    low_close = abs(df['low'] - df['close'].shift())\n    tr = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)\n    atr_14 = tr.rolling(window=14).mean()\n    atr_28 = tr.rolling(window=28).mean()\n    atr_diff = atr_14 - atr_28\n    wma_50 = df['close'].ewm(span=50, adjust=False).mean()\n    wma_200 = df['close'].ewm(span=200, adjust=False).mean()\n    wma_difference = wma_50 - wma_200\n    heuristics_matrix = atr_diff + wma_difference\n    return heuristics_matrix",
          "objective": -0.0244,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm, called Momentum-Volume Adjusted, calculates the RSI over a 20-day window and the VWAP, then combines them with weights of 0.6 for RSI and 0.4 for (VWAP - Close) to generate a more volume-adjusted momentum indicator.",
          "code": "def heuristics_v2(df):\n    # Calculate RSI\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=20).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=20).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate VWAP\n    tp = (df['high'] + df['low'] + df['close']) / 3\n    vwap = (tp * df['volume']).cumsum() / df['volume'].cumsum()\n    \n    # Combine RSI and VWAP into a single heuristic factor\n    heuristics_matrix = 0.6 * rsi + 0.4 * (vwap - df['close'])\n    \n    return heuristics_matrix",
          "objective": -0.02419,
          "other_inf": null
     }
]