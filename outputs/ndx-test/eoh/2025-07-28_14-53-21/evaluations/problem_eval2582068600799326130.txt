import pandas as pd

def heuristics_v2(df):
    # Calculate RSI
    delta = df['close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    
    # Calculate Parabolic SAR with dynamically adjusted parameters
    high = df['high']
    low = df['low']
    close = df['close']
    psar = close.copy()
    psar[0] = high[0]
    ep = high[0]
    acc_factor = 0.03  # Initial acceleration factor
    max_acc_factor = 0.3  # Maximum acceleration factor
    increment = acc_factor
    direction = 1 if close[1] > psar[0] else -1
    
    for i in range(1, len(close)):
        if direction == 1:
            psar[i] = psar[i-1] + increment
            if high[i] > ep:
                ep = high[i]
                increment = min(increment + 0.01 * (high[i] - low[i]), max_acc_factor)  # Adjust acc. factor based on price range
            if psar[i] > low[i] or psar[i] > ep:
                direction = -1
                psar[i] = ep
                ep = low[i]
                increment = acc_factor
        else:
            psar[i] = psar[i-1] - increment
            if low[i] < ep:
                ep = low[i]
                increment = min(increment + 0.01 * (high[i] - low[i]), max_acc_factor)  # Adjust acc. factor based on price range
            if psar[i] < high[i] or psar[i] < ep:
                direction = 1
                psar[i] = ep
                ep = high[i]
                increment = acc_factor
    
    # Dynamic moving average crossover periods
    std_dev = close.pct_change().rolling(window=14).std()
    short_period = 5 + (std_dev * 10).astype(int)
    long_period = 20 + (std_dev * 10).astype(int)
    ma_short = close.rolling(window=short_period).mean()
    ma_long = close.rolling(window=long_period).mean()
    
    # Combine RSI, PSAR, and Moving Averages
    weight_rsi = (std_dev.max() - std_dev) / (std_dev.max() - std_dev.min())
    weight_psar = 1 - weight_rsi
    crossover_signal = (ma_short - ma_long).shift(1)
    heuristics_matrix = weight_rsi * rsi + weight_psar * (psar - close) + crossover_signal

    return heuristics_matrix
