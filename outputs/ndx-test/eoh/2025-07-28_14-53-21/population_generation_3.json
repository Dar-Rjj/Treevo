[
     {
          "algorithm": "The new algorithm, named Modified Momentum-Trend Integration Plus, incorporates a dynamic weighting scheme between RSI and PSAR based on the volatility of the stock, and it further enhances the PSAR's sensitivity to trends by adjusting its acceleration factor dynamically according to the recent price action.",
          "code": "def heuristics_v2(df):\n    # Calculate RSI\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate Parabolic SAR with dynamically adjusted parameters\n    high = df['high']\n    low = df['low']\n    close = df['close']\n    psar = close.copy()\n    psar[0] = high[0]\n    ep = high[0]\n    acc_factor = 0.03  # Initial acceleration factor\n    max_acc_factor = 0.3  # Maximum acceleration factor\n    increment = acc_factor\n    direction = 1 if close[1] > psar[0] else -1\n    \n    for i in range(1, len(close)):\n        if direction == 1:\n            psar[i] = psar[i-1] + increment\n            if high[i] > ep:\n                ep = high[i]\n                increment = min(increment + 0.01 * (high[i] - low[i]), max_acc_factor)  # Adjust acc. factor based on price range\n            if psar[i] > low[i] or psar[i] > ep:\n                direction = -1\n                psar[i] = ep\n                ep = low[i]\n                increment = acc_factor\n        else:\n            psar[i] = psar[i-1] - increment\n            if low[i] < ep:\n                ep = low[i]\n                increment = min(increment + 0.01 * (high[i] - low[i]), max_acc_factor)  # Adjust acc. factor based on price range\n            if psar[i] < high[i] or psar[i] < ep:\n                direction = 1\n                psar[i] = ep\n                ep = high[i]\n                increment = acc_factor\n    \n    # Dynamic weight allocation based on the standard deviation of daily returns over the last 14 days\n    std_dev = close.pct_change().rolling(window=14).std()\n    weight_rsi = (std_dev.max() - std_dev) / (std_dev.max() - std_dev.min())\n    weight_psar = 1 - weight_rsi\n    heuristics_matrix = weight_rsi * rsi + weight_psar * (psar - close)\n\n    return heuristics_matrix",
          "objective": -0.03314,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm combines the 14-day rate of change (ROC) with the 50-day and 200-day exponential moving average (EMA) crossover to capture momentum and trend changes.",
          "code": "def heuristics_v2(df):\n    roc = (df['close'] - df['close'].shift(14)) / df['close'].shift(14) * 100\n    ema_50 = df['close'].ewm(span=50, adjust=False).mean()\n    ema_200 = df['close'].ewm(span=200, adjust=False).mean()\n    ema_crossover = ema_50 - ema_200\n    heuristics_matrix = roc + ema_crossover\n    return heuristics_matrix",
          "objective": -0.02573,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor by integrating the difference between the 50-day exponential moving average (EMA) and the 200-day EMA with the Money Flow Index (MFI) over a 14-day period.",
          "code": "def heuristics_v2(df):\n    # Calculate 50-day and 200-day exponential moving averages\n    ema_50 = df['close'].ewm(span=50, adjust=False).mean()\n    ema_200 = df['close'].ewm(span=200, adjust=False).mean()\n    ema_diff = ema_50 - ema_200\n\n    # Calculate Money Flow Index (MFI)\n    typical_price = (df['high'] + df['low'] + df['close']) / 3\n    money_flow = typical_price * df['volume']\n    positive_money_flow = money_flow.where(typical_price > typical_price.shift(1), 0)\n    negative_money_flow = money_flow.where(typical_price < typical_price.shift(1), 0)\n    positive_sum = positive_money_flow.rolling(window=14).sum()\n    negative_sum = negative_money_flow.rolling(window=14).sum()\n    mfi = 100 - (100 / (1 + (positive_sum / negative_sum)))\n\n    # Combine EMA difference and MFI into a single heuristic factor\n    heuristics_matrix = ema_diff + mfi\n\n    return heuristics_matrix",
          "objective": -0.02556,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm, named Momentum-Trend Integration, combines the Relative Strength Index (RSI) as a measure of momentum with the Parabolic SAR (PSAR) to capture price direction and potential reversals.",
          "code": "def heuristics_v2(df):\n    # Calculate RSI\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate Parabolic SAR\n    high = df['high']\n    low = df['low']\n    close = df['close']\n    psar = close.copy()\n    psar[0] = high[0]\n    ep = high[0]\n    acc_factor = 0.02\n    max_acc_factor = 0.2\n    increment = acc_factor\n    direction = 1 if close[1] > psar[0] else -1\n    \n    for i in range(1, len(close)):\n        if direction == 1:\n            psar[i] = psar[i-1] + increment\n            if high[i] > ep:\n                ep = high[i]\n                increment = min(increment + acc_factor, max_acc_factor)\n            if psar[i] > low[i] or psar[i] > ep:\n                direction = -1\n                psar[i] = ep\n                ep = low[i]\n                increment = acc_factor\n        else:\n            psar[i] = psar[i-1] - increment\n            if low[i] < ep:\n                ep = low[i]\n                increment = min(increment + acc_factor, max_acc_factor)\n            if psar[i] < high[i] or psar[i] < ep:\n                direction = 1\n                psar[i] = ep\n                ep = high[i]\n                increment = acc_factor\n    \n    # Combine RSI and PSAR into a single heuristic factor\n    heuristics_matrix = 0.5 * rsi + 0.5 * (psar - close)\n\n    return heuristics_matrix",
          "objective": -0.02527,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor by combining the 50-day and 200-day exponential moving averages crossover signal with the difference of the 13-day and 21-day RSI values.",
          "code": "import pandas as pd\nimport numpy as pd\n\ndef heuristics_v2(df):\n    ema_50 = df['close'].ewm(span=50, adjust=False).mean()\n    ema_200 = df['close'].ewm(span=200, adjust=False).mean()\n    ema_crossover = ema_50 - ema_200\n    delta = df['close'].diff()\n    gain_13 = (delta.where(delta > 0, 0)).rolling(window=13).mean()\n    loss_13 = (-delta.where(delta < 0, 0)).rolling(window=13).mean()\n    rs_13 = gain_13 / loss_13\n    rsi_13 = 100 - (100 / (1 + rs_13))\n    gain_21 = (delta.where(delta > 0, 0)).rolling(window=21).mean()\n    loss_21 = (-delta.where(delta < 0, 0)).rolling(window=21).mean()\n    rs_21 = gain_21 / loss_21\n    rsi_21 = 100 - (100 / (1 + rs_21))\n    rsi_diff = rsi_13 - rsi_21\n    heuristics_matrix = (ema_crossover + rsi_diff) / 2\n    return heuristics_matrix",
          "objective": -0.02397,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the 21-day rate of change (ROC) and combines it with the difference between a 30-day and 100-day simple moving average (SMA) to identify both short-term momentum and medium-term trend changes.",
          "code": "def heuristics_v2(df):\n    roc = (df['close'] - df['close'].shift(21)) / df['close'].shift(21) * 100\n    sma_30 = df['close'].rolling(window=30).mean()\n    sma_100 = df['close'].rolling(window=100).mean()\n    sma_difference = sma_30 - sma_100\n    heuristics_matrix = roc + sma_difference\n    return heuristics_matrix",
          "objective": -0.02364,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm, named Momentum-Volume Integration, combines the Relative Strength Index (RSI) as a measure of momentum with the Volume-Weighted Average Price (VWAP) to incorporate volume into price trends.",
          "code": "def heuristics_v2(df):\n    # Calculate RSI\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate VWAP\n    tp = (df['high'] + df['low'] + df['close']) / 3\n    vwap = (tp * df['volume']).cumsum() / df['volume'].cumsum()\n    \n    # Combine RSI and VWAP into a single heuristic factor\n    heuristics_matrix = 0.5 * rsi + 0.5 * (vwap - df['close'])\n    \n    return heuristics_matrix",
          "objective": -0.02358,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes an alpha factor by integrating the 14-day Chaikin Money Flow (CMF) with the 30-day rate of change (ROC) of the closing price, and the 7-day moving average of the daily return's standard deviation, providing a novel measure of market strength and volatility.",
          "code": "def heuristics_v2(df):\n    # Calculate 14-day Chaikin Money Flow (CMF)\n    money_flow_multiplier = ((df['close'] - df['low']) - (df['high'] - df['close'])) / (df['high'] - df['low'])\n    money_flow_volume = money_flow_multiplier * df['volume']\n    cmf = money_flow_volume.rolling(window=14).sum() / df['volume'].rolling(window=14).sum()\n\n    # Calculate 30-day Rate of Change (ROC)\n    roc = df['close'].pct_change(periods=30)\n\n    # Calculate 7-day moving average of the standard deviation of daily returns\n    daily_returns = df['close'].pct_change()\n    std_dev_7 = daily_returns.rolling(window=7).std()\n\n    # Combine all factors into a single heuristic factor\n    heuristics_matrix = cmf + roc + std_dev_7\n\n    return heuristics_matrix",
          "objective": -0.023,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm integrates the 14-day rate of change (ROC) with a ratio of the 50-day and 200-day exponential moving averages (EMA), aimed at providing an enhanced measure of momentum and trend strength.",
          "code": "def heuristics_v2(df):\n    roc = (df['close'] - df['close'].shift(14)) / df['close'].shift(14) * 100\n    ema_50 = df['close'].ewm(span=50, adjust=False).mean()\n    ema_200 = df['close'].ewm(span=200, adjust=False).mean()\n    ema_ratio = ema_50 / ema_200\n    heuristics_matrix = roc * ema_ratio\n    return heuristics_matrix",
          "objective": -0.02276,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates an alpha factor by integrating the 21-day Chaikin Money Flow (CMF) with the 50-day rate of change (ROC) of the closing price, and the 14-day moving average of the daily return's standard deviation, offering a fresh perspective on market momentum and volatility.",
          "code": "def heuristics_v2(df):\n    # Calculate 21-day Chaikin Money Flow (CMF)\n    money_flow_multiplier = ((df['close'] - df['low']) - (df['high'] - df['close'])) / (df['high'] - df['low'])\n    money_flow_volume = money_flow_multiplier * df['volume']\n    cmf = money_flow_volume.rolling(window=21).sum() / df['volume'].rolling(window=21).sum()\n\n    # Calculate 50-day Rate of Change (ROC)\n    roc = df['close'].pct_change(periods=50)\n\n    # Calculate 14-day moving average of the standard deviation of daily returns\n    daily_returns = df['close'].pct_change()\n    std_dev_14 = daily_returns.rolling(window=14).std()\n\n    # Combine all factors into a single heuristic factor\n    heuristics_matrix = cmf + roc + std_dev_14\n\n    return heuristics_matrix",
          "objective": -0.02257,
          "other_inf": null
     }
]