[
     {
          "algorithm": "The new algorithm integrates the percentage change of the 50-day EMA relative to the 200-day EMA with the normalized Money Flow Index (MFI) over a 14-day period.",
          "code": "def heuristics_v2(df):\n    # Calculate 50-day and 200-day exponential moving averages\n    ema_50 = df['close'].ewm(span=50, adjust=False).mean()\n    ema_200 = df['close'].ewm(span=200, adjust=False).mean()\n    ema_diff_percentage = (ema_50 - ema_200) / ema_200\n\n    # Calculate Money Flow Index (MFI)\n    typical_price = (df['high'] + df['low'] + df['close']) / 3\n    money_flow = typical_price * df['volume']\n    positive_money_flow = money_flow.where(typical_price > typical_price.shift(1), 0)\n    negative_money_flow = money_flow.where(typical_price < typical_price.shift(1), 0)\n    positive_sum = positive_money_flow.rolling(window=14).sum()\n    negative_sum = negative_money_flow.rolling(window=14).sum()\n    mfi = 100 - (100 / (1 + (positive_sum / negative_sum)))\n\n    # Normalize MFI\n    mfi_normalized = (mfi - mfi.min()) / (mfi.max() - mfi.min())\n\n    # Combine EMA difference percentage and normalized MFI into a single heuristic factor\n    heuristics_matrix = ema_diff_percentage + mfi_normalized\n\n    return heuristics_matrix",
          "objective": -0.03615,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm, named Modified Momentum-Trend Integration Plus, incorporates a dynamic weighting scheme between RSI and PSAR based on the volatility of the stock, and it further enhances the PSAR's sensitivity to trends by adjusting its acceleration factor dynamically according to the recent price action.",
          "code": "def heuristics_v2(df):\n    # Calculate RSI\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate Parabolic SAR with dynamically adjusted parameters\n    high = df['high']\n    low = df['low']\n    close = df['close']\n    psar = close.copy()\n    psar[0] = high[0]\n    ep = high[0]\n    acc_factor = 0.03  # Initial acceleration factor\n    max_acc_factor = 0.3  # Maximum acceleration factor\n    increment = acc_factor\n    direction = 1 if close[1] > psar[0] else -1\n    \n    for i in range(1, len(close)):\n        if direction == 1:\n            psar[i] = psar[i-1] + increment\n            if high[i] > ep:\n                ep = high[i]\n                increment = min(increment + 0.01 * (high[i] - low[i]), max_acc_factor)  # Adjust acc. factor based on price range\n            if psar[i] > low[i] or psar[i] > ep:\n                direction = -1\n                psar[i] = ep\n                ep = low[i]\n                increment = acc_factor\n        else:\n            psar[i] = psar[i-1] - increment\n            if low[i] < ep:\n                ep = low[i]\n                increment = min(increment + 0.01 * (high[i] - low[i]), max_acc_factor)  # Adjust acc. factor based on price range\n            if psar[i] < high[i] or psar[i] < ep:\n                direction = 1\n                psar[i] = ep\n                ep = high[i]\n                increment = acc_factor\n    \n    # Dynamic weight allocation based on the standard deviation of daily returns over the last 14 days\n    std_dev = close.pct_change().rolling(window=14).std()\n    weight_rsi = (std_dev.max() - std_dev) / (std_dev.max() - std_dev.min())\n    weight_psar = 1 - weight_rsi\n    heuristics_matrix = weight_rsi * rsi + weight_psar * (psar - close)\n\n    return heuristics_matrix",
          "objective": -0.03314,
          "other_inf": null
     },
     {
          "algorithm": "The modified algorithm, named Momentum-Trend Integration Plus, introduces a weighted combination of RSI and PSAR, where the weights are dynamically adjusted based on the recent volatility of the stock.",
          "code": "def heuristics_v2(df):\n    # Calculate RSI\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate Parabolic SAR\n    high = df['high']\n    low = df['low']\n    close = df['close']\n    psar = close.copy()\n    psar[0] = high[0]\n    ep = high[0]\n    acc_factor = 0.02\n    max_acc_factor = 0.2\n    increment = acc_factor\n    direction = 1 if close[1] > psar[0] else -1\n    \n    for i in range(1, len(close)):\n        if direction == 1:\n            psar[i] = psar[i-1] + increment\n            if high[i] > ep:\n                ep = high[i]\n                increment = min(increment + acc_factor, max_acc_factor)\n            if psar[i] > low[i] or psar[i] > ep:\n                direction = -1\n                psar[i] = ep\n                ep = low[i]\n                increment = acc_factor\n        else:\n            psar[i] = psar[i-1] - increment\n            if low[i] < ep:\n                ep = low[i]\n                increment = min(increment + acc_factor, max_acc_factor)\n            if psar[i] < high[i] or psar[i] < ep:\n                direction = 1\n                psar[i] = ep\n                ep = high[i]\n                increment = acc_factor\n\n    # Calculate recent volatility (Standard Deviation) over a 14-day window\n    volatility = df['close'].rolling(window=14).std()\n\n    # Dynamically adjust the weights for RSI and PSAR based on recent volatility\n    weight_rsi = 1 / (1 + volatility)\n    weight_psar = 1 - weight_rsi\n\n    # Combine RSI and PSAR into a single heuristic factor with dynamic weights\n    heuristics_matrix = weight_rsi * rsi + weight_psar * (psar - close)\n\n    return heuristics_matrix",
          "objective": -0.02644,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm combines the 14-day rate of change (ROC) with the 50-day and 200-day exponential moving average (EMA) crossover to capture momentum and trend changes.",
          "code": "def heuristics_v2(df):\n    roc = (df['close'] - df['close'].shift(14)) / df['close'].shift(14) * 100\n    ema_50 = df['close'].ewm(span=50, adjust=False).mean()\n    ema_200 = df['close'].ewm(span=200, adjust=False).mean()\n    ema_crossover = ema_50 - ema_200\n    heuristics_matrix = roc + ema_crossover\n    return heuristics_matrix",
          "objective": -0.02573,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor by integrating the difference between the 50-day exponential moving average (EMA) and the 200-day EMA with the Money Flow Index (MFI) over a 14-day period.",
          "code": "def heuristics_v2(df):\n    # Calculate 50-day and 200-day exponential moving averages\n    ema_50 = df['close'].ewm(span=50, adjust=False).mean()\n    ema_200 = df['close'].ewm(span=200, adjust=False).mean()\n    ema_diff = ema_50 - ema_200\n\n    # Calculate Money Flow Index (MFI)\n    typical_price = (df['high'] + df['low'] + df['close']) / 3\n    money_flow = typical_price * df['volume']\n    positive_money_flow = money_flow.where(typical_price > typical_price.shift(1), 0)\n    negative_money_flow = money_flow.where(typical_price < typical_price.shift(1), 0)\n    positive_sum = positive_money_flow.rolling(window=14).sum()\n    negative_sum = negative_money_flow.rolling(window=14).sum()\n    mfi = 100 - (100 / (1 + (positive_sum / negative_sum)))\n\n    # Combine EMA difference and MFI into a single heuristic factor\n    heuristics_matrix = ema_diff + mfi\n\n    return heuristics_matrix",
          "objective": -0.02556,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm, named Momentum-Trend Integration, combines the Relative Strength Index (RSI) as a measure of momentum with the Parabolic SAR (PSAR) to capture price direction and potential reversals.",
          "code": "def heuristics_v2(df):\n    # Calculate RSI\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate Parabolic SAR\n    high = df['high']\n    low = df['low']\n    close = df['close']\n    psar = close.copy()\n    psar[0] = high[0]\n    ep = high[0]\n    acc_factor = 0.02\n    max_acc_factor = 0.2\n    increment = acc_factor\n    direction = 1 if close[1] > psar[0] else -1\n    \n    for i in range(1, len(close)):\n        if direction == 1:\n            psar[i] = psar[i-1] + increment\n            if high[i] > ep:\n                ep = high[i]\n                increment = min(increment + acc_factor, max_acc_factor)\n            if psar[i] > low[i] or psar[i] > ep:\n                direction = -1\n                psar[i] = ep\n                ep = low[i]\n                increment = acc_factor\n        else:\n            psar[i] = psar[i-1] - increment\n            if low[i] < ep:\n                ep = low[i]\n                increment = min(increment + acc_factor, max_acc_factor)\n            if psar[i] < high[i] or psar[i] < ep:\n                direction = 1\n                psar[i] = ep\n                ep = high[i]\n                increment = acc_factor\n    \n    # Combine RSI and PSAR into a single heuristic factor\n    heuristics_matrix = 0.5 * rsi + 0.5 * (psar - close)\n\n    return heuristics_matrix",
          "objective": -0.02527,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm combines the 14-day and 28-day average true range (ATR) with the difference between a 50-day and 200-day weighted moving average (WMA) to capture volatility and long-term trend changes.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    high_low = df['high'] - df['low']\n    high_close = abs(df['high'] - df['close'].shift())\n    low_close = abs(df['low'] - df['close'].shift())\n    tr = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)\n    atr_14 = tr.rolling(window=14).mean()\n    atr_28 = tr.rolling(window=28).mean()\n    atr_diff = atr_14 - atr_28\n    wma_50 = df['close'].ewm(span=50, adjust=False).mean()\n    wma_200 = df['close'].ewm(span=200, adjust=False).mean()\n    wma_difference = wma_50 - wma_200\n    heuristics_matrix = atr_diff + wma_difference\n    return heuristics_matrix",
          "objective": -0.0244,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm, called Momentum-Volume Adjusted, calculates the RSI over a 20-day window and the VWAP, then combines them with weights of 0.6 for RSI and 0.4 for (VWAP - Close) to generate a more volume-adjusted momentum indicator.",
          "code": "def heuristics_v2(df):\n    # Calculate RSI\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=20).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=20).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate VWAP\n    tp = (df['high'] + df['low'] + df['close']) / 3\n    vwap = (tp * df['volume']).cumsum() / df['volume'].cumsum()\n    \n    # Combine RSI and VWAP into a single heuristic factor\n    heuristics_matrix = 0.6 * rsi + 0.4 * (vwap - df['close'])\n    \n    return heuristics_matrix",
          "objective": -0.02419,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor by combining the 50-day and 200-day exponential moving averages crossover signal with the difference of the 13-day and 21-day RSI values.",
          "code": "import pandas as pd\nimport numpy as pd\n\ndef heuristics_v2(df):\n    ema_50 = df['close'].ewm(span=50, adjust=False).mean()\n    ema_200 = df['close'].ewm(span=200, adjust=False).mean()\n    ema_crossover = ema_50 - ema_200\n    delta = df['close'].diff()\n    gain_13 = (delta.where(delta > 0, 0)).rolling(window=13).mean()\n    loss_13 = (-delta.where(delta < 0, 0)).rolling(window=13).mean()\n    rs_13 = gain_13 / loss_13\n    rsi_13 = 100 - (100 / (1 + rs_13))\n    gain_21 = (delta.where(delta > 0, 0)).rolling(window=21).mean()\n    loss_21 = (-delta.where(delta < 0, 0)).rolling(window=21).mean()\n    rs_21 = gain_21 / loss_21\n    rsi_21 = 100 - (100 / (1 + rs_21))\n    rsi_diff = rsi_13 - rsi_21\n    heuristics_matrix = (ema_crossover + rsi_diff) / 2\n    return heuristics_matrix",
          "objective": -0.02397,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the 21-day rate of change (ROC) and combines it with the difference between a 30-day and 100-day simple moving average (SMA) to identify both short-term momentum and medium-term trend changes.",
          "code": "def heuristics_v2(df):\n    roc = (df['close'] - df['close'].shift(21)) / df['close'].shift(21) * 100\n    sma_30 = df['close'].rolling(window=30).mean()\n    sma_100 = df['close'].rolling(window=100).mean()\n    sma_difference = sma_30 - sma_100\n    heuristics_matrix = roc + sma_difference\n    return heuristics_matrix",
          "objective": -0.02364,
          "other_inf": null
     }
]