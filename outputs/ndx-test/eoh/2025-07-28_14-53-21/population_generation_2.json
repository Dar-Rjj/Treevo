[
     {
          "algorithm": "The new algorithm calculates a factor by integrating the difference between the 50-day exponential moving average (EMA) and the 200-day EMA with the Money Flow Index (MFI) over a 14-day period.",
          "code": "def heuristics_v2(df):\n    # Calculate 50-day and 200-day exponential moving averages\n    ema_50 = df['close'].ewm(span=50, adjust=False).mean()\n    ema_200 = df['close'].ewm(span=200, adjust=False).mean()\n    ema_diff = ema_50 - ema_200\n\n    # Calculate Money Flow Index (MFI)\n    typical_price = (df['high'] + df['low'] + df['close']) / 3\n    money_flow = typical_price * df['volume']\n    positive_money_flow = money_flow.where(typical_price > typical_price.shift(1), 0)\n    negative_money_flow = money_flow.where(typical_price < typical_price.shift(1), 0)\n    positive_sum = positive_money_flow.rolling(window=14).sum()\n    negative_sum = negative_money_flow.rolling(window=14).sum()\n    mfi = 100 - (100 / (1 + (positive_sum / negative_sum)))\n\n    # Combine EMA difference and MFI into a single heuristic factor\n    heuristics_matrix = ema_diff + mfi\n\n    return heuristics_matrix",
          "objective": -0.02556,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm, named Momentum-Trend Integration, combines the Relative Strength Index (RSI) as a measure of momentum with the Parabolic SAR (PSAR) to capture price direction and potential reversals.",
          "code": "def heuristics_v2(df):\n    # Calculate RSI\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate Parabolic SAR\n    high = df['high']\n    low = df['low']\n    close = df['close']\n    psar = close.copy()\n    psar[0] = high[0]\n    ep = high[0]\n    acc_factor = 0.02\n    max_acc_factor = 0.2\n    increment = acc_factor\n    direction = 1 if close[1] > psar[0] else -1\n    \n    for i in range(1, len(close)):\n        if direction == 1:\n            psar[i] = psar[i-1] + increment\n            if high[i] > ep:\n                ep = high[i]\n                increment = min(increment + acc_factor, max_acc_factor)\n            if psar[i] > low[i] or psar[i] > ep:\n                direction = -1\n                psar[i] = ep\n                ep = low[i]\n                increment = acc_factor\n        else:\n            psar[i] = psar[i-1] - increment\n            if low[i] < ep:\n                ep = low[i]\n                increment = min(increment + acc_factor, max_acc_factor)\n            if psar[i] < high[i] or psar[i] < ep:\n                direction = 1\n                psar[i] = ep\n                ep = high[i]\n                increment = acc_factor\n    \n    # Combine RSI and PSAR into a single heuristic factor\n    heuristics_matrix = 0.5 * rsi + 0.5 * (psar - close)\n\n    return heuristics_matrix",
          "objective": -0.02527,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor by combining the 50-day and 200-day exponential moving averages crossover signal with the difference of the 13-day and 21-day RSI values.",
          "code": "import pandas as pd\nimport numpy as pd\n\ndef heuristics_v2(df):\n    ema_50 = df['close'].ewm(span=50, adjust=False).mean()\n    ema_200 = df['close'].ewm(span=200, adjust=False).mean()\n    ema_crossover = ema_50 - ema_200\n    delta = df['close'].diff()\n    gain_13 = (delta.where(delta > 0, 0)).rolling(window=13).mean()\n    loss_13 = (-delta.where(delta < 0, 0)).rolling(window=13).mean()\n    rs_13 = gain_13 / loss_13\n    rsi_13 = 100 - (100 / (1 + rs_13))\n    gain_21 = (delta.where(delta > 0, 0)).rolling(window=21).mean()\n    loss_21 = (-delta.where(delta < 0, 0)).rolling(window=21).mean()\n    rs_21 = gain_21 / loss_21\n    rsi_21 = 100 - (100 / (1 + rs_21))\n    rsi_diff = rsi_13 - rsi_21\n    heuristics_matrix = (ema_crossover + rsi_diff) / 2\n    return heuristics_matrix",
          "objective": -0.02397,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a unique alpha factor by combining the ratio of positive to negative volume flow with an Aroon Oscillator and a 10-day high minus low price range, providing a fresh perspective on market dynamics.",
          "code": "def heuristics_v2(df):\n    # Calculate Positive and Negative Volume Flow\n    df['volume_change'] = df['volume'].diff()\n    pos_volume_flow = (df['volume_change'] > 0) * df['volume']\n    neg_volume_flow = (df['volume_change'] < 0) * df['volume']\n    total_pos_volume = pos_volume_flow.rolling(window=20).sum()\n    total_neg_volume = neg_volume_flow.rolling(window=20).sum().abs()\n    volume_ratio = total_pos_volume / total_neg_volume\n\n    # Calculate Aroon Oscillator\n    df['aroon_up'] = df['high'].rolling(window=25).apply(lambda x: (x.argmax() - 24) / 24 * 100, raw=True)\n    df['aroon_down'] = df['low'].rolling(window=25).apply(lambda x: (x.argmin() - 24) / 24 * 100, raw=True)\n    aroon_oscillator = df['aroon_up'] - df['aroon_down']\n\n    # Calculate 10-Day High Minus Low\n    price_range = df['high'].rolling(window=10).max() - df['low'].rolling(window=10).min()\n\n    # Combine all factors into a single heuristic factor\n    heuristics_matrix = volume_ratio + aroon_oscillator + price_range\n\n    return heuristics_matrix",
          "objective": -0.02206,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor by combining the difference between the 50-day and 200-day simple moving averages with the Chaikin Money Flow (CMF) over a 20-day period.",
          "code": "def heuristics_v2(df):\n    # Calculate 50-day and 200-day simple moving averages\n    sma_50 = df['close'].rolling(window=50).mean()\n    sma_200 = df['close'].rolling(window=200).mean()\n    sma_diff = sma_50 - sma_200\n\n    # Calculate Chaikin Money Flow (CMF)\n    money_flow_multiplier = ((df['close'] - df['low']) - (df['high'] - df['close'])) / (df['high'] - df['low'])\n    money_flow_volume = money_flow_multiplier * df['volume']\n    cmf = money_flow_volume.rolling(window=20).sum() / df['volume'].rolling(window=20).sum()\n\n    # Combine SMA difference and CMF into a single heuristic factor\n    heuristics_matrix = sma_diff + cmf\n\n    return heuristics_matrix",
          "objective": -0.01998,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm, named Enhanced Momentum-Trend Integration, modifies the weight allocation between RSI and PSAR and adjusts the calculation of PSAR to be more sensitive by changing the acceleration factor.",
          "code": "def heuristics_v2(df):\n    # Calculate RSI\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate Parabolic SAR with adjusted parameters\n    high = df['high']\n    low = df['low']\n    close = df['close']\n    psar = close.copy()\n    psar[0] = high[0]\n    ep = high[0]\n    acc_factor = 0.03  # Increased initial acceleration factor\n    max_acc_factor = 0.3  # Increased maximum acceleration factor\n    increment = acc_factor\n    direction = 1 if close[1] > psar[0] else -1\n    \n    for i in range(1, len(close)):\n        if direction == 1:\n            psar[i] = psar[i-1] + increment\n            if high[i] > ep:\n                ep = high[i]\n                increment = min(increment + acc_factor, max_acc_factor)\n            if psar[i] > low[i] or psar[i] > ep:\n                direction = -1\n                psar[i] = ep\n                ep = low[i]\n                increment = acc_factor\n        else:\n            psar[i] = psar[i-1] - increment\n            if low[i] < ep:\n                ep = low[i]\n                increment = min(increment + acc_factor, max_acc_factor)\n            if psar[i] < high[i] or psar[i] < ep:\n                direction = 1\n                psar[i] = ep\n                ep = high[i]\n                increment = acc_factor\n    \n    # Combine RSI and PSAR into a single heuristic factor with different weights\n    heuristics_matrix = 0.7 * rsi + 0.3 * (psar - close)\n\n    return heuristics_matrix",
          "objective": -0.01931,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a weighted sum of the relative strength index (RSI) and the moving average convergence divergence (MACD), combined with a smoothed volatility factor, to produce an interpretable alpha factor.",
          "code": "def heuristics_v2(df):\n    # Calculate RSI\n    delta = df['close'].diff(1)\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n\n    # Calculate MACD\n    exp12 = df['close'].ewm(span=12, adjust=False).mean()\n    exp26 = df['close'].ewm(span=26, adjust=False).mean()\n    macd = exp12 - exp26\n    signal = macd.rolling(window=9).mean()\n\n    # Calculate smoothed volatility as the exponential moving average of the standard deviation of the last 20 days' returns\n    daily_returns = df['close'].pct_change()\n    volatility = daily_returns.rolling(window=20).std().ewm(span=5, adjust=False).mean()\n\n    # Combine RSI, MACD signal line, and smoothed volatility into a single heuristic factor\n    heuristics_matrix = rsi + signal - volatility\n\n    return heuristics_matrix",
          "objective": -0.01896,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm modifies the original by incorporating a momentum indicator based on the 10-day and 30-day simple moving averages (SMA) of the closing prices, alongside the Aroon Oscillator and the ratio of positive to negative volume flow, providing a refined perspective on price and volume trends.",
          "code": "def heuristics_v2(df):\n    # Calculate Positive and Negative Volume Flow\n    df['volume_change'] = df['volume'].diff()\n    pos_volume_flow = (df['volume_change'] > 0) * df['volume']\n    neg_volume_flow = (df['volume_change'] < 0) * df['volume']\n    total_pos_volume = pos_volume_flow.rolling(window=20).sum()\n    total_neg_volume = neg_volume_flow.rolling(window=20).sum().abs()\n    volume_ratio = total_pos_volume / total_neg_volume\n\n    # Calculate Aroon Oscillator\n    df['aroon_up'] = df['high'].rolling(window=25).apply(lambda x: (x.argmax() - 24) / 24 * 100, raw=True)\n    df['aroon_down'] = df['low'].rolling(window=25).apply(lambda x: (x.argmin() - 24) / 24 * 100, raw=True)\n    aroon_oscillator = df['aroon_up'] - df['aroon_down']\n\n    # Add Momentum Indicator\n    sma_10 = df['close'].rolling(window=10).mean()\n    sma_30 = df['close'].rolling(window=30).mean()\n    momentum_indicator = sma_10 - sma_30\n\n    # Combine all factors into a single heuristic factor\n    heuristics_matrix = volume_ratio + aroon_oscillator + momentum_indicator\n\n    return heuristics_matrix",
          "objective": -0.01882,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm, named Trend-Magnitude Heuristics, combines the Average True Range (ATR) as a volatility measure with a directional movement indicator (DMI) to capture the strength and direction of the trend.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def average_true_range(high, low, close, window=14):\n        tr = pd.Series(0.0, index=high.index)\n        for i in range(1, len(close)):\n            hl = high[i] - low[i]\n            hpc = abs(high[i] - close[i-1])\n            lpc = abs(low[i] - close[i-1])\n            tr[i] = max(hl, hpc, lpc)\n        atr = tr.rolling(window=window).mean()\n        return atr\n\n    def directional_movement(high, low, window=14):\n        up_move = high.diff()\n        down_move = low.diff().abs()\n        pos_dm = pd.Series(0.0, index=up_move.index)\n        neg_dm = pd.Series(0.0, index=down_move.index)\n        \n        for i in range(1, len(up_move)):\n            if up_move[i] > down_move[i] and up_move[i] > 0:\n                pos_dm[i] = up_move[i]\n            else:\n                pos_dm[i] = 0\n            if down_move[i] > up_move[i] and down_move[i] > 0:\n                neg_dm[i] = down_move[i]\n            else:\n                neg_dm[i] = 0\n                \n        di_pos = 100 * (pos_dm.rolling(window=window).sum() / average_true_range(high, low, close, window))\n        di_neg = 100 * (neg_dm.rolling(window=window).sum() / average_true_range(high, low, close, window))\n        return di_pos, di_neg\n\n    high = df['high']\n    low = df['low']\n    close = df['close']\n\n    atr = average_true_range(high, low, close)\n    di_pos, di_neg = directional_movement(high, low)\n\n    heuristics_matrix = 0.5 * (di_pos - di_neg) + 0.5 * atr\n    return heuristics_matrix",
          "objective": -0.01855,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a novel factor by incorporating the exponential moving average crossover signal with the difference between the 12-day and 26-day exponential moving averages of the closing price, combined with the relative strength index (RSI) over a 14-day period.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    ema_12 = df['close'].ewm(span=12, adjust=False).mean()\n    ema_26 = df['close'].ewm(span=26, adjust=False).mean()\n    ema_crossover = ema_12 - ema_26\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    heuristics_matrix = (ema_crossover + rsi) / 2\n    return heuristics_matrix",
          "objective": -0.01833,
          "other_inf": null
     }
]