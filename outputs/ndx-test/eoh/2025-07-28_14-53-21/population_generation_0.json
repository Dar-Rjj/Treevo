[
     {
          "algorithm": "The algorithm, called Trend-Momentum Heuristics, integrates moving average convergence divergence (MACD) and relative strength index (RSI) to generate a novel alpha factor reflecting both trend-following and momentum characteristics.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def macd(series, fast=12, slow=26, signal=9):\n        exp1 = series.ewm(span=fast, adjust=False).mean()\n        exp2 = series.ewm(span=slow, adjust=False).mean()\n        macd = exp1 - exp2\n        signal_line = macd.ewm(span=signal, adjust=False).mean()\n        return macd - signal_line\n\n    def rsi(series, periods=14):\n        delta = series.diff(1)\n        gain = delta.where(delta > 0, 0)\n        loss = -delta.where(delta < 0, 0)\n        avg_gain = gain.rolling(window=periods, min_periods=1).mean()\n        avg_loss = loss.rolling(window=periods, min_periods=1).mean()\n        rs = avg_gain / avg_loss\n        return 100 - (100 / (1 + rs))\n    \n    close_prices = df['close']\n    macd_values = macd(close_prices)\n    rsi_values = rsi(close_prices)\n    heuristics_matrix = 0.5 * macd_values + 0.5 * rsi_values\n    return heuristics_matrix",
          "objective": -0.01518,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a custom weighted sum of momentum and mean reversion signals, along with trading volume changes, to produce an interpretable alpha factor.",
          "code": "def heuristics_v2(df):\n    # Calculate momentum as the difference between the 5-day and 20-day moving average of close prices\n    momentum = df['close'].rolling(window=5).mean() - df['close'].rolling(window=20).mean()\n    \n    # Calculate a simple mean reversion signal as the inverse of the recent 5-day return\n    mean_reversion = -1 * (df['close'] / df['close'].shift(5) - 1)\n    \n    # Adjust for trading volume by multiplying the mean reversion and momentum indicators with the ratio of current volume to 5-day average volume\n    volume_adjustment = df['volume'] / df['volume'].rolling(window=5).mean()\n    \n    # Combine the momentum, mean reversion, and adjusted volume into a single heuristic factor\n    heuristics_matrix = (momentum + mean_reversion) * volume_adjustment\n    \n    return heuristics_matrix",
          "objective": -0.01272,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a unique factor by combining the percentage change in closing price with the ratio of volume to its moving average, aiming to capture both momentum and relative liquidity.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    close_change = df['close'].pct_change()\n    vol_ave = df['volume'].rolling(window=20).mean()\n    vol_ratio = df['volume'] / vol_ave\n    heuristics_matrix = (close_change + vol_ratio) / 2\n    return heuristics_matrix",
          "objective": -0.01195,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a weighted combination of moving averages and volatility measures over different time windows to generate an alpha factor, aiming at capturing both momentum and mean-reversion tendencies in stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def calculate_volatility(series, window):\n        return series.rolling(window=window).std()\n\n    short_window = 10\n    medium_window = 30\n    long_window = 90\n    \n    # Calculate moving averages\n    short_ma = df['close'].rolling(window=short_window).mean()\n    medium_ma = df['close'].rolling(window=medium_window).mean()\n    long_ma = df['close'].rolling(window=long_window).mean()\n    \n    # Calculate volatilities\n    short_vol = calculate_volatility(df['close'], short_window)\n    medium_vol = calculate_volatility(df['close'], medium_window)\n    long_vol = calculate_volatility(df['close'], long_window)\n\n    # Compute the heuristics\n    heuristics_matrix = (short_ma * 0.4 + medium_ma * 0.3 + long_ma * 0.1) - (short_vol * 0.1 + medium_vol * 0.1 + long_vol * 0.05)\n    \n    return heuristics_matrix",
          "objective": -0.01115,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a unique set of heuristic scores for each trading day based on weighted combinations of price and volume changes, aiming to predict future stock returns.",
          "code": "def heuristics_v2(df):\n    def calculate_heuristic(row):\n        # Example heuristic calculation: (close - open) / open + (volume / 1000000)\n        return (row['close'] - row['open']) / row['open'] + (row['volume'] / 1000000)\n\n    heuristics_matrix = df.apply(calculate_heuristic, axis=1)\n    return heuristics_matrix",
          "objective": -0.01059,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies potential alpha factors by calculating the difference between the closing price and the average of the high and low prices, then applying a moving average to smooth these differences, aiming to capture a trend-following signal.",
          "code": "def heuristics_v2(df):\n    # Calculate the average of High and Low prices\n    avg_high_low = (df['high'] + df['low']) / 2\n    \n    # Compute the difference between Close and the average of High and Low\n    diff_close_avg_high_low = df['close'] - avg_high_low\n    \n    # Apply a simple moving average on the computed differences\n    heuristics_matrix = diff_close_avg_high_low.rolling(window=10).mean()\n    \n    return heuristics_matrix",
          "objective": -0.00988,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm, called MomentumDivergence, identifies stocks with positive momentum in price while simultaneously having a decrease in trading volume, indicating a potential reversal or consolidation phase.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    df['price_change'] = df['close'].pct_change()\n    df['volume_change'] = df['volume'].pct_change()\n    df['momentum_divergence'] = (df['price_change'] > 0) & (df['volume_change'] < 0)\n    heuristics_matrix = df['momentum_divergence'].astype(int)\n    return heuristics_matrix",
          "objective": -0.00702,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a unique heuristic factor for each date by calculating the weighted sum of price momentum (close - open), volume-adjusted trading range (high - low), and volatility (standard deviation of log returns over the past 5 days), with weights being the inverse of their respective standard deviations over the entire dataset.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    price_momentum = df['close'] - df['open']\n    trading_range = (df['high'] - df['low']) * df['volume']\n    log_returns = np.log(df['close'] / df['close'].shift(1))\n    volatility = log_returns.rolling(window=5).std()\n    \n    # Calculate the overall standard deviation for each component to use as weights\n    weight_pm = 1 / price_momentum.std()\n    weight_tr = 1 / trading_range.std()\n    weight_vol = 1 / volatility.std()\n    \n    # Compute the heuristic factor\n    heuristics_matrix = (price_momentum * weight_pm) + (trading_range * weight_tr) + (volatility * weight_vol)\n    \n    return heuristics_matrix",
          "objective": -0.006,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a novel alpha factor by incorporating the weighted average of high and low prices, adjusted by volume, to predict future stock returns.",
          "code": "def heuristics_v2(df):\n    df['high_low_avg'] = (df['high'] + df['low']) / 2\n    df['vol_adj_factor'] = df['high_low_avg'] * df['volume']\n    heuristics_matrix = df.groupby(df.index).apply(lambda x: (x['close'] - x['open']) / x['vol_adj_factor'].mean())\n    return heuristics_matrix",
          "objective": -0.00413,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies potential alpha factors by calculating the difference between the closing price and a weighted moving average of the high and low prices, then dividing this result by the volume to generate a heuristics matrix.",
          "code": "def heuristics_v2(df):\n    weights = [0.5, 0.5]  # Equal weights for high and low\n    df['weighted_avg'] = (df['high'] * weights[0] + df['low'] * weights[1])\n    df['heuristics_factor'] = (df['close'] - df['weighted_avg']) / df['volume']\n    heuristics_matrix = df['heuristics_factor']\n    return heuristics_matrix",
          "objective": -0.00205,
          "other_inf": null
     }
]