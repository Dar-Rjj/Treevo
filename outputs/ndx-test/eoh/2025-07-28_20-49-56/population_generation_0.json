[
     {
          "algorithm": "The algorithm calculates a novel alpha factor by first computing the relative strength index (RSI) and then combining it with a momentum indicator, specifically the rate of change (ROC), to generate a composite heuristics matrix.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the RSI for a 14-day period\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).fillna(0)\n    loss = (-delta.where(delta < 0, 0)).fillna(0)\n    avg_gain = gain.rolling(window=14).mean()\n    avg_loss = loss.rolling(window=14).mean()\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate the ROC for a 12-day period\n    roc = ((df['close'] - df['close'].shift(12)) / df['close'].shift(12)) * 100\n    \n    # Combine RSI and ROC into a single heuristics measure\n    heuristics_matrix = (rsi + roc) / 2\n    return heuristics_matrix",
          "objective": -0.01999,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a novel alpha factor by considering the momentum and volatility of the price, combined with the relative strength index (RSI) to gauge overbought or oversold conditions, without normalizing the data.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def momentum(df, n=14):\n        return df['close'].pct_change(n)\n\n    def rsi(df, n=14):\n        delta = df['close'].diff(1)\n        gain = (delta.where(delta > 0, 0)).rolling(window=n).mean()\n        loss = (-delta.where(delta < 0, 0)).rolling(window=n).mean()\n        rs = gain / loss\n        return 100 - (100 / (1 + rs))\n\n    def volatility(df, n=14):\n        return df['close'].pct_change().rolling(window=n).std()\n\n    df['momentum'] = momentum(df)\n    df['rsi'] = rsi(df)\n    df['volatility'] = volatility(df)\n\n    heuristics_matrix = df[['momentum', 'rsi', 'volatility']].mean(axis=1).rename('heuristics')\n\n    return heuristics_matrix",
          "objective": -0.01819,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a composite factor by combining moving averages of different lengths and volume changes, aiming to capture both momentum and volume trends.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate short-term and long-term moving averages\n    short_ma = df['close'].rolling(window=10).mean()\n    long_ma = df['close'].rolling(window=50).mean()\n    \n    # Calculate the difference between short and long term MAs\n    ma_diff = short_ma - long_ma\n    \n    # Compute the daily change in volume\n    volume_change = df['volume'].pct_change()\n    \n    # Combine the two signals into a single heuristic\n    heuristics_matrix = (ma_diff + volume_change).fillna(0)\n    \n    return heuristics_matrix",
          "objective": -0.01437,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a novel alpha factor by calculating the ratio of the difference between the highest and lowest price to the closing price, then adjusts this value based on the volume change from the previous day, encapsulating both volatility and liquidity considerations.",
          "code": "def heuristics_v2(df):\n    heuristics_matrix = (df['high'] - df['low']) / df['close']\n    heuristics_matrix = heuristics_matrix * (df['volume'] / df['volume'].shift(1))\n    return heuristics_matrix",
          "objective": -0.01405,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies patterns in the historical price and volume data to generate a composite heuristics factor by combining simple moving averages, relative strength index (RSI), and price-volume trend (PVT) without normalizing the data.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef calculate_sma(df, window):\n    return df['close'].rolling(window=window).mean()\n\ndef calculate_rsi(df, window):\n    delta = df['close'].diff(1)\n    gain = (delta.where(delta > 0, 0)).fillna(0)\n    loss = (-delta.where(delta < 0, 0)).fillna(0)\n    avg_gain = gain.rolling(window=window).mean()\n    avg_loss = loss.rolling(window=window).mean()\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n    return rsi\n\ndef calculate_pvt(df):\n    pvt = (df['close'].pct_change() * df['volume']).cumsum()\n    return pvt\n\ndef heuristics_v2(df):\n    sma_short = calculate_sma(df, 10)\n    sma_long = calculate_sma(df, 30)\n    rsi = calculate_rsi(df, 14)\n    pvt = calculate_pvt(df)\n    \n    heuristics_matrix = 0.4 * (sma_short / sma_long) + 0.3 * rsi + 0.3 * pvt\n    return heuristics_matrix",
          "objective": -0.0136,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies patterns in historical trading data by calculating the rolling correlation between daily returns and volumes, then generates a heuristic factor based on the difference between the short-term and long-term moving averages of this correlation.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    returns = df['close'].pct_change()\n    rolling_corr = returns.rolling(window=30).corr(df['volume'])\n    short_term_ma = rolling_corr.rolling(window=10).mean()\n    long_term_ma = rolling_corr.rolling(window=60).mean()\n    heuristics_matrix = short_term_ma - long_term_ma\n    return heuristics_matrix",
          "objective": -0.0125,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a composite factor by combining the momentum of the closing price, the volatility measured over the past N days, and the volume changes, without normalizing any data.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the change in closing price to represent momentum\n    momentum = df['close'].pct_change()\n    \n    # Calculate the rolling standard deviation for volatility\n    volatility = df['close'].rolling(window=30).std()\n    \n    # Calculate the change in volume\n    volume_change = df['volume'].pct_change()\n    \n    # Combine the factors into a composite score\n    heuristics_matrix = (momentum + volatility + volume_change) / 3\n    \n    return heuristics_matrix",
          "objective": -0.00756,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies patterns in the historical price and volume data to generate a unique heuristic factor, which involves computing the difference between the 10-day moving average of the closing price and the 2-day exponential moving average of the volume, aiming to capture momentum and trading activity effects.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    ma_close = df['close'].rolling(window=10).mean()\n    ema_volume = df['volume'].ewm(span=2, adjust=False).mean()\n    heuristics_matrix = ma_close - ema_volume\n    return heuristics_matrix",
          "objective": -0.00745,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a heuristic factor based on the relationship between closing price changes and volume, by calculating the ratio of the difference between the current and previous day's closing prices to the current day's volume, aiming to capture momentum influenced by trading volume.",
          "code": "def heuristics_v2(df):\n    heuristics_matrix = (df['close'].diff() / df['volume']).shift(1)\n    return heuristics_matrix",
          "objective": -0.0071,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm extracts a set of heuristic-based alpha factors by calculating the interaction between price and volume, such as the ratio of closing price to the average of high and low prices, scaled by the percentage change in volume, for each day.",
          "code": "def heuristics_v2(df):\n    # Calculate the daily percentage change in volume\n    volume_change = df['volume'].pct_change()\n    \n    # Compute an interaction factor\n    price_interact = (df['close'] / ((df['high'] + df['low']) / 2)) * (1 + volume_change)\n    \n    # Form the heuristics matrix\n    heuristics_matrix = price_interact\n    \n    return heuristics_matrix",
          "objective": -0.00703,
          "other_inf": null
     }
]