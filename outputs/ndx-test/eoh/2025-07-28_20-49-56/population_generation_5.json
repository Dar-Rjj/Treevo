[
     {
          "algorithm": "The new algorithm calculates a weighted sum of ATR, MFI, and RSI, where the weights are dynamically adjusted based on the 14-day rolling mean of the close price, to better reflect recent market trends.",
          "code": "def heuristics_v2(df):\n    df['H-L'] = abs(df['high'] - df['low'])\n    df['H-PC'] = abs(df['high'] - df['close'].shift(1))\n    df['L-PC'] = abs(df['low'] - df['close'].shift(1))\n    df['TR'] = df[['H-L', 'H-PC', 'L-PC']].max(axis=1)\n    atr = df['TR'].rolling(window=14).mean()\n\n    typical_price = (df['high'] + df['low'] + df['close']) / 3\n    money_flow = typical_price * df['volume']\n    positive_money_flow = money_flow.where(typical_price > typical_price.shift(1), 0)\n    negative_money_flow = money_flow.where(typical_price < typical_price.shift(1), 0)\n    mfi_ratio = positive_money_flow.rolling(window=14).sum() / negative_money_flow.rolling(window=14).sum()\n    mfi = 100 - (100 / (1 + mfi_ratio))\n\n    delta = df['close'].diff()\n    gain = delta.where(delta > 0, 0)\n    loss = -delta.where(delta < 0, 0)\n    avg_gain = gain.rolling(window=14).mean()\n    avg_loss = loss.rolling(window=14).mean()\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n\n    mean_close = df['close'].rolling(window=14).mean()\n    weight_atr = 0.5 * (1 + mean_close / mean_close.max())\n    weight_mfi = 0.2 * (1 + mean_close / mean_close.max())\n    weight_rsi = 0.3 * (1 + mean_close / mean_close.max())\n\n    heuristics_matrix = (weight_atr * atr + weight_mfi * mfi + weight_rsi * rsi)\n\n    return heuristics_matrix",
          "objective": -0.06151,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of ATR, MFI, and RSI, where the weights are dynamically adjusted based on the 14-day rolling standard deviation of the close price, to better reflect recent market volatility and trends.",
          "code": "def heuristics_v2(df):\n    df['H-L'] = abs(df['high'] - df['low'])\n    df['H-PC'] = abs(df['high'] - df['close'].shift(1))\n    df['L-PC'] = abs(df['low'] - df['close'].shift(1))\n    df['TR'] = df[['H-L', 'H-PC', 'L-PC']].max(axis=1)\n    atr = df['TR'].rolling(window=14).mean()\n\n    typical_price = (df['high'] + df['low'] + df['close']) / 3\n    money_flow = typical_price * df['volume']\n    positive_money_flow = money_flow.where(typical_price > typical_price.shift(1), 0)\n    negative_money_flow = money_flow.where(typical_price < typical_price.shift(1), 0)\n    mfi_ratio = positive_money_flow.rolling(window=14).sum() / negative_money_flow.rolling(window=14).sum()\n    mfi = 100 - (100 / (1 + mfi_ratio))\n\n    delta = df['close'].diff()\n    gain = delta.where(delta > 0, 0)\n    loss = -delta.where(delta < 0, 0)\n    avg_gain = gain.rolling(window=14).mean()\n    avg_loss = loss.rolling(window=14).mean()\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n\n    std_close = df['close'].rolling(window=14).std()\n    weight_atr = 0.5 * (1 + std_close / std_close.max())\n    weight_mfi = 0.2 * (1 + std_close / std_close.max())\n    weight_rsi = 0.3 * (1 + std_close / std_close.max())\n\n    heuristics_matrix = (weight_atr * atr + weight_mfi * mfi + weight_rsi * rsi)\n\n    return heuristics_matrix",
          "objective": -0.03967,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm combines the Exponential Moving Average (EMA) ratio, the Relative Strength Index (RSI), and the Average True Range (ATR) into a single alpha factor, with dynamic weights adjusted based on the 14-day rolling standard deviation of the closing price to reflect market volatility.",
          "code": "def heuristics_v2(df):\n    # Calculate the Exponential Moving Averages and their ratio\n    short_term_ema = df['close'].ewm(span=12, adjust=False).mean()\n    long_term_ema = df['close'].ewm(span=26, adjust=False).mean()\n    ema_ratio = short_term_ema / long_term_ema\n\n    # Calculate the Relative Strength Index (RSI)\n    delta = df['close'].diff()\n    gain = delta.where(delta > 0, 0)\n    loss = -delta.where(delta < 0, 0)\n    avg_gain = gain.rolling(window=14).mean()\n    avg_loss = loss.rolling(window=14).mean()\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n\n    # Calculate the Average True Range (ATR)\n    df['H-L'] = abs(df['high'] - df['low'])\n    df['H-PC'] = abs(df['high'] - df['close'].shift(1))\n    df['L-PC'] = abs(df['low'] - df['close'].shift(1))\n    df['TR'] = df[['H-L', 'H-PC', 'L-PC']].max(axis=1)\n    atr = df['TR'].rolling(window=14).mean()\n\n    # Calculate the 14-day rolling standard deviation of the close price\n    std_close = df['close'].rolling(window=14).std()\n\n    # Dynamic weights based on the 14-day rolling standard deviation\n    weight_ema = 0.6 * (1 + std_close / std_close.max())\n    weight_rsi = 0.3 * (1 + std_close / std_close.max())\n    weight_atr = 0.1 * (1 + std_close / std_close.max())\n\n    # Combine EMA ratio, RSI, and ATR into a single heuristics measure\n    heuristics_matrix = (weight_ema * ema_ratio + weight_rsi * rsi + weight_atr * atr)\n    return heuristics_matrix",
          "objective": -0.03822,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm adjusts the EMA spans, RSI window, ATR window, and changes the dynamic weights calculation to be based on the 21-day rolling standard deviation of the closing price, aiming for a more sensitive reaction to market dynamics.",
          "code": "def heuristics_v2(df):\n    # Calculate the Exponential Moving Averages and their ratio\n    short_term_ema = df['close'].ewm(span=9, adjust=False).mean()\n    long_term_ema = df['close'].ewm(span=21, adjust=False).mean()\n    ema_ratio = short_term_ema / long_term_ema\n\n    # Calculate the Relative Strength Index (RSI)\n    delta = df['close'].diff()\n    gain = delta.where(delta > 0, 0)\n    loss = -delta.where(delta < 0, 0)\n    avg_gain = gain.rolling(window=14).mean()\n    avg_loss = loss.rolling(window=14).mean()\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n\n    # Calculate the Average True Range (ATR)\n    df['H-L'] = abs(df['high'] - df['low'])\n    df['H-PC'] = abs(df['high'] - df['close'].shift(1))\n    df['L-PC'] = abs(df['low'] - df['close'].shift(1))\n    df['TR'] = df[['H-L', 'H-PC', 'L-PC']].max(axis=1)\n    atr = df['TR'].rolling(window=21).mean()\n\n    # Calculate the 21-day rolling standard deviation of the close price\n    std_close = df['close'].rolling(window=21).std()\n\n    # Dynamic weights based on the 21-day rolling standard deviation\n    weight_ema = 0.5 * (1 + std_close / std_close.max())\n    weight_rsi = 0.4 * (1 + std_close / std_close.max())\n    weight_atr = 0.1 * (1 + std_close / std_close.max())\n\n    # Combine EMA ratio, RSI, and ATR into a single heuristics measure\n    heuristics_matrix = (weight_ema * ema_ratio + weight_rsi * rsi + weight_atr * atr)\n    return heuristics_matrix",
          "objective": -0.03551,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of ATR, MFI, and RSI, where the weights are dynamically adjusted based on the 20-day rolling standard deviation of the close price, with different weight distributions and a longer lookback period for MFI and RSI.",
          "code": "def heuristics_v2(df):\n    df['H-L'] = abs(df['high'] - df['low'])\n    df['H-PC'] = abs(df['high'] - df['close'].shift(1))\n    df['L-PC'] = abs(df['low'] - df['close'].shift(1))\n    df['TR'] = df[['H-L', 'H-PC', 'L-PC']].max(axis=1)\n    atr = df['TR'].rolling(window=14).mean()\n\n    typical_price = (df['high'] + df['low'] + df['close']) / 3\n    money_flow = typical_price * df['volume']\n    positive_money_flow = money_flow.where(typical_price > typical_price.shift(1), 0)\n    negative_money_flow = money_flow.where(typical_price < typical_price.shift(1), 0)\n    mfi_ratio = positive_money_flow.rolling(window=20).sum() / negative_money_flow.rolling(window=20).sum()\n    mfi = 100 - (100 / (1 + mfi_ratio))\n\n    delta = df['close'].diff()\n    gain = delta.where(delta > 0, 0)\n    loss = -delta.where(delta < 0, 0)\n    avg_gain = gain.rolling(window=20).mean()\n    avg_loss = loss.rolling(window=20).mean()\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n\n    std_close = df['close'].rolling(window=20).std()\n    weight_atr = 0.4 * (1 + std_close / std_close.max())\n    weight_mfi = 0.3 * (1 + std_close / std_close.max())\n    weight_rsi = 0.3 * (1 + std_close / std_close.max())\n\n    heuristics_matrix = (weight_atr * atr + weight_mfi * mfi + weight_rsi * rsi)\n\n    return heuristics_matrix",
          "objective": -0.03518,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of ATR, MFI, and RSI, where the weights are dynamically adjusted based on the 21-day rolling mean of the close price, and incorporates an additional exponential moving average (EMA) of the close price as a factor, to better reflect recent market trends.",
          "code": "def heuristics_v2(df):\n    df['H-L'] = abs(df['high'] - df['low'])\n    df['H-PC'] = abs(df['high'] - df['close'].shift(1))\n    df['L-PC'] = abs(df['low'] - df['close'].shift(1))\n    df['TR'] = df[['H-L', 'H-PC', 'L-PC']].max(axis=1)\n    atr = df['TR'].rolling(window=14).mean()\n\n    typical_price = (df['high'] + df['low'] + df['close']) / 3\n    money_flow = typical_price * df['volume']\n    positive_money_flow = money_flow.where(typical_price > typical_price.shift(1), 0)\n    negative_money_flow = money_flow.where(typical_price < typical_price.shift(1), 0)\n    mfi_ratio = positive_money_flow.rolling(window=14).sum() / negative_money_flow.rolling(window=14).sum()\n    mfi = 100 - (100 / (1 + mfi_ratio))\n\n    delta = df['close'].diff()\n    gain = delta.where(delta > 0, 0)\n    loss = -delta.where(delta < 0, 0)\n    avg_gain = gain.rolling(window=14).mean()\n    avg_loss = loss.rolling(window=14).mean()\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n\n    ema_close = df['close'].ewm(span=21, adjust=False).mean()\n\n    mean_close = df['close'].rolling(window=21).mean()\n    weight_atr = 0.4 * (1 + mean_close / mean_close.max())\n    weight_mfi = 0.2 * (1 + mean_close / mean_close.max())\n    weight_rsi = 0.3 * (1 + mean_close / mean_close.max())\n    weight_ema = 0.1 * (1 + mean_close / mean_close.max())\n\n    heuristics_matrix = (weight_atr * atr + weight_mfi * mfi + weight_rsi * rsi + weight_ema * ema_close)\n\n    return heuristics_matrix",
          "objective": -0.03181,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates an alpha factor by integrating a triple-smoothed PPO with the weighted sum of a 10-day and 20-day MFI, placing more emphasis on short-term momentum.",
          "code": "def heuristics_v2(df):\n    short_term_ema = df['close'].ewm(span=10, adjust=False).mean()\n    long_term_ema = df['close'].ewm(span=30, adjust=False).mean()\n    ppo_line = ((short_term_ema - long_term_ema) / long_term_ema) * 100\n    ppo_smoothed = ppo_line.ewm(span=9, adjust=False).mean().ewm(span=9, adjust=False).mean()\n    typical_price = (df['high'] + df['low'] + df['close']) / 3\n    money_flow = typical_price * df['volume']\n    positive_money_flow = money_flow.where(typical_price > typical_price.shift(1), 0)\n    negative_money_flow = money_flow.where(typical_price < typical_price.shift(1), 0)\n    mfi_ratio_10 = positive_money_flow.rolling(window=10).sum() / negative_money_flow.rolling(window=10).sum()\n    mfi_ratio_20 = positive_money_flow.rolling(window=20).sum() / negative_money_flow.rolling(window=20).sum()\n    mfi_smoothed = (mfi_ratio_10.ewm(span=9, adjust=False).mean() * 0.6 + mfi_ratio_20.ewm(span=9, adjust=False).mean() * 0.4)\n    heuristics_matrix = (ppo_smoothed * 0.8 + mfi_smoothed * 0.2)\n    return heuristics_matrix",
          "objective": -0.03089,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates an alpha factor by combining a modified version of the PPO with a smoothed MFI, placing more emphasis on longer-term trends and a slightly different balance between the PPO and MFI components.",
          "code": "def heuristics_v2(df):\n    short_term_ema = df['close'].ewm(span=20, adjust=False).mean()\n    long_term_ema = df['close'].ewm(span=50, adjust=False).mean()\n    ppo_line = ((short_term_ema - long_term_ema) / long_term_ema) * 100\n    typical_price = (df['high'] + df['low'] + df['close']) / 3\n    money_flow = typical_price * df['volume']\n    positive_money_flow = money_flow.where(typical_price > typical_price.shift(1), 0)\n    negative_money_flow = money_flow.where(typical_price < typical_price.shift(1), 0)\n    mfi_ratio = positive_money_flow.rolling(window=14).sum() / negative_money_flow.rolling(window=14).sum()\n    mfi_smoothed = mfi_ratio.ewm(span=9, adjust=False).mean()\n    heuristics_matrix = (ppo_line * 0.6 + mfi_smoothed * 0.4)\n    return heuristics_matrix",
          "objective": -0.03018,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates an alpha factor by averaging the ratio of the current day's volume to the 30-day average volume with the difference between the 100-day and 250-day Exponential Moving Averages (EMAs) of the closing price, providing a signal for trend changes and trading volume variations.",
          "code": "def heuristics_v2(df):\n    ema_100 = df['close'].ewm(span=100, adjust=False).mean()\n    ema_250 = df['close'].ewm(span=250, adjust=False).mean()\n    avg_volume_30 = df['volume'].rolling(window=30).mean()\n    volume_ratio = df['volume'] / avg_volume_30\n    ema_diff = ema_100 - ema_250\n    heuristics_matrix = (ema_diff + volume_ratio) / 2\n    return heuristics_matrix",
          "objective": -0.02914,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates an alpha factor by adjusting the EMA spans, PPO and MFI weights, and introducing a longer smoothing window for the MFI, aiming to enhance focus on longer-term trends and improve the balance between momentum and money flow indicators.",
          "code": "def heuristics_v2(df):\n    short_term_ema = df['close'].ewm(span=10, adjust=False).mean()\n    long_term_ema = df['close'].ewm(span=70, adjust=False).mean()\n    ppo_line = ((short_term_ema - long_term_ema) / long_term_ema) * 100\n    typical_price = (df['high'] + df['low'] + df['close']) / 3\n    money_flow = typical_price * df['volume']\n    positive_money_flow = money_flow.where(typical_price > typical_price.shift(1), 0)\n    negative_money_flow = money_flow.where(typical_price < typical_price.shift(1), 0)\n    mfi_ratio = positive_money_flow.rolling(window=14).sum() / negative_money_flow.rolling(window=14).sum()\n    mfi_smoothed = mfi_ratio.ewm(span=20, adjust=False).mean()\n    heuristics_matrix = (ppo_line * 0.5 + mfi_smoothed * 0.5)\n    return heuristics_matrix",
          "objective": -0.02891,
          "other_inf": null
     }
]