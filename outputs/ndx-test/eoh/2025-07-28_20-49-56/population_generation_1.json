[
     {
          "algorithm": "The new algorithm combines the volatility measured by the Average True Range (ATR) and the Money Flow Index (MFI) to assess both price volatility and money flow, generating a composite signal.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the Average True Range (ATR) for a 14-day period\n    df['H-L'] = abs(df['high'] - df['low'])\n    df['H-PC'] = abs(df['high'] - df['close'].shift(1))\n    df['L-PC'] = abs(df['low'] - df['close'].shift(1))\n    df['TR'] = df[['H-L', 'H-PC', 'L-PC']].max(axis=1)\n    atr = df['TR'].rolling(window=14).mean()\n    \n    # Calculate the Money Flow Index (MFI) for a 14-day period\n    typical_price = (df['high'] + df['low'] + df['close']) / 3\n    money_flow = typical_price * df['volume']\n    positive_money_flow = money_flow.where(typical_price > typical_price.shift(1), 0)\n    negative_money_flow = money_flow.where(typical_price < typical_price.shift(1), 0)\n    mfi_ratio = positive_money_flow.rolling(window=14).sum() / negative_money_flow.rolling(window=14).sum()\n    mfi = 100 - (100 / (1 + mfi_ratio))\n    \n    # Combine ATR and MFI into a single heuristic measure\n    heuristics_matrix = (atr + mfi) / 2\n    \n    return heuristics_matrix",
          "objective": -0.0271,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates an alpha factor by combining the difference between 20-day and 100-day moving averages of the closing price with a modified RSI that is based on a 28-day window and uses the average of high, low, and close prices.",
          "code": "def heuristics_v2(df):\n    # Calculate short and long term moving averages for the closing price\n    short_term_ma = df['close'].rolling(window=20).mean()\n    long_term_ma = df['close'].rolling(window=100).mean()\n\n    # Calculate the modified RSI using the average of high, low, and close prices\n    avg_price = (df['high'] + df['low'] + df['close']) / 3\n    delta = avg_price.diff(1)\n    gain = (delta.where(delta > 0, 0)).rolling(window=28).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=28).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n\n    # Combine the MA difference and the modified RSI\n    ma_diff = short_term_ma - long_term_ma\n    heuristics_matrix = (ma_diff + rsi) / 2\n\n    return heuristics_matrix",
          "objective": -0.02299,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates an alpha factor by combining the exponential moving average (EMA) crossover signal with a modified RSI that incorporates the median of the open, high, low, and close prices.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate short and long term exponential moving averages for the closing price\n    short_term_ema = df['close'].ewm(span=10, adjust=False).mean()\n    long_term_ema = df['close'].ewm(span=60, adjust=False).mean()\n\n    # Calculate the modified RSI using the median of open, high, low, and close prices\n    med_price = df[['open', 'high', 'low', 'close']].median(axis=1)\n    delta = med_price.diff(1)\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n\n    # Combine the EMA difference and the modified RSI\n    ema_diff = short_term_ema - long_term_ema\n    heuristics_matrix = (ema_diff + rsi) / 2\n\n    return heuristics_matrix",
          "objective": -0.02138,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm integrates the Rate of Change (ROC) and the Chande Momentum Oscillator (CMO) to capture momentum and trend, generating a composite signal for predicting future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the Rate of Change (ROC) for a 14-day period\n    roc = (df['close'] - df['close'].shift(14)) / df['close'].shift(14) * 100\n    \n    # Calculate the Chande Momentum Oscillator (CMO) for a 14-day period\n    cmo_diff = df['close'].diff().apply(lambda x: x if x > 0 else 0).rolling(window=14).sum() - df['close'].diff().apply(lambda x: -x if x < 0 else 0).rolling(window=14).sum()\n    cmo_sum = df['close'].diff().apply(lambda x: abs(x)).rolling(window=14).sum()\n    cmo = cmo_diff / cmo_sum * 100\n    \n    # Combine ROC and CMO into a single heuristic measure\n    heuristics_matrix = (roc + cmo) / 2\n    \n    return heuristics_matrix",
          "objective": -0.02073,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes an alpha factor by combining the exponential moving average (EMA) crossover signals, trading range (difference between high and low), and the percentage change in trading volume, to generate a heuristics matrix.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the EMA for short term (9 days) and long term (21 days)\n    ema_short = df['close'].ewm(span=9, adjust=False).mean()\n    ema_long = df['close'].ewm(span=21, adjust=False).mean()\n    \n    # Generate the EMA crossover signal\n    ema_signal = ema_short - ema_long\n    \n    # Calculate the daily trading range\n    trading_range = df['high'] - df['low']\n    \n    # Calculate the percentage change in trading volume\n    volume_change_pct = df['volume'].pct_change().fillna(0)\n    \n    # Combine the factors into a composite heuristics measure\n    heuristics_matrix = ema_signal + trading_range + volume_change_pct\n    \n    return heuristics_matrix",
          "objective": -0.02047,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a novel alpha factor by first computing the relative strength index (RSI) and then combining it with a momentum indicator, specifically the rate of change (ROC), to generate a composite heuristics matrix.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the RSI for a 14-day period\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).fillna(0)\n    loss = (-delta.where(delta < 0, 0)).fillna(0)\n    avg_gain = gain.rolling(window=14).mean()\n    avg_loss = loss.rolling(window=14).mean()\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate the ROC for a 12-day period\n    roc = ((df['close'] - df['close'].shift(12)) / df['close'].shift(12)) * 100\n    \n    # Combine RSI and ROC into a single heuristics measure\n    heuristics_matrix = (rsi + roc) / 2\n    return heuristics_matrix",
          "objective": -0.01999,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a modified alpha factor by first computing the RSI over a 14-day period, then calculating the ROC over a 20-day period, and finally combining these two indicators through a weighted sum to form the heuristics matrix.",
          "code": "def heuristics_v2(df):\n    # Calculate the RSI for a 14-day period\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).fillna(0)\n    loss = (-delta.where(delta < 0, 0)).fillna(0)\n    avg_gain = gain.rolling(window=14).mean()\n    avg_loss = loss.rolling(window=14).mean()\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate the ROC for a 20-day period\n    roc = ((df['close'] - df['close'].shift(20)) / df['close'].shift(20)) * 100\n    \n    # Combine RSI and ROC into a single heuristics measure with weights\n    heuristics_matrix = (0.6 * rsi + 0.4 * roc)\n    return heuristics_matrix",
          "objective": -0.01903,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes the RSI over a 14-day period and the Rate of Change (ROC) over a 20-day period, then weights the RSI by 0.7 and ROC by 0.3 before summing them to form the heuristics matrix.",
          "code": "def heuristics_v2(df):\n    # Calculate the RSI for a 14-day period\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).fillna(0)\n    loss = (-delta.where(delta < 0, 0)).fillna(0)\n    avg_gain = gain.rolling(window=14).mean()\n    avg_loss = loss.rolling(window=14).mean()\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate the ROC for a 20-day period\n    roc = ((df['close'] - df['close'].shift(20)) / df['close'].shift(20)) * 100\n    \n    # Combine RSI and ROC into a single heuristics measure with specific weights\n    heuristics_matrix = (rsi * 0.7 + roc * 0.3)\n    return heuristics_matrix",
          "objective": -0.01868,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a novel alpha factor by considering the momentum and volatility of the price, combined with the relative strength index (RSI) to gauge overbought or oversold conditions, without normalizing the data.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def momentum(df, n=14):\n        return df['close'].pct_change(n)\n\n    def rsi(df, n=14):\n        delta = df['close'].diff(1)\n        gain = (delta.where(delta > 0, 0)).rolling(window=n).mean()\n        loss = (-delta.where(delta < 0, 0)).rolling(window=n).mean()\n        rs = gain / loss\n        return 100 - (100 / (1 + rs))\n\n    def volatility(df, n=14):\n        return df['close'].pct_change().rolling(window=n).std()\n\n    df['momentum'] = momentum(df)\n    df['rsi'] = rsi(df)\n    df['volatility'] = volatility(df)\n\n    heuristics_matrix = df[['momentum', 'rsi', 'volatility']].mean(axis=1).rename('heuristics')\n\n    return heuristics_matrix",
          "objective": -0.01819,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm integrates a ratio of price change to volume change with a weighted moving average, aiming to incorporate both price momentum and volume activity into a single interpretable factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the short-term and long-term weighted moving averages\n    short_wma = df['close'].ewm(span=10, adjust=False).mean()\n    long_wma = df['close'].ewm(span=50, adjust=False).mean()\n    \n    # Calculate the price change\n    price_change = df['close'].pct_change()\n    \n    # Calculate the volume change\n    volume_change = df['volume'].pct_change()\n    \n    # Compute the ratio of price change to volume change\n    price_vol_ratio = (price_change / volume_change).fillna(0)\n    \n    # Combine the WMA difference and the price-volume ratio\n    heuristics_matrix = (short_wma - long_wma + price_vol_ratio).rename('heuristics')\n    \n    return heuristics_matrix",
          "objective": -0.01799,
          "other_inf": null
     }
]