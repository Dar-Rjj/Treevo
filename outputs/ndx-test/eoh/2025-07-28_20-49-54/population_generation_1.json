[
     {
          "algorithm": "The new algorithm calculates a composite factor by incorporating the difference between exponential moving averages and a modified price-volume relationship, then ranks the stocks based on this factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate short-term and long-term exponential moving averages\n    short_ema = df['close'].ewm(span=12, adjust=False).mean()\n    long_ema = df['close'].ewm(span=26, adjust=False).mean()\n    \n    # Calculate the modified price-volume relationship\n    pv_relationship_modified = (df['close'] * df['volume']) / df['volume'].rolling(window=10).mean()\n    \n    # Compute the difference between short and long exponential moving averages\n    ema_diff = short_ema - long_ema\n    \n    # Apply a custom heuristic to combine the EMA difference and modified price-volume relationship\n    heuristics_matrix = (ema_diff + pv_relationship_modified).rank(pct=True)\n    \n    return heuristics_matrix",
          "objective": -0.06323,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a composite factor by combining moving averages and price-volume relationships, then applies a custom heuristic to rank stock performance.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate short-term and long-term moving averages\n    short_ma = df['close'].rolling(window=10).mean()\n    long_ma = df['close'].rolling(window=50).mean()\n    \n    # Calculate the price-volume relationship\n    pv_relationship = df['close'] / df['volume']\n    \n    # Compute the difference between short and long moving averages\n    ma_diff = short_ma - long_ma\n    \n    # Apply a custom heuristic to combine the moving average difference and price-volume relationship\n    heuristics_matrix = (ma_diff + pv_relationship).rank(pct=True)\n    \n    return heuristics_matrix",
          "objective": -0.04199,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a composite factor using exponential moving averages and the ratio of closing price to high price, then applies a custom heuristic to rank stock performance.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate short-term and long-term exponential moving averages\n    short_ema = df['close'].ewm(span=12, adjust=False).mean()\n    long_ema = df['close'].ewm(span=26, adjust=False).mean()\n    \n    # Calculate the close-to-high price ratio\n    ch_ratio = df['close'] / df['high']\n    \n    # Compute the difference between short and long exponential moving averages\n    ema_diff = short_ema - long_ema\n    \n    # Apply a custom heuristic to combine the EMA difference and close-to-high price ratio\n    heuristics_matrix = (ema_diff + ch_ratio).rank(pct=True)\n    \n    return heuristics_matrix",
          "objective": -0.03997,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the ratio of short-term to long-term moving averages and combines it with a price-volume relationship, then ranks the combined factors.",
          "code": "def heuristics_v2(df):\n    # Calculate short-term and long-term moving averages\n    short_ma = df['close'].rolling(window=10).mean()\n    long_ma = df['close'].rolling(window=50).mean()\n    \n    # Calculate the price-volume relationship\n    pv_relationship = df['close'] * df['volume']\n    \n    # Compute the ratio of short and long moving averages\n    ma_ratio = short_ma / long_ma\n    \n    # Apply a custom heuristic to combine the moving average ratio and price-volume relationship\n    heuristics_matrix = (ma_ratio + pv_relationship).rank(pct=True)\n    \n    return heuristics_matrix",
          "objective": -0.03703,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor based on the exponential moving average (EMA) of the ratio between the high and low prices, combined with the EMA of the standard deviation of daily returns over a 30-day period.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    price_range = df['high'] - df['low']\n    price_ratio = price_range / df['close']\n    daily_returns = df['close'].pct_change()\n    volatility_ema = daily_returns.rolling(window=30).std().ewm(span=30, adjust=False).mean()\n    price_ratio_ema = price_ratio.ewm(span=30, adjust=False).mean()\n    heuristics_matrix = (price_ratio_ema + volatility_ema)\n    return heuristics_matrix",
          "objective": -0.02349,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm modifies the factor by incorporating the volume-adjusted price range and a longer-term (60-day) volatility measure, aiming to capture both short-term price movements and long-term market stability.",
          "code": "def heuristics_v2(df):\n    adj_price_range = (df['high'] - df['low']) / df['volume']\n    price_ratio = adj_price_range / df['close']\n    daily_returns = df['close'].pct_change()\n    long_volatility = daily_returns.rolling(window=60).std()\n    heuristics_matrix = (price_ratio + long_volatility)\n    return heuristics_matrix",
          "objective": -0.02246,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor by weighting the RSI and MFI based on their respective standard deviations, to capture momentum and money flow dynamics with emphasis on volatility.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the Relative Strength Index (RSI)\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate the Money Flow Index (MFI)\n    typical_price = (df['high'] + df['low'] + df['close']) / 3\n    money_flow = typical_price * df['volume']\n    positive_money_flow = money_flow.where(typical_price > typical_price.shift(1), 0)\n    negative_money_flow = money_flow.where(typical_price < typical_price.shift(1), 0)\n    money_ratio = positive_money_flow.rolling(window=14).sum() / negative_money_flow.rolling(window=14).sum()\n    mfi = 100 - (100 / (1 + money_ratio))\n\n    # Calculate the standard deviation of RSI and MFI\n    rsi_std = rsi.std()\n    mfi_std = mfi.std()\n\n    # Weighted combination of RSI and MFI\n    heuristics_matrix = (rsi * mfi_std + mfi * rsi_std) / (rsi_std + mfi_std)\n\n    return heuristics_matrix",
          "objective": -0.02168,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a factor by combining the relative strength index (RSI) based on closing prices with the money flow index (MFI) to capture both price momentum and money flow dynamics.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the Relative Strength Index (RSI)\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate the Money Flow Index (MFI)\n    typical_price = (df['high'] + df['low'] + df['close']) / 3\n    money_flow = typical_price * df['volume']\n    positive_money_flow = money_flow.where(typical_price > typical_price.shift(1), 0)\n    negative_money_flow = money_flow.where(typical_price < typical_price.shift(1), 0)\n    money_ratio = positive_money_flow.rolling(window=14).sum() / negative_money_flow.rolling(window=14).sum()\n    mfi = 100 - (100 / (1 + money_ratio))\n    \n    # Combine the RSI and MFI\n    heuristics_matrix = (rsi + mfi) / 2\n    \n    return heuristics_matrix",
          "objective": -0.0214,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor by weighting the RSI and MFI based on their respective medians, to capture momentum and money flow dynamics with emphasis on central tendency.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the Relative Strength Index (RSI)\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate the Money Flow Index (MFI)\n    typical_price = (df['high'] + df['low'] + df['close']) / 3\n    money_flow = typical_price * df['volume']\n    positive_money_flow = money_flow.where(typical_price > typical_price.shift(1), 0)\n    negative_money_flow = money_flow.where(typical_price < typical_price.shift(1), 0)\n    money_ratio = positive_money_flow.rolling(window=14).sum() / negative_money_flow.rolling(window=14).sum()\n    mfi = 100 - (100 / (1 + money_ratio))\n\n    # Calculate the median of RSI and MFI\n    rsi_median = rsi.median()\n    mfi_median = mfi.median()\n\n    # Weighted combination of RSI and MFI\n    heuristics_matrix = (rsi * mfi_median + mfi * rsi_median) / (rsi_median + mfi_median)\n\n    return heuristics_matrix",
          "objective": -0.02139,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor based on the ratio of the difference between the high and low prices to the closing price, combined with a volatility measure calculated as the standard deviation of daily returns over a 30-day period.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    price_range = df['high'] - df['low']\n    price_ratio = price_range / df['close']\n    daily_returns = df['close'].pct_change()\n    volatility = daily_returns.rolling(window=30).std()\n    heuristics_matrix = (price_ratio + volatility)\n    return heuristics_matrix",
          "objective": -0.01858,
          "other_inf": null
     }
]