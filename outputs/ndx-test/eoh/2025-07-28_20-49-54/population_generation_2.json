[
     {
          "algorithm": "The new algorithm calculates a composite factor using the difference between 9-period and 21-period exponential moving averages, combined with a modified price-volume relationship based on a 5-day rolling volume average, then ranks the stocks based on this factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate short-term and long-term exponential moving averages\n    short_ema = df['close'].ewm(span=9, adjust=False).mean()\n    long_ema = df['close'].ewm(span=21, adjust=False).mean()\n    \n    # Calculate the modified price-volume relationship\n    pv_relationship_modified = (df['close'] * df['volume']) / df['volume'].rolling(window=5).mean()\n    \n    # Compute the difference between short and long exponential moving averages\n    ema_diff = short_ema - long_ema\n    \n    # Apply a custom heuristic to combine the EMA difference and modified price-volume relationship\n    heuristics_matrix = (ema_diff + pv_relationship_modified).rank(pct=True)\n    \n    return heuristics_matrix",
          "objective": -0.07352,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by incorporating the ratio of simple moving averages and a weighted price-volume relationship, then ranks the stocks based on this factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate short-term and long-term simple moving averages\n    short_sma = df['close'].rolling(window=10).mean()\n    long_sma = df['close'].rolling(window=30).mean()\n    \n    # Calculate the weighted price-volume relationship\n    pv_relationship_weighted = (df['close'] * df['volume']) / df['volume'].ewm(span=10, adjust=False).mean()\n    \n    # Compute the ratio of short to long simple moving averages\n    sma_ratio = short_sma / long_sma\n    \n    # Apply a custom heuristic to combine the SMA ratio and weighted price-volume relationship\n    heuristics_matrix = (sma_ratio + pv_relationship_weighted).rank(pct=True)\n    \n    return heuristics_matrix",
          "objective": -0.07124,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by incorporating the difference between exponential moving averages and a modified price-volume relationship, then ranks the stocks based on this factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate short-term and long-term exponential moving averages\n    short_ema = df['close'].ewm(span=12, adjust=False).mean()\n    long_ema = df['close'].ewm(span=26, adjust=False).mean()\n    \n    # Calculate the modified price-volume relationship\n    pv_relationship_modified = (df['close'] * df['volume']) / df['volume'].rolling(window=10).mean()\n    \n    # Compute the difference between short and long exponential moving averages\n    ema_diff = short_ema - long_ema\n    \n    # Apply a custom heuristic to combine the EMA difference and modified price-volume relationship\n    heuristics_matrix = (ema_diff + pv_relationship_modified).rank(pct=True)\n    \n    return heuristics_matrix",
          "objective": -0.06323,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the exponential moving average (EMA) for both short and long terms with different spans, combines it with the ratio of the difference between the high and low price to volume, and ranks the resulting composite factor.",
          "code": "def heuristics_v2(df):\n    # Calculate short-term and long-term exponential moving averages\n    short_ema = df['close'].ewm(span=12, adjust=False).mean()\n    long_ema = df['close'].ewm(span=60, adjust=False).mean()\n    \n    # Calculate the ratio of the difference between high and low prices to volume\n    hlv_ratio = (df['high'] - df['low']) / df['volume']\n    \n    # Compute the ratio of short and long EMAs\n    ema_ratio = short_ema / long_ema\n    \n    # Apply a custom heuristic to combine the EMA ratio and the high-low price to volume ratio\n    heuristics_matrix = (ema_ratio + hlv_ratio).rank(pct=True)\n    \n    return heuristics_matrix",
          "objective": -0.04805,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the exponential moving average (EMA) for both short and long terms, combines it with the ratio of closing price to volume, and ranks the resulting composite factor.",
          "code": "def heuristics_v2(df):\n    # Calculate short-term and long-term exponential moving averages\n    short_ema = df['close'].ewm(span=10, adjust=False).mean()\n    long_ema = df['close'].ewm(span=50, adjust=False).mean()\n    \n    # Calculate the ratio of closing price to volume\n    cpv_ratio = df['close'] / df['volume']\n    \n    # Compute the ratio of short and long EMAs\n    ema_ratio = short_ema / long_ema\n    \n    # Apply a custom heuristic to combine the EMA ratio and closing price to volume ratio\n    heuristics_matrix = (ema_ratio + cpv_ratio).rank(pct=True)\n    \n    return heuristics_matrix",
          "objective": -0.04461,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the difference between the short-term and long-term moving averages, scales it by the logarithm of the price-volume relationship, and ranks the resulting factor.",
          "code": "import numpy as np\n\ndef heuristics_v2(df):\n    # Calculate short-term and long-term moving averages\n    short_ma = df['close'].rolling(window=10).mean()\n    long_ma = df['close'].rolling(window=50).mean()\n    \n    # Calculate the price-volume relationship\n    pv_relationship = np.log(df['close'] * df['volume'])\n    \n    # Compute the difference of short and long moving averages\n    ma_diff = short_ma - long_ma\n    \n    # Scale the moving average difference by the log of the price-volume relationship\n    scaled_factor = ma_diff * pv_relationship\n    \n    # Rank the scaled factors\n    heuristics_matrix = scaled_factor.rank(pct=True)\n    \n    return heuristics_matrix",
          "objective": -0.04241,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a composite factor by combining moving averages and price-volume relationships, then applies a custom heuristic to rank stock performance.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate short-term and long-term moving averages\n    short_ma = df['close'].rolling(window=10).mean()\n    long_ma = df['close'].rolling(window=50).mean()\n    \n    # Calculate the price-volume relationship\n    pv_relationship = df['close'] / df['volume']\n    \n    # Compute the difference between short and long moving averages\n    ma_diff = short_ma - long_ma\n    \n    # Apply a custom heuristic to combine the moving average difference and price-volume relationship\n    heuristics_matrix = (ma_diff + pv_relationship).rank(pct=True)\n    \n    return heuristics_matrix",
          "objective": -0.04199,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a composite factor by integrating the momentum of price changes with a volatility-adjusted volume, then applies a custom heuristic to rank stock performance.",
          "code": "def heuristics_v2(df):\n    # Calculate short-term and long-term moving averages\n    short_ma = df['close'].rolling(window=10).mean()\n    long_ma = df['close'].rolling(window=50).mean()\n    \n    # Calculate the momentum of price changes\n    momentum = df['close'] - df['close'].shift(10)\n    \n    # Calculate the standard deviation of prices as a measure of volatility\n    volatility = df['close'].rolling(window=20).std()\n    \n    # Adjust the volume by the volatility\n    adjusted_volume = df['volume'] / volatility\n    \n    # Apply a custom heuristic to combine the momentum and the adjusted volume\n    heuristics_matrix = (momentum + adjusted_volume).rank(pct=True)\n    \n    return heuristics_matrix",
          "objective": -0.04102,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a composite factor using exponential moving averages and the ratio of closing price to high price, then applies a custom heuristic to rank stock performance.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate short-term and long-term exponential moving averages\n    short_ema = df['close'].ewm(span=12, adjust=False).mean()\n    long_ema = df['close'].ewm(span=26, adjust=False).mean()\n    \n    # Calculate the close-to-high price ratio\n    ch_ratio = df['close'] / df['high']\n    \n    # Compute the difference between short and long exponential moving averages\n    ema_diff = short_ema - long_ema\n    \n    # Apply a custom heuristic to combine the EMA difference and close-to-high price ratio\n    heuristics_matrix = (ema_diff + ch_ratio).rank(pct=True)\n    \n    return heuristics_matrix",
          "objective": -0.03997,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor using the difference between long-term and short-term exponential moving averages, alongside the ratio of closing price to low price, then ranks stock performance based on a custom heuristic.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate short-term and long-term exponential moving averages\n    short_ema = df['close'].ewm(span=12, adjust=False).mean()\n    long_ema = df['close'].ewm(span=26, adjust=False).mean()\n    \n    # Calculate the close-to-low price ratio\n    cl_ratio = df['close'] / df['low']\n    \n    # Compute the difference between long and short exponential moving averages\n    ema_diff = long_ema - short_ema\n    \n    # Apply a custom heuristic to combine the EMA difference and close-to-low price ratio\n    heuristics_matrix = (ema_diff + cl_ratio).rank(pct=True)\n    \n    return heuristics_matrix",
          "objective": -0.0399,
          "other_inf": null
     }
]