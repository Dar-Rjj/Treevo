[
     {
          "algorithm": "The new algorithm calculates a composite factor by integrating the ratio of high price to low price with the exponential moving average (EMA) of the closing price, then ranks stock performance based on this custom heuristic.",
          "code": "def heuristics_v2(df):\n    # Calculate the volume weighted average price (VWAP)\n    vwap = (df['close'] * df['volume']).cumsum() / df['volume'].cumsum()\n    \n    # Calculate the high-to-low price ratio\n    hl_ratio = df['high'] / df['low']\n    \n    # Compute the exponential moving average (EMA) of the closing price\n    ema_close = df['close'].ewm(span=10, adjust=False).mean()\n    \n    # Apply a custom heuristic to combine the high-to-low price ratio and the EMA of the closing price\n    heuristics_matrix = (hl_ratio + ema_close).rank(pct=True)\n    \n    return heuristics_matrix",
          "objective": -0.14093,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor using the ratio of 10-period and 20-period exponential moving averages, combined with a smoothed price-volume momentum indicator based on a 5-day rolling volume sum, then ranks the stocks based on this factor.",
          "code": "def heuristics_v2(df):\n    short_ema = df['close'].ewm(span=10, adjust=False).mean()\n    long_ema = df['close'].ewm(span=20, adjust=False).mean()\n    pv_momentum_smoothed = (df['close'] * df['volume']).rolling(window=5).sum() / df['volume'].rolling(window=5).sum()\n    ema_ratio = short_ema / long_ema\n    heuristics_matrix = (ema_ratio + pv_momentum_smoothed).rank(pct=True)\n    return heuristics_matrix",
          "objective": -0.14066,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor using the ratio of 10-period and 30-period exponential moving averages, combined with a smoothed price-volume momentum indicator based on a 5-day rolling volume sum, then ranks the stocks based on this factor.",
          "code": "def heuristics_v2(df):\n    # Calculate short-term and long-term exponential moving averages\n    short_ema = df['close'].ewm(span=10, adjust=False).mean()\n    long_ema = df['close'].ewm(span=30, adjust=False).mean()\n    \n    # Calculate the smoothed price-volume momentum\n    pv_momentum_smoothed = (df['close'] * df['volume']).rolling(window=5).sum() / df['volume'].rolling(window=5).sum()\n    \n    # Compute the ratio between short and long exponential moving averages\n    ema_ratio = short_ema / long_ema\n    \n    # Apply a custom heuristic to combine the EMA ratio and smoothed price-volume momentum\n    heuristics_matrix = (ema_ratio + pv_momentum_smoothed).rank(pct=True)\n    \n    return heuristics_matrix",
          "objective": -0.14065,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor using the ratio of 13-period and 26-period exponential moving averages, combined with a smoothed price-volume momentum indicator based on a 7-day rolling volume sum, then ranks the stocks based on this factor.",
          "code": "def heuristics_v2(df):\n    # Calculate short-term and long-term exponential moving averages\n    short_ema = df['close'].ewm(span=13, adjust=False).mean()\n    long_ema = df['close'].ewm(span=26, adjust=False).mean()\n    \n    # Calculate the smoothed price-volume momentum\n    pv_momentum_smoothed = (df['close'] * df['volume']).rolling(window=7).sum() / df['volume'].rolling(window=7).sum()\n    \n    # Compute the ratio between short and long exponential moving averages\n    ema_ratio = short_ema / long_ema\n    \n    # Apply a custom heuristic to combine the EMA ratio and smoothed price-volume momentum\n    heuristics_matrix = (ema_ratio + pv_momentum_smoothed).rank(pct=True)\n    \n    return heuristics_matrix",
          "objective": -0.13982,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor using the ratio of 14-period and 28-period exponential moving averages, combined with a smoothed price-volume momentum indicator based on a 10-day rolling volume sum, then ranks the stocks based on this factor.",
          "code": "def heuristics_v2(df):\n    # Calculate short-term and long-term exponential moving averages\n    short_ema = df['close'].ewm(span=14, adjust=False).mean()\n    long_ema = df['close'].ewm(span=28, adjust=False).mean()\n    \n    # Calculate the smoothed price-volume momentum\n    pv_momentum_smoothed = (df['close'] * df['volume']).rolling(window=10).sum() / df['volume'].rolling(window=10).sum()\n    \n    # Compute the ratio between short and long exponential moving averages\n    ema_ratio = short_ema / long_ema\n    \n    # Apply a custom heuristic to combine the EMA ratio and smoothed price-volume momentum\n    heuristics_matrix = (ema_ratio + pv_momentum_smoothed).rank(pct=True)\n    \n    return heuristics_matrix",
          "objective": -0.13869,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor using the ratio of high price to low price, combined with the difference between closing price and volume weighted average price, then ranks stock performance based on this custom heuristic.",
          "code": "def heuristics_v2(df):\n    # Calculate the volume weighted average price (VWAP)\n    vwap = (df['close'] * df['volume']).cumsum() / df['volume'].cumsum()\n    \n    # Calculate the high-to-low price ratio\n    hl_ratio = df['high'] / df['low']\n    \n    # Compute the difference between closing price and VWAP\n    cp_vwap_diff = df['close'] - vwap\n    \n    # Apply a custom heuristic to combine the high-to-low price ratio and the difference between closing price and VWAP\n    heuristics_matrix = (hl_ratio + cp_vwap_diff).rank(pct=True)\n    \n    return heuristics_matrix",
          "objective": -0.10929,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor using the difference between 9-period and 21-period exponential moving averages, combined with a modified price-volume relationship based on a 5-day rolling volume average, then ranks the stocks based on this factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate short-term and long-term exponential moving averages\n    short_ema = df['close'].ewm(span=9, adjust=False).mean()\n    long_ema = df['close'].ewm(span=21, adjust=False).mean()\n    \n    # Calculate the modified price-volume relationship\n    pv_relationship_modified = (df['close'] * df['volume']) / df['volume'].rolling(window=5).mean()\n    \n    # Compute the difference between short and long exponential moving averages\n    ema_diff = short_ema - long_ema\n    \n    # Apply a custom heuristic to combine the EMA difference and modified price-volume relationship\n    heuristics_matrix = (ema_diff + pv_relationship_modified).rank(pct=True)\n    \n    return heuristics_matrix",
          "objective": -0.07352,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by incorporating the ratio of simple moving averages and a weighted price-volume relationship, then ranks the stocks based on this factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate short-term and long-term simple moving averages\n    short_sma = df['close'].rolling(window=10).mean()\n    long_sma = df['close'].rolling(window=30).mean()\n    \n    # Calculate the weighted price-volume relationship\n    pv_relationship_weighted = (df['close'] * df['volume']) / df['volume'].ewm(span=10, adjust=False).mean()\n    \n    # Compute the ratio of short to long simple moving averages\n    sma_ratio = short_sma / long_sma\n    \n    # Apply a custom heuristic to combine the SMA ratio and weighted price-volume relationship\n    heuristics_matrix = (sma_ratio + pv_relationship_weighted).rank(pct=True)\n    \n    return heuristics_matrix",
          "objective": -0.07124,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor using the difference between 12-period and 26-period exponential moving averages, combined with a modified price-volume relationship based on a 7-day rolling volume average, then ranks the stocks based on this factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate short-term and long-term exponential moving averages\n    short_ema = df['close'].ewm(span=12, adjust=False).mean()\n    long_ema = df['close'].ewm(span=26, adjust=False).mean()\n    \n    # Calculate the modified price-volume relationship\n    pv_relationship_modified = (df['close'] * df['volume']) / df['volume'].rolling(window=7).mean()\n    \n    # Compute the difference between short and long exponential moving averages\n    ema_diff = short_ema - long_ema\n    \n    # Combine the EMA difference and modified price-volume relationship\n    composite_factor = ema_diff + pv_relationship_modified\n    \n    # Rank the stocks based on the composite factor\n    heuristics_matrix = composite_factor.rank(pct=True)\n    \n    return heuristics_matrix",
          "objective": -0.06895,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by integrating the momentum of price changes with a volatility measure, then ranks stock performance using this combined metric.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the rate of change (ROC) over a 10-day period\n    roc = df['close'].pct_change(periods=10)\n    \n    # Calculate the average true range (ATR) over a 14-day period\n    tr = df[['high', 'low']].diff().abs().max(axis=1)\n    atr = tr.rolling(window=14).mean()\n    \n    # Apply a custom heuristic to combine the ROC and ATR\n    heuristics_matrix = (roc - atr).rank(pct=True)\n    \n    return heuristics_matrix",
          "objective": -0.06568,
          "other_inf": null
     }
]