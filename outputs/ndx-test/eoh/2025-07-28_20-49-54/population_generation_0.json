[
     {
          "algorithm": "The algorithm computes a composite factor by combining moving averages and price-volume relationships, then applies a custom heuristic to rank stock performance.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate short-term and long-term moving averages\n    short_ma = df['close'].rolling(window=10).mean()\n    long_ma = df['close'].rolling(window=50).mean()\n    \n    # Calculate the price-volume relationship\n    pv_relationship = df['close'] / df['volume']\n    \n    # Compute the difference between short and long moving averages\n    ma_diff = short_ma - long_ma\n    \n    # Apply a custom heuristic to combine the moving average difference and price-volume relationship\n    heuristics_matrix = (ma_diff + pv_relationship).rank(pct=True)\n    \n    return heuristics_matrix",
          "objective": -0.04199,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm extracts a heuristic factor by calculating the difference between the 21-day and 5-day exponential moving averages (EMA) of the closing prices, aiming to capture medium-term momentum signals.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    ema_21 = df['close'].ewm(span=21, adjust=False).mean()\n    ema_5 = df['close'].ewm(span=5, adjust=False).mean()\n    heuristics_matrix = ema_21 - ema_5\n    return heuristics_matrix",
          "objective": -0.01676,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a factor by computing the difference between the exponential moving average of the closing price over two different periods and then subtracting the volume's rate of change, aiming to capture momentum shifts combined with liquidity signals.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    ema_short = df['close'].ewm(span=12, adjust=False).mean()\n    ema_long = df['close'].ewm(span=26, adjust=False).mean()\n    roc_volume = df['volume'].pct_change()\n    heuristics_matrix = (ema_short - ema_long) - roc_volume\n    return heuristics_matrix",
          "objective": -0.01454,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a composite factor by combining moving averages and volume trends, then weights these according to their relative strengths over different time periods.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Compute short and long term moving averages\n    short_ma = df['close'].rolling(window=10).mean()\n    long_ma = df['close'].rolling(window=50).mean()\n    \n    # Calculate the difference between short and long moving averages\n    ma_diff = short_ma - long_ma\n    \n    # Compute the ratio of current volume to the average volume over 20 days\n    vol_ratio = df['volume'] / df['volume'].rolling(window=20).mean()\n    \n    # Combine the moving average difference and volume ratio\n    heuristics_matrix = (ma_diff + vol_ratio) / 2\n    \n    return heuristics_matrix",
          "objective": -0.01367,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a set of heuristics based on price and volume trends, including moving averages, relative strength, and volume changes, to form a composite factor designed to predict future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Moving Averages\n    df['SMA_5'] = df['close'].rolling(window=5).mean()\n    df['SMA_10'] = df['close'].rolling(window=10).mean()\n    df['SMA_Diff'] = df['SMA_5'] - df['SMA_10']\n    \n    # Relative Strength\n    df['RS'] = df['close'].pct_change().rolling(window=14).mean()\n    \n    # Volume Changes\n    df['Volume_Change'] = df['volume'].pct_change()\n    \n    # Composite Factor\n    heuristics_matrix = (df['SMA_Diff'] + df['RS'] + df['Volume_Change']) / 3\n    \n    return heuristics_matrix",
          "objective": -0.01191,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a set of heuristic-based features from the input DataFrame, including momentum, volatility, and moving average crossovers, then combines these into a single heuristics matrix.",
          "code": "def heuristics_v2(df):\n    heuristics_matrix = (df['close'].pct_change()  # Momentum\n                        + df['close'].rolling(window=10).std()  # Volatility\n                        + (df['close'].rolling(window=5).mean() > df['close'].rolling(window=20).mean()).astype(int))  # Moving Average Crossover\n    return heuristics_matrix",
          "objective": -0.01171,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm, termed Dynamic Correlation Heuristics, calculates the rolling correlation between each pair of market features over a 21-day window to capture short-term trends, subsequently generating a heuristic score for each date based on the aggregated positive correlations minus the aggregated negative ones.}\n\n```python\nimport pandas as pd\n\ndef heuristics_v2(df):\n    # Initialize an empty DataFrame to store the correlation scores\n    corr_scores = pd.DataFrame(index=df.index)\n    \n    # Calculate the rolling 21-day correlation for each pair of columns\n    for col1 in df.columns:\n        for col2 in df.columns:\n            if col1 != col2:\n                corr_label = f'{col1}_corr_{col2",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Initialize an empty DataFrame to store the correlation scores\n    corr_scores = pd.DataFrame(index=df.index)\n    \n    # Calculate the rolling 21-day correlation for each pair of columns\n    for col1 in df.columns:\n        for col2 in df.columns:\n            if col1 != col2:\n                corr_label = f'{col1}_corr_{col2}'\n                corr_scores[corr_label] = df[col1].rolling(window=21).corr(df[col2])\n    \n    # Compute the sum of positive and negative correlations for each row\n    pos_corr_sum = (corr_scores > 0).multiply(corr_scores).sum(axis=1)\n    neg_corr_sum = (corr_scores < 0).multiply(corr_scores).sum(axis=1)\n    \n    # Generate the heuristic score\n    heuristics_matrix = pos_corr_sum - neg_corr_sum\n    \n    return heuristics_matrix",
          "objective": -0.01076,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a heuristic factor based on the exponential moving average (EMA) of the volume and the difference between high and low prices, then combines these with a time-series momentum indicator.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def ema(data, window):\n        return data.ewm(span=window, adjust=False).mean()\n    \n    # Calculate EMA for volume\n    ema_volume = ema(df['volume'], 10)\n    \n    # Calculate the difference between high and low\n    diff_high_low = df['high'] - df['low']\n    \n    # Calculate EMA for the difference between high and low\n    ema_diff_high_low = ema(diff_high_low, 10)\n    \n    # Calculate a simple time-series momentum indicator\n    momentum = df['close'].pct_change(20)\n    \n    # Combine the factors\n    heuristics_matrix = ema_volume + ema_diff_high_low + momentum\n    \n    return heuristics_matrix",
          "objective": -0.00702,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a set of alpha factors by applying a combination of statistical and heuristic transformations, including moving averages and volume trends, to the input market features, then aggregates these into a single factor series.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Compute short and long moving averages for close price\n    df['short_mavg'] = df['close'].rolling(window=10).mean()\n    df['long_mavg'] = df['close'].rolling(window=50).mean()\n    # Calculate the difference between short and long moving averages\n    df['mavg_diff'] = df['short_mavg'] - df['long_mavg']\n    # Calculate the daily return\n    df['daily_return'] = df['close'].pct_change()\n    # Calculate the average daily volume over 10 days\n    df['avg_vol_10d'] = df['volume'].rolling(window=10).mean()\n    # Heuristic score based on momentum and volume\n    df['heuristic_score'] = (df['mavg_diff'] + df['avg_vol_10d']) / 2\n    # Drop rows with NaN values resulting from rolling calculations\n    df.dropna(inplace=True)\n    # Create heuristics_matrix as a Series\n    heuristics_matrix = df['heuristic_score']\n    \n    return heuristics_matrix",
          "objective": -0.00672,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a set of heuristic-based alpha factors by analyzing the relationship between trading volume and price changes, then combining these with moving average crossovers to generate a predictive signal.",
          "code": "def heuristics_v2(df):\n    # Calculate the daily return\n    df['return'] = df['close'].pct_change()\n    \n    # Calculate the 5-day and 20-day moving averages of the closing price\n    df['ma_5'] = df['close'].rolling(window=5).mean()\n    df['ma_20'] = df['close'].rolling(window=20).mean()\n    \n    # Generate signals based on moving average crossovers\n    df['ma_signal'] = (df['ma_5'] > df['ma_20']).astype(int)\n    \n    # Calculate the volume change\n    df['volume_change'] = df['volume'].pct_change()\n    \n    # Generate a combined heuristic factor\n    df['heuristic_factor'] = df['return'] * df['volume_change'] * df['ma_signal']\n    \n    # Return the heuristic factor as a pandas Series\n    heuristics_matrix = df['heuristic_factor'].dropna()\n    return heuristics_matrix",
          "objective": -0.00425,
          "other_inf": null
     }
]