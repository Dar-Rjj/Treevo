[
     {
          "algorithm": "The algorithm calculates a heuristic factor based on the ratio of average daily returns to the standard deviation of daily volumes, aiming to identify stocks with stable returns and consistent trading activity.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily returns\n    daily_returns = df['close'].pct_change()\n    # Calculate the standard deviation of the daily volumes\n    volume_std = df['volume'].std()\n    # Calculate the average of daily returns\n    avg_daily_returns = daily_returns.mean()\n    # Compute the heuristic factor\n    heuristic_factor = avg_daily_returns / volume_std if volume_std > 0 else 0\n    # Create a Series for the heuristic factor, repeating it for each date in the DataFrame\n    heuristics_matrix = pd.Series([heuristic_factor]*len(df), index=df.index)\n    return heuristics_matrix",
          "objective": -0.03215,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor based on the product of the average daily returns and the reciprocal of the coefficient of variation (standard deviation divided by mean) of daily volumes, aiming to highlight stocks with high, stable returns and relatively stable trading volume.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily returns\n    daily_returns = df['close'].pct_change()\n    # Calculate the standard deviation and mean of the daily volumes\n    volume_std = df['volume'].std()\n    volume_mean = df['volume'].mean()\n    # Ensure the mean volume is not zero to avoid division by zero\n    if volume_mean == 0:\n        return pd.Series([0]*len(df), index=df.index)\n    # Coefficient of variation of volume\n    volume_cov = volume_std / volume_mean\n    # Calculate the average of daily returns\n    avg_daily_returns = daily_returns.mean()\n    # Compute the heuristic factor\n    heuristic_factor = avg_daily_returns * (1/volume_cov) if volume_cov > 0 else 0\n    # Create a Series for the heuristic factor, repeating it for each date in the DataFrame\n    heuristics_matrix = pd.Series([heuristic_factor]*len(df), index=df.index)\n    return heuristics_matrix",
          "objective": -0.03075,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a novel heuristic factor by integrating the rate of change (ROC) of the closing prices with the average directional index (ADX) to signal both trend strength and price momentum, thereby predicting future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate ROC\n    roc = df['close'].pct_change(periods=10)\n    \n    # Calculate True Range\n    tr1 = df['high'] - df['low']\n    tr2 = abs(df['high'] - df['close'].shift(1))\n    tr3 = abs(df['low'] - df['close'].shift(1))\n    true_range = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)\n    \n    # Calculate +DM and -DM\n    dm_pos = (df['high'].diff(1).fillna(0)).where((df['high'] - df['high'].shift(1)) > (df['low'].shift(1) - df['low']), 0)\n    dm_neg = (df['low'].shift(1) - df['low']).where((df['low'].shift(1) - df['low']) > (df['high'] - df['high'].shift(1)), 0)\n    \n    # Smooth +DM and -DM\n    smooth_dm_pos = dm_pos.rolling(window=14).sum()\n    smooth_dm_neg = dm_neg.rolling(window=14).sum()\n    smooth_true_range = true_range.rolling(window=14).sum()\n    \n    # Calculate +DI and -DI\n    di_pos = (smooth_dm_pos / smooth_true_range) * 100\n    di_neg = (smooth_dm_neg / smooth_true_range) * 100\n    \n    # Calculate ADX\n    dx = (abs(di_pos - di_neg) / (di_pos + di_neg)) * 100\n    adx = dx.rolling(window=14).mean()\n    \n    # Composite heuristic\n    heuristics_matrix = roc + adx\n    \n    return heuristics_matrix",
          "objective": -0.02769,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the factor by combining the difference between a short-term and long-term Exponential Moving Average (EMA) of the closing price with the relative strength index (RSI) of the closing price, to capture trend and overbought/oversold conditions.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def calculate_ema(series, span):\n        return series.ewm(span=span, adjust=False).mean()\n    \n    def calculate_rsi(series, period):\n        delta = series.diff(1)\n        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()\n        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()\n        rs = gain / loss\n        return 100 - (100 / (1 + rs))\n    \n    ema_short = calculate_ema(df['close'], 10)\n    ema_long = calculate_ema(df['close'], 30)\n    rsi = calculate_rsi(df['close'], 14)\n    \n    heuristics_matrix = (ema_short - ema_long) + rsi\n    \n    return heuristics_matrix",
          "objective": -0.02072,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm extracts alpha factors by calculating the difference between the closing price and a weighted average of the high and low prices, using volume as weights, to generate a heuristics matrix that could predict future stock returns.",
          "code": "def heuristics_v2(df):\n    heuristics_matrix = (df['close'] - ((df['high'] + df['low']) / 2 * df['volume']).rolling(window=10).mean()) / df['volume']\n    return heuristics_matrix",
          "objective": -0.01961,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor using the exponential moving average (EMA) of the daily return over a 20-day span and incorporates the ratio of the volume to the average volume over the last 60 days.",
          "code": "def heuristics_v2(df):\n    df['daily_return'] = df['close'].pct_change()\n    df['avg_volume_60'] = df['volume'].rolling(window=60).mean()\n    df['vol_ratio'] = df['volume'] / df['avg_volume_60']\n    ema_daily_return = df['daily_return'].ewm(span=20, adjust=False).mean()\n    heuristics_matrix = (ema_daily_return + df['vol_ratio']).dropna()\n    return heuristics_matrix",
          "objective": -0.01894,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a composite heuristics factor by calculating the moving average convergence divergence (MACD) of the closing prices and combining it with a 14-day relative strength index (RSI), aiming to capture both momentum and overbought/oversold signals for predicting future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate MACD\n    short_ema = df['close'].ewm(span=12, adjust=False).mean()\n    long_ema = df['close'].ewm(span=26, adjust=False).mean()\n    macd = short_ema - long_ema\n    signal = macd.ewm(span=9, adjust=False).mean()\n    \n    # Calculate RSI\n    delta = df['close'].diff(1)\n    gain = (delta.where(delta > 0, 0)).fillna(0)\n    loss = (-delta.where(delta < 0, 0)).fillna(0)\n    avg_gain = gain.rolling(window=14).mean()\n    avg_loss = loss.rolling(window=14).mean()\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Composite heuristic\n    heuristics_matrix = (macd - signal) + rsi\n    \n    return heuristics_matrix",
          "objective": -0.01853,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a factor based on the exponential moving average (EMA) of the daily return and the ratio of the volume to the average volume over the last 30 days.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    df['daily_return'] = df['close'].pct_change()\n    df['avg_volume_30'] = df['volume'].rolling(window=30).mean()\n    df['vol_ratio'] = df['volume'] / df['avg_volume_30']\n    ema_daily_return = df['daily_return'].ewm(span=10, adjust=False).mean()\n    heuristics_matrix = (ema_daily_return + df['vol_ratio']).dropna()\n    return heuristics_matrix",
          "objective": -0.0182,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates the difference between the closing price and a volume-weighted average of the high and low prices, then smooths this difference using an exponential moving average to generate a heuristics matrix.",
          "code": "def heuristics_v2(df):\n    weighted_avg = (df['high'] + df['low']) / 2 * df['volume']\n    smoothed_avg = weighted_avg.ewm(span=10).mean()\n    heuristics_matrix = (df['close'] - smoothed_avg) / df['volume']\n    return heuristics_matrix",
          "objective": -0.01806,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm enhances the original by incorporating a 20-day price volatility measure, along with the MACD and a 14-day RSI, to better capture market sentiment and momentum.",
          "code": "def heuristics_v2(df):\n    # Calculate MACD\n    short_ema = df['close'].ewm(span=12, adjust=False).mean()\n    long_ema = df['close'].ewm(span=26, adjust=False).mean()\n    macd = short_ema - long_ema\n    signal = macd.ewm(span=9, adjust=False).mean()\n\n    # Calculate RSI\n    delta = df['close'].diff(1)\n    gain = (delta.where(delta > 0, 0)).fillna(0)\n    loss = (-delta.where(delta < 0, 0)).fillna(0)\n    avg_gain = gain.rolling(window=14).mean()\n    avg_loss = loss.rolling(window=14).mean()\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n\n    # Calculate 20-day Volatility\n    volatility = df['close'].pct_change().rolling(window=20).std() * (252 ** 0.5)\n\n    # Composite heuristic\n    heuristics_matrix = (macd - signal) + rsi + volatility\n\n    return heuristics_matrix",
          "objective": -0.01777,
          "other_inf": null
     }
]