[
     {
          "algorithm": "The algorithm calculates a heuristic factor based on the ratio of average daily returns to the standard deviation of daily volumes, aiming to identify stocks with stable returns and consistent trading activity.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily returns\n    daily_returns = df['close'].pct_change()\n    # Calculate the standard deviation of the daily volumes\n    volume_std = df['volume'].std()\n    # Calculate the average of daily returns\n    avg_daily_returns = daily_returns.mean()\n    # Compute the heuristic factor\n    heuristic_factor = avg_daily_returns / volume_std if volume_std > 0 else 0\n    # Create a Series for the heuristic factor, repeating it for each date in the DataFrame\n    heuristics_matrix = pd.Series([heuristic_factor]*len(df), index=df.index)\n    return heuristics_matrix",
          "objective": -0.03215,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm extracts alpha factors by calculating the difference between the closing price and a weighted average of the high and low prices, using volume as weights, to generate a heuristics matrix that could predict future stock returns.",
          "code": "def heuristics_v2(df):\n    heuristics_matrix = (df['close'] - ((df['high'] + df['low']) / 2 * df['volume']).rolling(window=10).mean()) / df['volume']\n    return heuristics_matrix",
          "objective": -0.01961,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a composite heuristics factor by calculating the moving average convergence divergence (MACD) of the closing prices and combining it with a 14-day relative strength index (RSI), aiming to capture both momentum and overbought/oversold signals for predicting future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate MACD\n    short_ema = df['close'].ewm(span=12, adjust=False).mean()\n    long_ema = df['close'].ewm(span=26, adjust=False).mean()\n    macd = short_ema - long_ema\n    signal = macd.ewm(span=9, adjust=False).mean()\n    \n    # Calculate RSI\n    delta = df['close'].diff(1)\n    gain = (delta.where(delta > 0, 0)).fillna(0)\n    loss = (-delta.where(delta < 0, 0)).fillna(0)\n    avg_gain = gain.rolling(window=14).mean()\n    avg_loss = loss.rolling(window=14).mean()\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Composite heuristic\n    heuristics_matrix = (macd - signal) + rsi\n    \n    return heuristics_matrix",
          "objective": -0.01853,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a weighted moving average of the ratio between the closing price and the volume, and the difference between high and low prices, to generate a heuristic factor series.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    df['price_vol_ratio'] = df['close'] / df['volume']\n    df['high_low_diff'] = df['high'] - df['low']\n    weighted_avg = (df['price_vol_ratio'] + 2 * df['high_low_diff']).rolling(window=10).mean()\n    heuristics_matrix = weighted_avg\n    return heuristics_matrix",
          "objective": -0.01456,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm constructs a novel alpha factor by computing the rolling mean of the difference between the daily high and low prices over a 20-day window, followed by subtracting the 60-day exponential moving average of the closing prices.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    diff = df['high'] - df['low']\n    rolling_mean_diff = diff.rolling(window=20).mean()\n    ema_close = df['close'].ewm(span=60, adjust=False).mean()\n    heuristics_matrix = rolling_mean_diff - ema_close\n    return heuristics_matrix",
          "objective": -0.01313,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm extracts momentum and volatility features from the input DataFrame, combining them in a novel way to generate an interpretable alpha factor through a series of arithmetic and statistical operations.",
          "code": "def heuristics_v2(df):\n    # Calculate price change\n    df['price_change'] = df['close'].diff()\n    # Simple moving average for short term trend (e.g., 5 days)\n    short_rolling = df['close'].rolling(window=5).mean()\n    # Simple moving average for long term trend (e.g., 20 days)\n    long_rolling = df['close'].rolling(window=20).mean()\n    # Short term volatility\n    short_volatility = df['close'].rolling(window=5).std()\n    # Long term volatility\n    long_volatility = df['close'].rolling(window=20).std()\n    # Momentum signal: difference between short and long term averages\n    momentum_signal = short_rolling - long_rolling\n    # Volatility adjusted momentum: momentum normalized by long term volatility\n    volatility_adjusted_momentum = momentum_signal / long_volatility\n    # Final heuristic matrix: adjusted momentum plus short term volatility\n    heuristics_matrix = volatility_adjusted_momentum + short_volatility\n    return heuristics_matrix",
          "objective": -0.01083,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies momentum and volatility signals by calculating the difference between the closing price of the current day and the average closing price over a 20-day period, as well as the standard deviation of the closing prices over the same 20 days, to generate alpha factors.",
          "code": "def heuristics_v2(df):\n    df['avg_close_20'] = df['close'].rolling(window=20).mean()\n    df['std_close_20'] = df['close'].rolling(window=20).std()\n    heuristics_matrix = (df['close'] - df['avg_close_20']) / df['std_close_20']\n    return heuristics_matrix",
          "objective": -0.00969,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm constructs a novel alpha factor by calculating the rolling mean and standard deviation of the volume, then combining this with the relative strength index (RSI) of the closing prices over a specified window, and finally subtracting the moving average convergence divergence (MACD) of the closing prices from this combined value.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate Rolling Mean and Standard Deviation for Volume\n    volume_mean = df['volume'].rolling(window=14).mean()\n    volume_std = df['volume'].rolling(window=14).std()\n\n    # Calculate RSI for Close Prices\n    delta = df['close'].diff(1)\n    gain = (delta.where(delta > 0, 0)).fillna(0)\n    loss = (-delta.where(delta < 0, 0)).fillna(0)\n    avg_gain = gain.rolling(window=14).mean()\n    avg_loss = loss.rolling(window=14).mean()\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n\n    # Calculate MACD for Close Prices\n    ema_12 = df['close'].ewm(span=12, adjust=False).mean()\n    ema_26 = df['close'].ewm(span=26, adjust=False).mean()\n    macd = ema_12 - ema_26\n    signal = macd.rolling(window=9).mean()\n    macd_diff = macd - signal\n\n    # Combine all elements into a final heuristic\n    heuristics_matrix = (volume_mean + volume_std + rsi) - macd_diff\n    \n    return heuristics_matrix",
          "objective": -0.00806,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates the momentum of the closing price over a 20-day period and the ratio of today's volume to the average volume over the past 10 days, then combines these two metrics into a single heuristics factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def calculate_momentum(series, window=20):\n        return series / series.shift(window) - 1\n\n    def calculate_volume_ratio(series, window=10):\n        return series / series.rolling(window).mean()\n\n    momentum = calculate_momentum(df['close'])\n    volume_ratio = calculate_volume_ratio(df['volume'])\n\n    heuristics_matrix = (momentum + volume_ratio) / 2\n    \n    return heuristics_matrix",
          "objective": -0.00676,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a heuristic factor based on the weighted combination of price momentum, volume changes, and volatility over a specified window, aiming to capture market dynamics that potentially influence future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate price momentum\n    price_momentum = df['close'].pct_change(periods=5)\n    \n    # Calculate volume change\n    volume_change = df['volume'].pct_change(periods=1)\n    \n    # Calculate daily return\n    daily_return = df['close'].pct_change()\n    \n    # Calculate volatility (standard deviation of daily returns over a window)\n    volatility = daily_return.rolling(window=20).std()\n    \n    # Combine factors into a single score using equal weights\n    heuristics_matrix = 0.3 * price_momentum + 0.3 * volume_change + 0.4 * volatility\n    \n    # Return the heuristics matrix\n    return heuristics_matrix",
          "objective": -0.00535,
          "other_inf": null
     }
]