[
     {
          "algorithm": "The new algorithm calculates a factor based on the difference between the average daily high and low prices over a 30-day period, divided by the standard deviation of the daily closing prices.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the 30-day moving average of daily high and low prices\n    avg_high_low = (df['high'] + df['low']) / 2\n    moving_avg_high_low = avg_high_low.rolling(window=30).mean()\n    \n    # Calculate the standard deviation of daily closing prices\n    close_std = df['close'].std()\n    \n    # Compute the heuristic factor\n    heuristic_factor = (moving_avg_high_low - df['close'].mean()) / close_std if close_std > 0 else 0\n    \n    # Create a Series for the heuristic factor, ensuring it is indexed correctly\n    heuristics_matrix = pd.Series(heuristic_factor, index=df.index)\n    return heuristics_matrix",
          "objective": -0.13241,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor based on the ratio of the average daily returns to the mean of daily volumes, aiming to identify stocks with stable returns and consistent average trading volume.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily returns\n    daily_returns = df['close'].pct_change()\n    # Calculate the mean of the daily volumes\n    volume_mean = df['volume'].mean()\n    # Calculate the average of daily returns\n    avg_daily_returns = daily_returns.mean()\n    # Compute the heuristic factor\n    heuristic_factor = avg_daily_returns / volume_mean if volume_mean > 0 else 0\n    # Create a Series for the heuristic factor, repeating it for each date in the DataFrame\n    heuristics_matrix = pd.Series([heuristic_factor]*len(df), index=df.index)\n    return heuristics_matrix",
          "objective": -0.03397,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a heuristic factor based on the ratio of average daily log returns to the standard deviation of daily closing prices, aiming to identify stocks with stable return patterns and lower price volatility.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate daily log returns\n    daily_log_returns = np.log(df['close']).diff()\n    # Calculate the standard deviation of daily closing prices\n    close_std = df['close'].std()\n    # Calculate the average of daily log returns\n    avg_daily_log_returns = daily_log_returns.mean()\n    # Compute the heuristic factor\n    heuristic_factor = avg_daily_log_returns / close_std if close_std > 0 else 0\n    # Create a Series for the heuristic factor, repeating it for each date in the DataFrame\n    heuristics_matrix = pd.Series([heuristic_factor]*len(df), index=df.index)\n    return heuristics_matrix",
          "objective": -0.03276,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a heuristic factor based on the ratio of average daily returns to the standard deviation of daily volumes, aiming to identify stocks with stable returns and consistent trading activity.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily returns\n    daily_returns = df['close'].pct_change()\n    # Calculate the standard deviation of the daily volumes\n    volume_std = df['volume'].std()\n    # Calculate the average of daily returns\n    avg_daily_returns = daily_returns.mean()\n    # Compute the heuristic factor\n    heuristic_factor = avg_daily_returns / volume_std if volume_std > 0 else 0\n    # Create a Series for the heuristic factor, repeating it for each date in the DataFrame\n    heuristics_matrix = pd.Series([heuristic_factor]*len(df), index=df.index)\n    return heuristics_matrix",
          "objective": -0.03215,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor based on the product of the average daily returns and the reciprocal of the coefficient of variation (standard deviation divided by mean) of daily volumes, aiming to highlight stocks with high, stable returns and relatively stable trading volume.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily returns\n    daily_returns = df['close'].pct_change()\n    # Calculate the standard deviation and mean of the daily volumes\n    volume_std = df['volume'].std()\n    volume_mean = df['volume'].mean()\n    # Ensure the mean volume is not zero to avoid division by zero\n    if volume_mean == 0:\n        return pd.Series([0]*len(df), index=df.index)\n    # Coefficient of variation of volume\n    volume_cov = volume_std / volume_mean\n    # Calculate the average of daily returns\n    avg_daily_returns = daily_returns.mean()\n    # Compute the heuristic factor\n    heuristic_factor = avg_daily_returns * (1/volume_cov) if volume_cov > 0 else 0\n    # Create a Series for the heuristic factor, repeating it for each date in the DataFrame\n    heuristics_matrix = pd.Series([heuristic_factor]*len(df), index=df.index)\n    return heuristics_matrix",
          "objective": -0.03075,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor based on the ratio of the exponential moving average of daily returns to the coefficient of variation (standard deviation divided by mean) of daily volumes, aiming to emphasize recent return performance and penalize high volatility in trading volume.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily returns\n    daily_returns = df['close'].pct_change()\n    # Calculate the exponential moving average of daily returns with a span of 10 days\n    ema_daily_returns = daily_returns.ewm(span=10, adjust=False).mean()\n    # Calculate the mean and standard deviation of the daily volumes\n    volume_mean = df['volume'].mean()\n    volume_std = df['volume'].std()\n    # Calculate the coefficient of variation of daily volumes\n    volume_cv = volume_std / volume_mean if volume_mean > 0 else 0\n    # Compute the heuristic factor\n    heuristic_factor = ema_daily_returns.mean() / volume_cv if volume_cv > 0 else 0\n    # Create a Series for the heuristic factor, repeating it for each date in the DataFrame\n    heuristics_matrix = pd.Series([heuristic_factor]*len(df), index=df.index)\n    return heuristics_matrix",
          "objective": -0.03062,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor by taking the difference between the 50-day simple moving average (SMA) of the closing price and the 20-day SMA, then dividing this difference by the 200-day SMA to generate a heuristics matrix.",
          "code": "def heuristics_v2(df):\n    sma_50 = df['close'].rolling(window=50).mean()\n    sma_20 = df['close'].rolling(window=20).mean()\n    sma_200 = df['close'].rolling(window=200).mean()\n    heuristics_matrix = (sma_50 - sma_20) / sma_200\n    return heuristics_matrix",
          "objective": -0.03028,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor based on the cumulative sum of positive daily log returns divided by the total number of days, aiming to identify stocks with a consistent upward trend.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate daily log returns\n    daily_log_returns = np.log(df['close']).diff()\n    # Count the number of positive daily log returns\n    positive_returns = (daily_log_returns > 0).sum()\n    # Total number of days\n    total_days = len(df)\n    # Compute the heuristic factor\n    heuristic_factor = positive_returns / total_days if total_days > 0 else 0\n    # Create a Series for the heuristic factor, repeating it for each date in the DataFrame\n    heuristics_matrix = pd.Series([heuristic_factor]*len(df), index=df.index)\n    return heuristics_matrix",
          "objective": -0.02997,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor based on the ratio of the standard deviation of daily returns to the mean of daily volumes, aiming to identify stocks with volatile returns and consistent average trading volume.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily returns\n    daily_returns = df['close'].pct_change()\n    # Calculate the mean of the daily volumes\n    volume_mean = df['volume'].mean()\n    # Calculate the standard deviation of daily returns\n    std_daily_returns = daily_returns.std()\n    # Compute the heuristic factor\n    heuristic_factor = std_daily_returns / volume_mean if volume_mean > 0 else 0\n    # Create a Series for the heuristic factor, repeating it for each date in the DataFrame\n    heuristics_matrix = pd.Series([heuristic_factor]*len(df), index=df.index)\n    return heuristics_matrix",
          "objective": -0.02862,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor by taking the difference between the 20-day exponential moving average (EMA) of the closing price and the 50-day EMA, then dividing this difference by the 200-day simple moving average (SMA).",
          "code": "def heuristics_v2(df):\n    ema_20 = df['close'].ewm(span=20, adjust=False).mean()\n    ema_50 = df['close'].ewm(span=50, adjust=False).mean()\n    sma_200 = df['close'].rolling(window=200).mean()\n    heuristics_matrix = (ema_20 - ema_50) / sma_200\n    return heuristics_matrix",
          "objective": -0.02828,
          "other_inf": null
     }
]