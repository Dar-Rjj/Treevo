[
     {
          "algorithm": "The new algorithm calculates a factor based on the difference between the average daily high and low prices over a 30-day period, divided by the standard deviation of the daily closing prices.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the 30-day moving average of daily high and low prices\n    avg_high_low = (df['high'] + df['low']) / 2\n    moving_avg_high_low = avg_high_low.rolling(window=30).mean()\n    \n    # Calculate the standard deviation of daily closing prices\n    close_std = df['close'].std()\n    \n    # Compute the heuristic factor\n    heuristic_factor = (moving_avg_high_low - df['close'].mean()) / close_std if close_std > 0 else 0\n    \n    # Create a Series for the heuristic factor, ensuring it is indexed correctly\n    heuristics_matrix = pd.Series(heuristic_factor, index=df.index)\n    return heuristics_matrix",
          "objective": -0.13241,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor based on the ratio of the exponential moving average of daily returns with a span of 20 days to the coefficient of variation (standard deviation divided by mean) of the last 10 days' volumes, aiming to provide a smoother return performance indicator and a more recent volatility measure.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily returns\n    daily_returns = df['close'].pct_change()\n    # Calculate the exponential moving average of daily returns with a span of 20 days\n    ema_daily_returns = daily_returns.ewm(span=20, adjust=False).mean()\n    # Calculate the mean and standard deviation of the last 10 days' volumes\n    volume_mean = df['volume'][-10:].mean()\n    volume_std = df['volume'][-10:].std()\n    # Calculate the coefficient of variation of the last 10 days' volumes\n    volume_cv = volume_std / volume_mean if volume_mean > 0 else 0\n    # Compute the heuristic factor\n    heuristic_factor = ema_daily_returns.mean() / volume_cv if volume_cv > 0 else 0\n    # Create a Series for the heuristic factor, repeating it for each date in the DataFrame\n    heuristics_matrix = pd.Series([heuristic_factor]*len(df), index=df.index)\n    return heuristics_matrix",
          "objective": -0.03896,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor based on the ratio of the exponential moving average of daily returns to the sum of the coefficient of variation (standard deviation divided by mean) of daily volumes and the standard deviation of daily returns, aiming to incorporate both volume and return volatility in penalizing unstable stocks.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily returns\n    daily_returns = df['close'].pct_change()\n    # Calculate the exponential moving average of daily returns with a span of 10 days\n    ema_daily_returns = daily_returns.ewm(span=10, adjust=False).mean()\n    # Calculate the mean and standard deviation of the daily volumes\n    volume_mean = df['volume'].mean()\n    volume_std = df['volume'].std()\n    # Calculate the coefficient of variation of daily volumes\n    volume_cv = volume_std / volume_mean if volume_mean > 0 else 0\n    # Calculate the standard deviation of daily returns\n    daily_returns_std = daily_returns.std()\n    # Compute the heuristic factor\n    denominator = volume_cv + daily_returns_std\n    heuristic_factor = ema_daily_returns.mean() / denominator if denominator > 0 else 0\n    # Create a Series for the heuristic factor, repeating it for each date in the DataFrame\n    heuristics_matrix = pd.Series([heuristic_factor]*len(df), index=df.index)\n    return heuristics_matrix",
          "objective": -0.03845,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor based on the median of daily returns adjusted by the ratio of the 25th percentile volume to the 75th percentile volume, aiming to capture stocks with robust central tendency in returns and low volatility in trading volume.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily returns\n    daily_returns = df['close'].pct_change()\n    # Calculate the 25th and 75th percentiles of the daily volumes\n    volume_25th = df['volume'].quantile(0.25)\n    volume_75th = df['volume'].quantile(0.75)\n    # Ensure the 75th percentile volume is not zero to avoid division by zero\n    if volume_75th == 0:\n        return pd.Series([0]*len(df), index=df.index)\n    # Ratio of 25th to 75th percentile of volume\n    volume_ratio = volume_25th / volume_75th\n    # Calculate the median of daily returns\n    median_daily_returns = daily_returns.median()\n    # Compute the heuristic factor\n    heuristic_factor = median_daily_returns * (1 + volume_ratio) if volume_75th > 0 else 0\n    # Create a Series for the heuristic factor, repeating it for each date in the DataFrame\n    heuristics_matrix = pd.Series([heuristic_factor]*len(df), index=df.index)\n    return heuristics_matrix",
          "objective": -0.03797,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor based on the ratio of the average daily returns to the mean of daily volumes, aiming to identify stocks with stable returns and consistent average trading volume.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily returns\n    daily_returns = df['close'].pct_change()\n    # Calculate the mean of the daily volumes\n    volume_mean = df['volume'].mean()\n    # Calculate the average of daily returns\n    avg_daily_returns = daily_returns.mean()\n    # Compute the heuristic factor\n    heuristic_factor = avg_daily_returns / volume_mean if volume_mean > 0 else 0\n    # Create a Series for the heuristic factor, repeating it for each date in the DataFrame\n    heuristics_matrix = pd.Series([heuristic_factor]*len(df), index=df.index)\n    return heuristics_matrix",
          "objective": -0.03397,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a heuristic factor based on the ratio of average daily log returns to the standard deviation of daily closing prices, aiming to identify stocks with stable return patterns and lower price volatility.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate daily log returns\n    daily_log_returns = np.log(df['close']).diff()\n    # Calculate the standard deviation of daily closing prices\n    close_std = df['close'].std()\n    # Calculate the average of daily log returns\n    avg_daily_log_returns = daily_log_returns.mean()\n    # Compute the heuristic factor\n    heuristic_factor = avg_daily_log_returns / close_std if close_std > 0 else 0\n    # Create a Series for the heuristic factor, repeating it for each date in the DataFrame\n    heuristics_matrix = pd.Series([heuristic_factor]*len(df), index=df.index)\n    return heuristics_matrix",
          "objective": -0.03276,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by multiplying the weighted average of daily returns, where weights are given based on the trading volume, and the square of the reciprocal of the coefficient of variation (standard deviation divided by mean) of daily volumes, to highlight stocks with high, volume-weighted returns and extremely stable trading patterns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily returns\n    daily_returns = df['close'].pct_change()\n    # Calculate the standard deviation and mean of the daily volumes\n    volume_std = df['volume'].std()\n    volume_mean = df['volume'].mean()\n    # Ensure the mean volume is not zero to avoid division by zero\n    if volume_mean == 0:\n        return pd.Series([0]*len(df), index=df.index)\n    # Coefficient of variation of volume\n    volume_cov = volume_std / volume_mean\n    # Calculate the weighted average of daily returns\n    weighted_avg_daily_returns = (daily_returns * df['volume']).sum() / df['volume'].sum()\n    # Compute the heuristic factor\n    heuristic_factor = weighted_avg_daily_returns * (1/volume_cov)**2 if volume_cov > 0 else 0\n    # Create a Series for the heuristic factor, repeating it for each date in the DataFrame\n    heuristics_matrix = pd.Series([heuristic_factor]*len(df), index=df.index)\n    return heuristics_matrix",
          "objective": -0.03261,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor based on the ratio of the simple moving average of daily returns to the entropy of daily volume changes, aiming to emphasize medium-term return stability and penalize unpredictable trading volume.",
          "code": "import pandas as pd\nfrom scipy.stats import entropy\n\ndef heuristics_v2(df):\n    # Calculate daily returns\n    daily_returns = df['close'].pct_change()\n    # Calculate the simple moving average of daily returns with a window of 10 days\n    sma_daily_returns = daily_returns.rolling(window=10).mean()\n    # Calculate the daily volume changes\n    volume_changes = df['volume'].diff().fillna(0)\n    # Compute the entropy of daily volume changes\n    volume_entropy = entropy(volume_changes.abs())\n    # Compute the heuristic factor\n    heuristic_factor = sma_daily_returns.mean() / (1 + volume_entropy) if volume_entropy > 0 else 0\n    # Create a Series for the heuristic factor, repeating it for each date in the DataFrame\n    heuristics_matrix = pd.Series([heuristic_factor]*len(df), index=df.index)\n    return heuristics_matrix",
          "objective": -0.03251,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a heuristic factor based on the ratio of average daily returns to the standard deviation of daily volumes, aiming to identify stocks with stable returns and consistent trading activity.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily returns\n    daily_returns = df['close'].pct_change()\n    # Calculate the standard deviation of the daily volumes\n    volume_std = df['volume'].std()\n    # Calculate the average of daily returns\n    avg_daily_returns = daily_returns.mean()\n    # Compute the heuristic factor\n    heuristic_factor = avg_daily_returns / volume_std if volume_std > 0 else 0\n    # Create a Series for the heuristic factor, repeating it for each date in the DataFrame\n    heuristics_matrix = pd.Series([heuristic_factor]*len(df), index=df.index)\n    return heuristics_matrix",
          "objective": -0.03215,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor based on the ratio of the sum of positive daily returns to the total number of trading days, aiming to identify stocks with a higher frequency of profitable days.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily returns\n    daily_returns = df['close'].pct_change()\n    # Count the number of positive daily returns\n    positive_days = (daily_returns > 0).sum()\n    # Calculate the total number of trading days\n    total_days = len(daily_returns)\n    # Compute the heuristic factor\n    heuristic_factor = positive_days / total_days if total_days > 0 else 0\n    # Create a Series for the heuristic factor, repeating it for each date in the DataFrame\n    heuristics_matrix = pd.Series([heuristic_factor]*len(df), index=df.index)\n    return heuristics_matrix",
          "objective": -0.03146,
          "other_inf": null
     }
]