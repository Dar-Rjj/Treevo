[
     {
          "algorithm": "The new algorithm calculates a factor based on the difference between the average daily high and low prices over a 30-day period, divided by the standard deviation of the daily closing prices.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the 30-day moving average of daily high and low prices\n    avg_high_low = (df['high'] + df['low']) / 2\n    moving_avg_high_low = avg_high_low.rolling(window=30).mean()\n    \n    # Calculate the standard deviation of daily closing prices\n    close_std = df['close'].std()\n    \n    # Compute the heuristic factor\n    heuristic_factor = (moving_avg_high_low - df['close'].mean()) / close_std if close_std > 0 else 0\n    \n    # Create a Series for the heuristic factor, ensuring it is indexed correctly\n    heuristics_matrix = pd.Series(heuristic_factor, index=df.index)\n    return heuristics_matrix",
          "objective": -0.13241,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a modified heuristic factor based on the ratio of the weighted moving average of daily returns, using volume as weights, to the standard deviation of the last 30 days' closing prices, aiming to provide a different perspective on volatility.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily returns\n    daily_returns = df['close'].pct_change()\n    # Compute the weighted moving average of daily returns with a window of 10 days, using volume as weight\n    wma_daily_returns = (daily_returns * df['volume']).rolling(window=10).sum() / df['volume'].rolling(window=10).sum()\n    # Calculate the standard deviation of the last 30 days' close prices as a measure of price volatility\n    std_close = df['close'].rolling(window=30).std()\n    # Compute the mean of the standard deviations\n    mean_std = std_close.mean()\n    # Compute the heuristic factor\n    heuristic_factor = wma_daily_returns.mean() / mean_std if mean_std > 0 else 0\n    # Create a Series for the heuristic factor, repeating it for each date in the DataFrame\n    heuristics_matrix = pd.Series([heuristic_factor]*len(df), index=df.index)\n    return heuristics_matrix",
          "objective": -0.04072,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor based on the ratio of the exponential moving average of daily returns with a span of 20 days to the coefficient of variation (standard deviation divided by mean) of the last 10 days' volumes, aiming to provide a smoother return performance indicator and a more recent volatility measure.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily returns\n    daily_returns = df['close'].pct_change()\n    # Calculate the exponential moving average of daily returns with a span of 20 days\n    ema_daily_returns = daily_returns.ewm(span=20, adjust=False).mean()\n    # Calculate the mean and standard deviation of the last 10 days' volumes\n    volume_mean = df['volume'][-10:].mean()\n    volume_std = df['volume'][-10:].std()\n    # Calculate the coefficient of variation of the last 10 days' volumes\n    volume_cv = volume_std / volume_mean if volume_mean > 0 else 0\n    # Compute the heuristic factor\n    heuristic_factor = ema_daily_returns.mean() / volume_cv if volume_cv > 0 else 0\n    # Create a Series for the heuristic factor, repeating it for each date in the DataFrame\n    heuristics_matrix = pd.Series([heuristic_factor]*len(df), index=df.index)\n    return heuristics_matrix",
          "objective": -0.03896,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor based on the ratio of the weighted moving average of daily returns, using volume as weights, to the difference between the 25th and 75th percentiles of daily close prices, aiming to incorporate both trading volume influence and price volatility in assessing stock stability.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily returns\n    daily_returns = df['close'].pct_change()\n    # Compute the weighted moving average of daily returns with a window of 10 days, using volume as weight\n    wma_daily_returns = (daily_returns * df['volume']).rolling(window=10).sum() / df['volume'].rolling(window=10).sum()\n    # Calculate the 25th and 75th percentiles of the daily close prices\n    q25_close = df['close'].quantile(0.25)\n    q75_close = df['close'].quantile(0.75)\n    # Compute the interquartile range of daily close prices as a measure of price volatility\n    iqr_close = q75_close - q25_close\n    # Compute the heuristic factor\n    heuristic_factor = wma_daily_returns.mean() / iqr_close if iqr_close > 0 else 0\n    # Create a Series for the heuristic factor, repeating it for each date in the DataFrame\n    heuristics_matrix = pd.Series([heuristic_factor]*len(df), index=df.index)\n    return heuristics_matrix",
          "objective": -0.03847,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor based on the ratio of the exponential moving average of daily returns to the sum of the coefficient of variation (standard deviation divided by mean) of daily volumes and the standard deviation of daily returns, aiming to incorporate both volume and return volatility in penalizing unstable stocks.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily returns\n    daily_returns = df['close'].pct_change()\n    # Calculate the exponential moving average of daily returns with a span of 10 days\n    ema_daily_returns = daily_returns.ewm(span=10, adjust=False).mean()\n    # Calculate the mean and standard deviation of the daily volumes\n    volume_mean = df['volume'].mean()\n    volume_std = df['volume'].std()\n    # Calculate the coefficient of variation of daily volumes\n    volume_cv = volume_std / volume_mean if volume_mean > 0 else 0\n    # Calculate the standard deviation of daily returns\n    daily_returns_std = daily_returns.std()\n    # Compute the heuristic factor\n    denominator = volume_cv + daily_returns_std\n    heuristic_factor = ema_daily_returns.mean() / denominator if denominator > 0 else 0\n    # Create a Series for the heuristic factor, repeating it for each date in the DataFrame\n    heuristics_matrix = pd.Series([heuristic_factor]*len(df), index=df.index)\n    return heuristics_matrix",
          "objective": -0.03845,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor based on the median of daily returns adjusted by the ratio of the 25th percentile volume to the 75th percentile volume, aiming to capture stocks with robust central tendency in returns and low volatility in trading volume.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily returns\n    daily_returns = df['close'].pct_change()\n    # Calculate the 25th and 75th percentiles of the daily volumes\n    volume_25th = df['volume'].quantile(0.25)\n    volume_75th = df['volume'].quantile(0.75)\n    # Ensure the 75th percentile volume is not zero to avoid division by zero\n    if volume_75th == 0:\n        return pd.Series([0]*len(df), index=df.index)\n    # Ratio of 25th to 75th percentile of volume\n    volume_ratio = volume_25th / volume_75th\n    # Calculate the median of daily returns\n    median_daily_returns = daily_returns.median()\n    # Compute the heuristic factor\n    heuristic_factor = median_daily_returns * (1 + volume_ratio) if volume_75th > 0 else 0\n    # Create a Series for the heuristic factor, repeating it for each date in the DataFrame\n    heuristics_matrix = pd.Series([heuristic_factor]*len(df), index=df.index)\n    return heuristics_matrix",
          "objective": -0.03797,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor based on the product of the weighted moving average of daily returns over 30 days and the inverse of the sum of the coefficient of variation (standard deviation divided by mean) of the last 15 days' volumes and the coefficient of variation of daily returns, aiming to combine both return momentum and volatility measures in a novel way.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily returns\n    daily_returns = df['close'].pct_change()\n    # Calculate the weighted moving average of daily returns with a span of 30 days\n    wma_daily_returns = daily_returns.rolling(window=30).apply(lambda x: (x * pd.Series(range(1, len(x)+1))).sum() / pd.Series(range(1, len(x)+1)).sum(), raw=True)\n    # Calculate the mean and standard deviation of the last 15 days' volumes\n    volume_mean = df['volume'][-15:].mean()\n    volume_std = df['volume'][-15:].std()\n    # Calculate the coefficient of variation of the last 15 days' volumes\n    volume_cv = volume_std / volume_mean if volume_mean > 0 else 0\n    # Calculate the coefficient of variation of daily returns\n    daily_returns_cv = daily_returns.std() / daily_returns.mean() if daily_returns.mean() != 0 else 0\n    # Compute the heuristic factor\n    denominator = volume_cv + daily_returns_cv\n    heuristic_factor = wma_daily_returns.mean() * (1 / denominator) if denominator > 0 else 0\n    # Create a Series for the heuristic factor, repeating it for each date in the DataFrame\n    heuristics_matrix = pd.Series([heuristic_factor]*len(df), index=df.index)\n    return heuristics_matrix",
          "objective": -0.03469,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor based on the ratio of the average daily returns to the mean of daily volumes, aiming to identify stocks with stable returns and consistent average trading volume.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily returns\n    daily_returns = df['close'].pct_change()\n    # Calculate the mean of the daily volumes\n    volume_mean = df['volume'].mean()\n    # Calculate the average of daily returns\n    avg_daily_returns = daily_returns.mean()\n    # Compute the heuristic factor\n    heuristic_factor = avg_daily_returns / volume_mean if volume_mean > 0 else 0\n    # Create a Series for the heuristic factor, repeating it for each date in the DataFrame\n    heuristics_matrix = pd.Series([heuristic_factor]*len(df), index=df.index)\n    return heuristics_matrix",
          "objective": -0.03397,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a heuristic factor based on the ratio of average daily log returns to the standard deviation of daily closing prices, aiming to identify stocks with stable return patterns and lower price volatility.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate daily log returns\n    daily_log_returns = np.log(df['close']).diff()\n    # Calculate the standard deviation of daily closing prices\n    close_std = df['close'].std()\n    # Calculate the average of daily log returns\n    avg_daily_log_returns = daily_log_returns.mean()\n    # Compute the heuristic factor\n    heuristic_factor = avg_daily_log_returns / close_std if close_std > 0 else 0\n    # Create a Series for the heuristic factor, repeating it for each date in the DataFrame\n    heuristics_matrix = pd.Series([heuristic_factor]*len(df), index=df.index)\n    return heuristics_matrix",
          "objective": -0.03276,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by multiplying the weighted average of daily returns, where weights are given based on the trading volume, and the square of the reciprocal of the coefficient of variation (standard deviation divided by mean) of daily volumes, to highlight stocks with high, volume-weighted returns and extremely stable trading patterns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily returns\n    daily_returns = df['close'].pct_change()\n    # Calculate the standard deviation and mean of the daily volumes\n    volume_std = df['volume'].std()\n    volume_mean = df['volume'].mean()\n    # Ensure the mean volume is not zero to avoid division by zero\n    if volume_mean == 0:\n        return pd.Series([0]*len(df), index=df.index)\n    # Coefficient of variation of volume\n    volume_cov = volume_std / volume_mean\n    # Calculate the weighted average of daily returns\n    weighted_avg_daily_returns = (daily_returns * df['volume']).sum() / df['volume'].sum()\n    # Compute the heuristic factor\n    heuristic_factor = weighted_avg_daily_returns * (1/volume_cov)**2 if volume_cov > 0 else 0\n    # Create a Series for the heuristic factor, repeating it for each date in the DataFrame\n    heuristics_matrix = pd.Series([heuristic_factor]*len(df), index=df.index)\n    return heuristics_matrix",
          "objective": -0.03261,
          "other_inf": null
     }
]