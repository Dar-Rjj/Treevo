[
     {
          "algorithm": "The new algorithm calculates a heuristic factor based on the ratio of the average daily returns to the mean of daily volumes, aiming to identify stocks with stable returns and consistent average trading volume.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily returns\n    daily_returns = df['close'].pct_change()\n    # Calculate the mean of the daily volumes\n    volume_mean = df['volume'].mean()\n    # Calculate the average of daily returns\n    avg_daily_returns = daily_returns.mean()\n    # Compute the heuristic factor\n    heuristic_factor = avg_daily_returns / volume_mean if volume_mean > 0 else 0\n    # Create a Series for the heuristic factor, repeating it for each date in the DataFrame\n    heuristics_matrix = pd.Series([heuristic_factor]*len(df), index=df.index)\n    return heuristics_matrix",
          "objective": -0.03397,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a heuristic factor based on the ratio of average daily log returns to the standard deviation of daily closing prices, aiming to identify stocks with stable return patterns and lower price volatility.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate daily log returns\n    daily_log_returns = np.log(df['close']).diff()\n    # Calculate the standard deviation of daily closing prices\n    close_std = df['close'].std()\n    # Calculate the average of daily log returns\n    avg_daily_log_returns = daily_log_returns.mean()\n    # Compute the heuristic factor\n    heuristic_factor = avg_daily_log_returns / close_std if close_std > 0 else 0\n    # Create a Series for the heuristic factor, repeating it for each date in the DataFrame\n    heuristics_matrix = pd.Series([heuristic_factor]*len(df), index=df.index)\n    return heuristics_matrix",
          "objective": -0.03276,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a heuristic factor based on the ratio of average daily returns to the standard deviation of daily volumes, aiming to identify stocks with stable returns and consistent trading activity.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily returns\n    daily_returns = df['close'].pct_change()\n    # Calculate the standard deviation of the daily volumes\n    volume_std = df['volume'].std()\n    # Calculate the average of daily returns\n    avg_daily_returns = daily_returns.mean()\n    # Compute the heuristic factor\n    heuristic_factor = avg_daily_returns / volume_std if volume_std > 0 else 0\n    # Create a Series for the heuristic factor, repeating it for each date in the DataFrame\n    heuristics_matrix = pd.Series([heuristic_factor]*len(df), index=df.index)\n    return heuristics_matrix",
          "objective": -0.03215,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor based on the product of the average daily returns and the reciprocal of the coefficient of variation (standard deviation divided by mean) of daily volumes, aiming to highlight stocks with high, stable returns and relatively stable trading volume.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily returns\n    daily_returns = df['close'].pct_change()\n    # Calculate the standard deviation and mean of the daily volumes\n    volume_std = df['volume'].std()\n    volume_mean = df['volume'].mean()\n    # Ensure the mean volume is not zero to avoid division by zero\n    if volume_mean == 0:\n        return pd.Series([0]*len(df), index=df.index)\n    # Coefficient of variation of volume\n    volume_cov = volume_std / volume_mean\n    # Calculate the average of daily returns\n    avg_daily_returns = daily_returns.mean()\n    # Compute the heuristic factor\n    heuristic_factor = avg_daily_returns * (1/volume_cov) if volume_cov > 0 else 0\n    # Create a Series for the heuristic factor, repeating it for each date in the DataFrame\n    heuristics_matrix = pd.Series([heuristic_factor]*len(df), index=df.index)\n    return heuristics_matrix",
          "objective": -0.03075,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor by taking the difference between the 50-day simple moving average (SMA) of the closing price and the 20-day SMA, then dividing this difference by the 200-day SMA to generate a heuristics matrix.",
          "code": "def heuristics_v2(df):\n    sma_50 = df['close'].rolling(window=50).mean()\n    sma_20 = df['close'].rolling(window=20).mean()\n    sma_200 = df['close'].rolling(window=200).mean()\n    heuristics_matrix = (sma_50 - sma_20) / sma_200\n    return heuristics_matrix",
          "objective": -0.03028,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor based on the ratio of the standard deviation of daily returns to the mean of daily volumes, aiming to identify stocks with volatile returns and consistent average trading volume.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily returns\n    daily_returns = df['close'].pct_change()\n    # Calculate the mean of the daily volumes\n    volume_mean = df['volume'].mean()\n    # Calculate the standard deviation of daily returns\n    std_daily_returns = daily_returns.std()\n    # Compute the heuristic factor\n    heuristic_factor = std_daily_returns / volume_mean if volume_mean > 0 else 0\n    # Create a Series for the heuristic factor, repeating it for each date in the DataFrame\n    heuristics_matrix = pd.Series([heuristic_factor]*len(df), index=df.index)\n    return heuristics_matrix",
          "objective": -0.02862,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor by taking the difference between the 20-day exponential moving average (EMA) of the closing price and the 50-day EMA, then dividing this difference by the 200-day simple moving average (SMA).",
          "code": "def heuristics_v2(df):\n    ema_20 = df['close'].ewm(span=20, adjust=False).mean()\n    ema_50 = df['close'].ewm(span=50, adjust=False).mean()\n    sma_200 = df['close'].rolling(window=200).mean()\n    heuristics_matrix = (ema_20 - ema_50) / sma_200\n    return heuristics_matrix",
          "objective": -0.02828,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor by taking the difference between the 70-day simple moving average (SMA) of the closing price and the 30-day SMA, then dividing this difference by the 150-day SMA to generate a heuristics matrix.",
          "code": "def heuristics_v2(df):\n    sma_70 = df['close'].rolling(window=70).mean()\n    sma_30 = df['close'].rolling(window=30).mean()\n    sma_150 = df['close'].rolling(window=150).mean()\n    heuristics_matrix = (sma_70 - sma_30) / sma_150\n    return heuristics_matrix",
          "objective": -0.02771,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a novel heuristic factor by integrating the rate of change (ROC) of the closing prices with the average directional index (ADX) to signal both trend strength and price momentum, thereby predicting future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate ROC\n    roc = df['close'].pct_change(periods=10)\n    \n    # Calculate True Range\n    tr1 = df['high'] - df['low']\n    tr2 = abs(df['high'] - df['close'].shift(1))\n    tr3 = abs(df['low'] - df['close'].shift(1))\n    true_range = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)\n    \n    # Calculate +DM and -DM\n    dm_pos = (df['high'].diff(1).fillna(0)).where((df['high'] - df['high'].shift(1)) > (df['low'].shift(1) - df['low']), 0)\n    dm_neg = (df['low'].shift(1) - df['low']).where((df['low'].shift(1) - df['low']) > (df['high'] - df['high'].shift(1)), 0)\n    \n    # Smooth +DM and -DM\n    smooth_dm_pos = dm_pos.rolling(window=14).sum()\n    smooth_dm_neg = dm_neg.rolling(window=14).sum()\n    smooth_true_range = true_range.rolling(window=14).sum()\n    \n    # Calculate +DI and -DI\n    di_pos = (smooth_dm_pos / smooth_true_range) * 100\n    di_neg = (smooth_dm_neg / smooth_true_range) * 100\n    \n    # Calculate ADX\n    dx = (abs(di_pos - di_neg) / (di_pos + di_neg)) * 100\n    adx = dx.rolling(window=14).mean()\n    \n    # Composite heuristic\n    heuristics_matrix = roc + adx\n    \n    return heuristics_matrix",
          "objective": -0.02769,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor by taking the difference between the 30-day exponential moving average (EMA) of the closing price and the 70-day EMA, then dividing this difference by the 150-day simple moving average (SMA).",
          "code": "def heuristics_v2(df):\n    ema_30 = df['close'].ewm(span=30, adjust=False).mean()\n    ema_70 = df['close'].ewm(span=70, adjust=False).mean()\n    sma_150 = df['close'].rolling(window=150).mean()\n    heuristics_matrix = (ema_30 - ema_70) / sma_150\n    return heuristics_matrix",
          "objective": -0.02533,
          "other_inf": null
     }
]