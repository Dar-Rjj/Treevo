```python
def heuristics_v2(df: pd.DataFrame) -> pd.Series:
    # Calculate the short-term (5-day) momentum factor
    momentum_5d = df['close'] - df['close'].rolling(window=5).mean()

    # Calculate the 14-day Relative Strength Index (RSI)
    delta = df['close'].diff()
    gain = (delta.where(delta > 0, 0)).ewm(alpha=1/14, adjust=False).mean()
    loss = (-delta.where(delta < 0, 0)).ewm(alpha=1/14, adjust=False).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))

    # Calculate the difference between the close price and the average of high and low prices
    avg_high_low = (df['high'] + df['low']) / 2
    diff_close_avg = df['close'] - avg_high_low

    # Calculate the price change and volume change
    price_change = df['close'] - df['open']
    volume_change = df['volume'].pct_change()

    # Calculate the 5-day volatility
    volatility_5d = df['close'].rolling(window=5).std()

    # Adaptive weighting based on recent performance
    weight_price_change = abs(price_change.rolling(window=5).mean()) / abs(price_change.rolling(window=5).std())
    weight_volume_change = abs(volume_change.rolling(window=5).mean()) / abs(volume_change.rolling(window=5).std())
    weight_momentum = abs(momentum_5d.rolling(window=5).mean()) / abs(momentum_5d.rolling(window=5).std())
    weight_rsi = abs(rsi.rolling(window=5).mean()) / abs(rsi.rolling(window=5).std())
    weight_volatility = abs(volatility_5d.rolling(window=5).mean()) / abs(volatility_5d.rolling(window=5).std())

    # Combine the factors with adaptive weights to create a robust alpha factor
    factor = (price_change * weight_price_change + 
              volume_change * weight_volume_change + 
              diff_close_avg + 
              momentum_5d * weight_momentum + 
              rsi * weight_rsi + 
              volatility_5d * weight_volatility)

    # Apply exponential smoothing to the combined factor
    smoothed_factor = factor.ewm(span=5, adjust=False).mean()

    # Consider interaction effects by multiplying the smoothed factor with its lagged value
    lagged_factor = smoothed_factor.shift(1)
    interaction_effect = smoothed_factor * lagged_factor

    # Incorporate additional lags for richer signals
    lagged_interaction_effect = interaction_effect.shift(1)
    final_factor = (smoothed_factor + interaction_effect + lagged_interaction_effect).ewm(span=5, adjust=False).mean()

    return final_factor
```
