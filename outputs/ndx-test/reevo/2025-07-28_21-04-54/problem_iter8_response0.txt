```python
def heuristics_v2(df: pd.DataFrame) -> pd.Series:
    # Calculate the daily return based on close prices
    daily_return = df['close'].pct_change()
    
    # Adaptive volatility: 10-day exponentially weighted moving standard deviation
    adaptive_volatility = daily_return.ewm(span=10, adjust=False).std()
    
    # Calculate the 30-day cumulative return as a momentum factor
    momentum = (df['close'] / df['close'].shift(30)) - 1
    
    # Advanced sentiment analysis: incorporate the ratio of close to open price and the high-low range
    market_sentiment = (df['close'] / df['open']) * ((df['high'] - df['low']) / (df['close'] + 1e-7))
    
    # Volume dynamics: 10-day exponentially weighted moving average of volume
    volume_dynamics = df['volume'].ewm(span=10, adjust=False).mean()
    
    # Percentage change in volume, indicating changes in liquidity or interest
    vol_change = df['volume'].pct_change().fillna(0)
    
    # Inter-day price patterns: calculate the weighted difference of high and low prices
    weighted_price_diff = (1.5 * df['high'] - 0.5 * df['low']) / (df['close'] + 1e-7)
    
    # Mean reversion component using the deviation from the 10-day moving average
    moving_avg = df['close'].rolling(window=10).mean()
    mean_reversion = (df['close'] - moving_avg) / (df['high'] - df['low'] + 1e-7)
    
    # Combine the factors
    # Higher market sentiment, volume dynamics, and weighted price difference increase the score
    # Higher adaptive volatility and mean reversion reduce the score, indicating higher risk
    factor = (
        momentum + 
        (market_sentiment - 1) + 
        (volume_dynamics / df['volume'].mean()) + 
        2 * vol_change * weighted_price_diff - 
        (adaptive_volatility / adaptive_volatility.mean()) - 
        mean_reversion
    )
    
    # Add an additional smoothing to further stabilize the signal
    factor = factor.ewm(span=5, adjust=False).mean()
    
    return factor
```
