```python
def heuristics_v2(df: pd.DataFrame) -> pd.Series:
    # Calculate the daily return based on close prices
    daily_return = df['close'].pct_change()
    
    # Calculate the 10-day exponential moving average of daily returns for stability
    smoothed_daily_return = daily_return.ewm(span=10, adjust=False).mean()
    
    # Calculate the 30-day cumulative return as a momentum factor
    momentum = (df['close'] / df['close'].shift(30)) - 1
    
    # Calculate the 10-day standard deviation of smoothed daily returns as volatility
    volatility = smoothed_daily_return.rolling(window=10).std()
    
    # Incorporate market sentiment using the ratio of close to open price
    market_sentiment = df['close'] / df['open']
    
    # Calculate volume dynamics as the 10-day exponentially weighted moving average of volume
    volume_dynamics = df['volume'].ewm(span=10, adjust=False).mean()
    
    # Calculate the percentage change in volume, indicating changes in liquidity or interest
    vol_change = df['volume'].pct_change().fillna(0)
    
    # Calculate a weighted difference of high and low prices, giving more importance to the high price,
    # this could indicate the strength of positive price movement
    weighted_price_diff = (1.5 * df['high'] - 0.5 * df['low']) / (df['close'] + 1e-7)
    
    # Calculate the mean reversion component using the deviation from the moving average
    moving_avg = df['close'].rolling(window=10).mean()
    mean_reversion = (df['close'] - moving_avg) / (df['high'] - df['low'] + 1e-7)
    
    # Combine the momentum, market sentiment, and volatility
    # Higher market sentiment, volume dynamics, and weighted price difference increase the score
    # Higher volatility and mean reversion reduce the score, indicating higher risk
    factor = (
        momentum + 
        (market_sentiment - 1) + 
        (volume_dynamics / df['volume'].mean()) + 
        2 * vol_change * weighted_price_diff - 
        (volatility / volatility.mean()) - 
        mean_reversion
    )
    
    # Add an additional smoothing to further stabilize the signal
    factor = factor.ewm(span=5, adjust=False).mean()
    
    return factor
```
