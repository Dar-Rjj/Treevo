[
     {
          "algorithm": "The new algorithm calculates a modified trend factor by incorporating exponential moving averages of different lengths and then adjusts this factor based on the average true range to reflect market volatility, finally outputting this as the heuristics matrix.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    short_window = 5\n    long_window = 20\n    very_long_window = 60\n    \n    short_ema = df['close'].ewm(span=short_window, adjust=False).mean()\n    long_ema = df['close'].ewm(span=long_window, adjust=False).mean()\n    very_long_ema = df['close'].ewm(span=very_long_window, adjust=False).mean()\n\n    # Custom weight for emphasizing recent price movements\n    trend_factor = (2 * short_ema - long_ema) / 2\n    \n    # Calculate average true range over the long window as a measure of volatility\n    tr1 = df['high'] - df['low']\n    tr2 = np.abs(df['high'] - df['close'].shift())\n    tr3 = np.abs(df['low'] - df['close'].shift())\n    true_range = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)\n    atr = true_range.rolling(window=long_window).mean()\n\n    heuristics_matrix = trend_factor / atr\n    return heuristics_matrix",
          "objective": -0.03794,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm generates alpha factors by integrating the rate of change in price with the relative strength index to capture both momentum and overbought/oversold conditions.",
          "code": "def heuristics_v2(df):\n    # Calculate the 14-day Relative Strength Index (RSI)\n    delta = df['close'].diff()\n    gain = delta.where(delta > 0, 0)\n    loss = -delta.where(delta < 0, 0)\n    avg_gain = gain.rolling(window=14).mean()\n    avg_loss = loss.rolling(window=14).mean()\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate the 10-day Rate of Change (ROC)\n    roc = df['close'].pct_change(periods=10) * 100\n    \n    # Combine RSI and ROC to form the heuristic factor\n    heuristics_matrix = (rsi - 50) + roc\n    \n    return heuristics_matrix",
          "objective": -0.02182,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm generates alpha factors by combining moving averages of different lengths and applying a custom weighting scheme to emphasize recent price movements, followed by calculating the ratio between this weighted trend and the historical volatility.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    short_window = 5\n    long_window = 20\n    very_long_window = 60\n    \n    short_mavg = df['close'].rolling(window=short_window).mean()\n    long_mavg = df['close'].rolling(window=long_window).mean()\n    very_long_mavg = df['close'].rolling(window=very_long_window).mean()\n\n    # Custom weight for emphasizing recent price movements\n    trend_factor = (2 * short_mavg - long_mavg) / 2\n    volatility = df['close'].rolling(window=long_window).std()\n\n    heuristics_matrix = trend_factor / volatility\n    return heuristics_matrix",
          "objective": -0.02136,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor by combining the exponential moving average of the closing prices with the accumulation/distribution line, aiming to capture both trend and money flow.",
          "code": "def heuristics_v2(df):\n    # Calculate 5-day and 20-day exponential moving averages for close prices\n    ema_5 = df['close'].ewm(span=5, adjust=False).mean()\n    ema_20 = df['close'].ewm(span=20, adjust=False).mean()\n    \n    # Compute the Accumulation/Distribution Line\n    adl = (df['close'] - df['low']) - (df['high'] - df['close'])\n    adl = adl * df['volume'] / (df['high'] - df['low'])\n    adl = adl.cumsum()\n    \n    # Combine the EMA convergence and ADL\n    heuristics_matrix = (ema_5 - ema_20) + adl\n    \n    return heuristics_matrix",
          "objective": -0.02038,
          "other_inf": null
     }
]