[
     {
          "algorithm": "The new algorithm calculates a modified trend factor by incorporating exponential moving averages of different lengths and then adjusts this factor based on the average true range to reflect market volatility, finally outputting this as the heuristics matrix.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    short_window = 5\n    long_window = 20\n    very_long_window = 60\n    \n    short_ema = df['close'].ewm(span=short_window, adjust=False).mean()\n    long_ema = df['close'].ewm(span=long_window, adjust=False).mean()\n    very_long_ema = df['close'].ewm(span=very_long_window, adjust=False).mean()\n\n    # Custom weight for emphasizing recent price movements\n    trend_factor = (2 * short_ema - long_ema) / 2\n    \n    # Calculate average true range over the long window as a measure of volatility\n    tr1 = df['high'] - df['low']\n    tr2 = np.abs(df['high'] - df['close'].shift())\n    tr3 = np.abs(df['low'] - df['close'].shift())\n    true_range = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)\n    atr = true_range.rolling(window=long_window).mean()\n\n    heuristics_matrix = trend_factor / atr\n    return heuristics_matrix",
          "objective": -0.03794,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm combines exponential moving averages of different periods, applies a dynamic weighting based on the ratio of short-term to long-term volatility, and then calculates the ratio between this weighted trend and the historical average true range.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    short_window = 5\n    long_window = 20\n    very_long_window = 60\n    \n    # Calculate exponential moving averages\n    short_ema = df['close'].ewm(span=short_window, adjust=False).mean()\n    long_ema = df['close'].ewm(span=long_window, adjust=False).mean()\n    very_long_ema = df['close'].ewm(span=very_long_window, adjust=False).mean()\n\n    # Calculate short-term and long-term volatility\n    short_volatility = df['close'].rolling(window=short_window).std()\n    long_volatility = df['close'].rolling(window=long_window).std()\n\n    # Dynamic weighting based on the ratio of short-term to long-term volatility\n    weight_factor = short_volatility / long_volatility\n    trend_factor = (weight_factor * short_ema + (1 - weight_factor) * long_ema) / 2\n\n    # Calculate the historical average true range\n    tr = df['high'] - df['low']\n    atr = tr.rolling(window=long_window).mean()\n\n    heuristics_matrix = trend_factor / atr\n    return heuristics_matrix",
          "objective": -0.02818,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm combines a measure of momentum with the historical volatility, using a weighted sum of price changes and their standard deviations over different time horizons, to generate a factor that reflects both the directional movement and the risk of reversal.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    short_window = 5\n    long_window = 20\n    very_long_window = 60\n    \n    # Calculate the percentage change in closing prices\n    short_change = df['close'].pct_change(periods=short_window).fillna(0)\n    long_change = df['close'].pct_change(periods=long_window).fillna(0)\n    \n    # Calculate the standard deviation of the percentage changes as a measure of volatility\n    short_volatility = df['close'].pct_change().rolling(window=short_window).std().fillna(0)\n    long_volatility = df['close'].pct_change().rolling(window=long_window).std().fillna(0)\n\n    # Dynamic weighting based on the ratio of short-term to long-term volatility\n    weight_factor = short_volatility / (short_volatility + long_volatility)\n    momentum_factor = (weight_factor * short_change + (1 - weight_factor) * long_change)\n\n    # Combine momentum and volatility into a single factor\n    heuristics_matrix = momentum_factor / (short_volatility + long_volatility)\n    return heuristics_matrix",
          "objective": -0.02355,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm leverages the concept of trend and volatility but uses a combination of momentum and relative strength indicators to create a novel factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    short_window = 5\n    long_window = 20\n    very_long_window = 60\n    \n    # Calculate simple moving averages\n    short_sma = df['close'].rolling(window=short_window).mean()\n    long_sma = df['close'].rolling(window=long_window).mean()\n    very_long_sma = df['close'].rolling(window=very_long_window).mean()\n\n    # Calculate the relative strength index (RSI)\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n\n    # Calculate the average true range\n    tr1 = df['high'] - df['low']\n    tr2 = (df['high'] - df['close'].shift()).abs()\n    tr3 = (df['low'] - df['close'].shift()).abs()\n    true_range = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)\n    atr = true_range.rolling(window=long_window).mean()\n\n    # Combine the RSI and the ratio of short to long SMA\n    trend_factor = (short_sma / long_sma) * rsi\n\n    heuristics_matrix = trend_factor / atr\n    return heuristics_matrix",
          "objective": -0.02285,
          "other_inf": null
     }
]