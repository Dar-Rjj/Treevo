[
     {
          "algorithm": "The algorithm generates alpha factors by combining moving averages of different lengths and applying a custom weighting scheme to emphasize recent price movements, followed by calculating the ratio between this weighted trend and the historical volatility.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    short_window = 5\n    long_window = 20\n    very_long_window = 60\n    \n    short_mavg = df['close'].rolling(window=short_window).mean()\n    long_mavg = df['close'].rolling(window=long_window).mean()\n    very_long_mavg = df['close'].rolling(window=very_long_window).mean()\n\n    # Custom weight for emphasizing recent price movements\n    trend_factor = (2 * short_mavg - long_mavg) / 2\n    volatility = df['close'].rolling(window=long_window).std()\n\n    heuristics_matrix = trend_factor / volatility\n    return heuristics_matrix",
          "objective": -0.02136,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a composite factor by combining the moving average of the ratio of close to open prices with the difference between high and low prices over a specified window, aiming to capture momentum and volatility simultaneously.",
          "code": "def heuristics_v2(df):\n    # Calculate the moving average of the ratio of close to open prices\n    close_open_ratio = df['close'] / df['open']\n    ma_ratio = close_open_ratio.rolling(window=5).mean()\n    \n    # Calculate the difference between high and low prices\n    high_low_diff = df['high'] - df['low']\n    \n    # Composite factor: sum of moving average of the ratio and high-low difference\n    heuristics_matrix = ma_ratio + high_low_diff\n    \n    return heuristics_matrix",
          "objective": -0.01955,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes the difference between the average of the highest and lowest prices over a 10-day window, aiming to capture momentum and volatility characteristics that could serve as predictive signals for future stock returns.",
          "code": "def heuristics_v2(df):\n    high_avg = df['high'].rolling(window=10).mean()\n    low_avg = df['low'].rolling(window=10).mean()\n    heuristics_matrix = high_avg - low_avg\n    return heuristics_matrix",
          "objective": -0.01282,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm, named HeuristicV2, combines momentum, volatility, and trading volume patterns by calculating the difference between 5-day and 20-day moving averages for closing prices, dividing it by the standard deviation of the last 20 days' closing prices, and further adjusting this ratio based on the relative change in daily trading volumes over a 5-day period.",
          "code": "import pandas as pd\n    \n    # Calculate 5-day and 20-day moving averages for close prices\n    ma_5 = df['close'].rolling(window=5).mean()\n    ma_20 = df['close'].rolling(window=20).mean()\n    \n    # Compute the standard deviation of the close price over the last 20 days\n    std_20 = df['close'].rolling(window=20).std()\n    \n    # Calculate the moving average convergence\n    ma_convergence = (ma_5 - ma_20) / std_20\n    \n    # Calculate the 5-day percentage change in volume\n    vol_change_5 = df['volume'].pct_change(5).fillna(0)\n    \n    # Adjust the MA convergence with the relative change in volume\n    heuristics_matrix = ma_convergence + (ma_convergence * vol_change_5)\n    \n    return heuristics_matrix",
          "objective": -0.00678,
          "other_inf": null
     }
]