[
     {
          "algorithm": "The new algorithm calculates a modified trend factor by incorporating exponential moving averages of different lengths and then adjusts this factor based on the average true range to reflect market volatility, finally outputting this as the heuristics matrix.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    short_window = 5\n    long_window = 20\n    very_long_window = 60\n    \n    short_ema = df['close'].ewm(span=short_window, adjust=False).mean()\n    long_ema = df['close'].ewm(span=long_window, adjust=False).mean()\n    very_long_ema = df['close'].ewm(span=very_long_window, adjust=False).mean()\n\n    # Custom weight for emphasizing recent price movements\n    trend_factor = (2 * short_ema - long_ema) / 2\n    \n    # Calculate average true range over the long window as a measure of volatility\n    tr1 = df['high'] - df['low']\n    tr2 = np.abs(df['high'] - df['close'].shift())\n    tr3 = np.abs(df['low'] - df['close'].shift())\n    true_range = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)\n    atr = true_range.rolling(window=long_window).mean()\n\n    heuristics_matrix = trend_factor / atr\n    return heuristics_matrix",
          "objective": -0.03794,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm combines exponential moving averages of different periods, applies a dynamic weighting based on the ratio of short-term to long-term volatility, and then calculates the ratio between this weighted trend and the historical average true range.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    short_window = 5\n    long_window = 20\n    very_long_window = 60\n    \n    # Calculate exponential moving averages\n    short_ema = df['close'].ewm(span=short_window, adjust=False).mean()\n    long_ema = df['close'].ewm(span=long_window, adjust=False).mean()\n    very_long_ema = df['close'].ewm(span=very_long_window, adjust=False).mean()\n\n    # Calculate short-term and long-term volatility\n    short_volatility = df['close'].rolling(window=short_window).std()\n    long_volatility = df['close'].rolling(window=long_window).std()\n\n    # Dynamic weighting based on the ratio of short-term to long-term volatility\n    weight_factor = short_volatility / long_volatility\n    trend_factor = (weight_factor * short_ema + (1 - weight_factor) * long_ema) / 2\n\n    # Calculate the historical average true range\n    tr = df['high'] - df['low']\n    atr = tr.rolling(window=long_window).mean()\n\n    heuristics_matrix = trend_factor / atr\n    return heuristics_matrix",
          "objective": -0.02818,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm modifies the original by incorporating a 10-day and 30-day exponential moving average, adjusting dynamic weighting using logarithmic ratios of short-term to long-term volatilities, and integrating a 40-day window for calculating the Average True Range (ATR).",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    short_window = 10\n    long_window = 30\n    very_long_window = 60\n    \n    # Calculate exponential moving averages\n    short_ema = df['close'].ewm(span=short_window, adjust=False).mean()\n    long_ema = df['close'].ewm(span=long_window, adjust=False).mean()\n    very_long_ema = df['close'].ewm(span=very_long_window, adjust=False).mean()\n\n    # Calculate short-term and long-term volatility\n    short_volatility = df['close'].rolling(window=short_window).std()\n    long_volatility = df['close'].rolling(window=long_window).std()\n\n    # Dynamic weighting based on the ratio of log(short-term to long-term volatility)\n    weight_factor = (short_volatility / long_volatility).apply(lambda x: max(0, min(1, (x**0.5 - 0.5))))\n    trend_factor = (weight_factor * short_ema + (1 - weight_factor) * long_ema)\n\n    # Calculate the historical average true range with a 40-day window\n    tr = df['high'] - df['low']\n    atr = tr.rolling(window=40).mean()\n\n    heuristics_matrix = trend_factor / atr\n    return heuristics_matrix",
          "objective": -0.02803,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm combines a measure of momentum with the historical volatility, using a weighted sum of price changes and their standard deviations over different time horizons, to generate a factor that reflects both the directional movement and the risk of reversal.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    short_window = 5\n    long_window = 20\n    very_long_window = 60\n    \n    # Calculate the percentage change in closing prices\n    short_change = df['close'].pct_change(periods=short_window).fillna(0)\n    long_change = df['close'].pct_change(periods=long_window).fillna(0)\n    \n    # Calculate the standard deviation of the percentage changes as a measure of volatility\n    short_volatility = df['close'].pct_change().rolling(window=short_window).std().fillna(0)\n    long_volatility = df['close'].pct_change().rolling(window=long_window).std().fillna(0)\n\n    # Dynamic weighting based on the ratio of short-term to long-term volatility\n    weight_factor = short_volatility / (short_volatility + long_volatility)\n    momentum_factor = (weight_factor * short_change + (1 - weight_factor) * long_change)\n\n    # Combine momentum and volatility into a single factor\n    heuristics_matrix = momentum_factor / (short_volatility + long_volatility)\n    return heuristics_matrix",
          "objective": -0.02355,
          "other_inf": null
     }
]