```python
def heuristics_v2(df: pd.DataFrame) -> pd.Series:
    # Adaptive window for EMA based on volatility
    volatility = df['close'].rolling(window=20).std()
    ema_window = (volatility / volatility.mean() * 20).fillna(20).astype(int)
    df['ema_close'] = df['close'].ewm(span=ema_window, adjust=False).mean()

    # RSI calculation
    delta = df['close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
    rs = gain / loss
    df['rsi'] = 100 - (100 / (1 + rs))

    # Momentum with adaptive window
    momentum_window = (volatility / volatility.mean() * 14).fillna(14).astype(int)
    df['momentum'] = df['close'] / df['close'].shift(momentum_window) - 1

    # Volume-weighted measures
    df['volume_weighted_price'] = (df['close'] * df['volume']).rolling(window=5).sum() / df['volume'].rolling(window=5).sum()

    # Average True Range (ATR) as a measure of volatility
    df['tr'] = df[['high', 'low', 'close']].apply(lambda x: max(x['high'] - x['low'], abs(x['high'] - x['close'].shift(1)), abs(x['close'].shift(1) - x['low'])), axis=1)
    df['atr'] = df['tr'].rolling(window=14).mean()

    # Bollinger Bands
    df['sma_close'] = df['close'].rolling(window=20).mean()
    df['upper_band'] = df['sma_close'] + 2 * df['close'].rolling(window=20).std()
    df['lower_band'] = df['sma_close'] - 2 * df['close'].rolling(window=20).std()
    df['bb_width'] = (df['upper_band'] - df['lower_band']) / df['sma_close']

    # Chaikin Money Flow (CMF)
    money_flow_multiplier = ((df['close'] - df['low']) - (df['high'] - df['close'])) / (df['high'] - df['low'])
    money_flow_volume = money_flow_multiplier * df['volume']
    df['cmf'] = money_flow_volume.rolling(window=20).sum() / df['volume'].rolling(window=20).sum()

    # Dynamic factor adjustments
    df['dynamic_momentum'] = df['momentum'] * (df['volume_weighted_price'] / df['close'])
    df['dynamic_rsi'] = (df['rsi'] - 50) / 50 * (df['volume_weighted_price'] / df['close'])
    df['dynamic_cmf'] = df['cmf'] * (df['volume_weighted_price'] / df['close'])

    # Integrate advanced machine learning for adaptive weighting
    import numpy as np
    from sklearn.ensemble import RandomForestRegressor
    from sklearn.model_selection import TimeSeriesSplit
    from sklearn.metrics import mean_squared_error

    X = df[['dynamic_momentum', 'dynamic_rsi', 'dynamic_cmf']].dropna()
    y = df['close'].pct_change().shift(-1).loc[X.index]

    tscv = TimeSeriesSplit(n_splits=5)
    best_model = None
    best_rmse = np.inf

    for train_index, test_index in tscv.split(X):
        X_train, X_test = X.iloc[train_index], X.iloc[test_index]
        y_train, y_test = y.iloc[train_index], y.iloc[test_index]

        model = RandomForestRegressor(n_estimators=100, random_state=42)
        model.fit(X_train, y_train)
        y_pred = model.predict(X_test)
        rmse = np.sqrt(mean_squared_error(y_test, y_pred))

        if rmse < best_rmse:
            best_rmse = rmse
            best_model = model

    feature_importances = best_model.feature_importances_

    # Combine factors with adaptive weights
    factor_value = (X['dynamic_momentum'] * feature_importances[0] +
                    X['dynamic_rsi'] * feature_importances[1] +
                    X['dynamic_cmf'] * feature_importances[2])

    return factor_value
```
