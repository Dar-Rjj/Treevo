```python
def heuristics_v2(df: pd.DataFrame) -> pd.Series:
    # Adaptive window for EMA based on volatility
    volatility = df['close'].rolling(window=20).std()
    ema_window = (volatility / volatility.mean() * 20).fillna(20).astype(int)
    df['ema_close'] = df['close'].ewm(span=ema_window, adjust=False).mean()

    # RSI calculation
    delta = df['close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
    rs = gain / loss
    df['rsi'] = 100 - (100 / (1 + rs))

    # Momentum with adaptive window
    momentum_window = (volatility / volatility.mean() * 14).fillna(14).astype(int)
    df['momentum'] = df['close'] / df['close'].shift(momentum_window) - 1

    # Volume-weighted measures
    df['volume_weighted_price'] = (df['close'] * df['volume']).rolling(window=5).sum() / df['volume'].rolling(window=5).sum()

    # Average True Range (ATR) as a measure of volatility with more dynamic window
    df['tr'] = df[['high', 'low', 'close']].apply(lambda x: max(x['high'] - x['low'], abs(x['high'] - x['close'].shift(1)), abs(x['close'].shift(1) - x['low'])), axis=1)
    atr_window = (volatility / volatility.mean() * 14).fillna(14).astype(int)
    df['atr'] = df['tr'].rolling(window=atr_window).mean()

    # Bollinger Bands
    sma_window = (volatility / volatility.mean() * 20).fillna(20).astype(int)
    df['sma_close'] = df['close'].rolling(window=sma_window).mean()
    df['upper_band'] = df['sma_close'] + 2 * df['close'].rolling(window=sma_window).std()
    df['lower_band'] = df['sma_close'] - 2 * df['close'].rolling(window=sma_window).std()
    df['bb_width'] = (df['upper_band'] - df['lower_band']) / df['sma_close']

    # Chaikin Money Flow (CMF)
    money_flow_multiplier = ((df['close'] - df['low']) - (df['high'] - df['close'])) / (df['high'] - df['low'])
    money_flow_volume = money_flow_multiplier * df['volume']
    cmf_window = (volatility / volatility.mean() * 20).fillna(20).astype(int)
    df['cmf'] = money_flow_volume.rolling(window=cmf_window).sum() / df['volume'].rolling(window=cmf_window).sum()

    # Dynamic factor adjustments
    df['dynamic_momentum'] = df['momentum'] * (df['volume_weighted_price'] / df['close'])
    df['dynamic_rsi'] = (df['rsi'] - 50) / 50 * (df['volume_weighted_price'] / df['close'])
    df['dynamic_cmf'] = df['cmf'] * (df['volume_weighted_price'] / df['close'])

    # Integrate ensemble methods for factor combination
    import numpy as np
    from sklearn.linear_model import LinearRegression
    from sklearn.ensemble import RandomForestRegressor

    X = df[['dynamic_momentum', 'dynamic_rsi', 'dynamic_cmf']].dropna()
    y = df['close'].pct_change().shift(-1).loc[X.index]

    # Linear Regression model
    lr_model = LinearRegression()
    lr_model.fit(X, y)
    lr_weights = lr_model.coef_

    # Random Forest model
    rf_model = RandomForestRegressor(n_estimators=100, random_state=42)
    rf_model.fit(X, y)
    rf_importances = rf_model.feature_importances_

    # Combine factors using ensemble weights
    lr_factor_value = (X['dynamic_momentum'] * lr_weights[0] +
                       X['dynamic_rsi'] * lr_weights[1] +
                       X['dynamic_cmf'] * lr_weights[2])
    rf_factor_value = (X['dynamic_momentum'] * rf_importances[0] +
                       X['dynamic_rsi'] * rf_importances[1] +
                       X['dynamic_cmf'] * rf_importances[2])

    # Final factor value as an average of the two
    factor
