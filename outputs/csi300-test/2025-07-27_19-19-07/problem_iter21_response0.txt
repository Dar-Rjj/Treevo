```python
import pandas as pd
import numpy as np

def heuristics_v2(df):
    """
    Generate a novel and interpretable alpha factor based on the given market features.
    
    Parameters:
    df (pd.DataFrame): DataFrame with index as date and columns as open, high, low, close, amount, volume.
    
    Returns:
    pd.Series: Factor values indexed by date.
    """
    # Calculate the percentage change in closing price from yesterday to today
    df['close_pct_change'] = df['close'].pct_change()
    
    # Identify if the closing price is higher or lower compared to the opening price
    df['close_higher_than_open'] = (df['close'] > df['open']).astype(int)
    
    # Measure the difference between the high and low prices of the day
    df['price_range'] = df['high'] - df['low']
    
    # Determine how often the daily price range exceeds a certain threshold
    df['large_price_range'] = (df['price_range'] > 1.5 * df['price_range'].mean()).astype(int)
    
    # Calculate the ratio of today's volume to the average volume over the past n days
    n = 30
    df['volume_ratio'] = df['volume'] / df['volume'].rolling(window=n).mean()
    
    # Check if today's volume is an outlier by comparing it with the last m days' volumes
    m = 10
    df['volume_outlier'] = (df['volume'] > 2 * df['volume'].rolling(window=m).std()).astype(int)
    
    # Calculate the moving average of closing prices over a short period (e.g., 5 days)
    df['short_moving_avg'] = df['close'].rolling(window=5).mean()
    
    # Compare the current closing price with its short-term moving average
    df['above_short_moving_avg'] = (df['close'] > df['short_moving_avg']).astype(int)
    
    # Define positive and negative money flow based on whether the closing price is greater than the previous day
    df['positive_money_flow'] = df['close'] > df['close'].shift(1)
    df['negative_money_flow'] = df['close'] < df['close'].shift(1)
    
    # Sum the positive and negative money flows over a specified period
    k = 14
    df['pos_money_flow_sum'] = df['positive_money_flow'].rolling(window=k).sum()
    df['neg_money_flow_sum'] = df['negative_money_flow'].rolling(window=k).sum()
    
    # Create a weighted sum of the daily percentage change in price and the percentage change in volume
    df['weighted_change'] = 0.7 * df['close_pct_change'] + 0.3 * df['volume'].pct_change()
    
    # Calculate the true range for each day as the maximum of (high - low), (high - previous close), (previous close - low)
    df['true_range'] = df[['high', 'low', 'close']].apply(lambda x: max(x['high'] - x['low'], 
                                                                       abs(x['high'] - x['close'].shift(1)), 
                                                                       abs(x['low'] - x['close'].shift(1))), axis=1)
    
    # Sum the true ranges over a defined period to estimate average volatility
    df['atr_14'] = df['true_range'].rolling(window=k).sum()
    
    # Identify "pin bar" candlestick patterns
    df['pin_bar'] = ((df['high'] - df['low']) > 2 * (df['close'] - df['open']).abs()) & (
        (df['close'] - df['open']).abs() < 0.1 * (df['high'] - df['low']))
    
    # Count the number of bullish and bearish pin bars in the past n days
    df['bullish_pin_bar_count'] = df['pin_bar'].rolling(window=k).sum()
    df['bearish_pin_bar_count'] = (~df['pin_bar']).rolling(window=k).sum()
    
    # Check if significant volume increases are followed by consistent price movements
    df['high_volume'] = (df['volume'] > 2 * df['volume'].rolling(window=k).mean())
    df['consistent_move'] = (df['close'] > df['open']).rolling(window=k).mean()
    
    # Detect upward and downward gaps by comparing the open price with the previous day's close
    df['upward_gap'] = (df['open'] > df['close'].shift(1)).astype(int)
    df['downward_gap'] = (df['open'] < df['close'].shift(1)).astype(int)
    
    # Measure the distance of the stock price from its N
