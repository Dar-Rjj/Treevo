```python
def heuristics_v2(df: pd.DataFrame) -> pd.Series:
    # Calculate the price movement as a percentage change from open to close
    price_movement = (df['close'] - df['open']) / df['open']
    
    # Calculate the average of high and low prices
    avg_price = (df['high'] + df['low']) / 2
    
    # Calculate the relative strength index (RSI) for the close prices
    delta = df['close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    
    # Calculate the volume trend
    volume_trend = df['volume'].pct_change()
    
    # Calculate the exponential moving average of the price movement
    ema_price_movement = price_movement.ewm(span=14, adjust=False).mean()
    
    # Calculate the volume-weighted average price (VWAP)
    vwap = (df['close'] * df['volume']).cumsum() / df['volume'].cumsum()
    
    # Calculate the money flow index (MFI)
    typical_price = (df['high'] + df['low'] + df['close']) / 3
    money_flow = typical_price * df['volume']
    positive_money_flow = money_flow.where(price_movement > 0, 0)
    negative_money_flow = money_flow.where(price_movement < 0, 0)
    positive_money_flow_14 = positive_money_flow.rolling(window=14).sum()
    negative_money_flow_14 = negative_money_flow.rolling(window=14).sum()
    money_ratio = positive_money_flow_14 / negative_money_flow_14
    mfi = 100 - (100 / (1 + money_ratio))
    
    # Calculate the 5-day and 20-day simple moving averages
    sma_5d = df['close'].rolling(window=5).mean()
    sma_20d = df['close'].rolling(window=20).mean()
    
    # Calculate the distance between the 5-day and 20-day SMAs
    sma_distance = sma_5d - sma_20d
    
    # Calculate the 30-day and 60-day simple moving averages
    sma_30d = df['close'].rolling(window=30).mean()
    sma_60d = df['close'].rolling(window=60).mean()
    
    # Calculate the distance between the 30-day and 60-day SMAs
    sma_distance_long = sma_30d - sma_60d
    
    # Calculate the 14-period rolling standard deviation of returns for advanced volatility
    returns_volatility = df['close'].pct_change().rolling(window=14).std()
    
    # Calculate the momentum over a 10-day period
    momentum_10d = df['close'].pct_change(periods=10)
    
    # Calculate the 14-period rolling average of VWAP
    vwap_rolling_avg = vwap.rolling(window=14).mean()
    
    # Dynamic weighting based on the relative strength of the factors
    weight_momentum = abs(momentum_10d) / (abs(momentum_10d) + abs(sma_distance) + abs(rsi) + abs(mfi))
    weight_sma = abs(sma_distance) / (abs(momentum_10d) + abs(sma_distance) + abs(rsi) + abs(mfi))
    weight_rsi = abs(rsi) / (abs(momentum_10d) + abs(sma_distance) + abs(rsi) + abs(mfi))
    weight_mfi = abs(mfi) / (abs(momentum_10d) + abs(sma_distance) + abs(rsi) + abs(mfi))
    
    # Incorporate advanced volatility and multi-period analysis
    factor = (weight_momentum * momentum_10d +
              weight_sma * sma_distance +
              weight_rsi * rsi +
              weight_mfi * mfi +
              ema_price_movement +
              vwap_rolling_avg +
              sma_distance_long +
              returns_volatility)
    
    # Add a longer-term momentum component
    momentum_30d = df['close'].pct_change(periods=30)
    weight_momentum_30d = abs(momentum_30d) / (abs(momentum_10d) + abs(momentum_30d))

