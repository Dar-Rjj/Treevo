```python
def heuristics_v2(df: pd.DataFrame) -> pd.Series:
    # Calculate the daily return
    daily_return = df['close'].pct_change().fillna(0)
    
    # Calculate the average of high and low as a proxy for the midpoint of the day's trading range
    midpoint = (df['high'] + df['low']) / 2
    
    # Calculate the ratio of amount to volume, which could act as a proxy for the average price per share
    avg_price_per_share = df['amount'] / df['volume']
    
    # Calculate the difference between the close and open prices (daily movement)
    daily_movement = df['close'] - df['open']
    
    # Calculate the adaptive volatility (standard deviation of daily returns over an adaptive window based on recent volatility)
    adaptive_volatility_window = df['close'].rolling(window=5).std().fillna(1).apply(lambda x: 5 if x < 0.01 else 10)
    volatility = df['close'].rolling(window=adaptive_volatility_window).std().fillna(0)
    
    # Calculate the trend strength (difference between the adaptive moving average and the current close)
    adaptive_trend_window = df['close'].rolling(window=5).std().fillna(1).apply(lambda x: 5 if x < 0.01 else 10)
    trend_strength = df['close'].rolling(window=adaptive_trend_window).mean() - df['close']
    
    # Calculate the trading volume intensity (current volume divided by the adaptive average volume)
    adaptive_volume_window = df['close'].rolling(window=5).std().fillna(1).apply(lambda x: 5 if x < 0.01 else 10)
    volume_intensity = df['volume'] / df['volume'].rolling(window=adaptive_volume_window).mean()
    volume_intensity.fillna(1, inplace=True)
    
    # Factor: Combine daily return, daily movement, distance from the closing price to the midpoint, 
    # average price per share, volatility, trend strength, and trading volume intensity
    factor = daily_return * 0.3 + daily_movement * 0.2 - 0.1 * (df['close'] - midpoint) + 0.1 * avg_price_per_share - 0.1 * volatility + 0.1 * trend_strength + 0.1 * volume_intensity
    
    return factor
```
