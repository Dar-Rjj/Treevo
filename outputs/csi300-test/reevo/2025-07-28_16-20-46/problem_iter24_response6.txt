```python
import pandas as pd
import numpy as np

def heuristics_v2(df: pd.DataFrame) -> pd.Series:
    # Calculate the 5-day and 20-day exponential moving average of closing prices to capture momentum
    df['EMA_5'] = df['close'].ewm(span=5, adjust=False).mean()
    df['EMA_20'] = df['close'].ewm(span=20, adjust=False).mean()

    # Momentum factor: difference between 5-day and 20-day EMA
    df['momentum_factor'] = df['EMA_5'] - df['EMA_20']

    # Calculate the 20-day standard deviation of closing prices to capture volatility
    df['volatility_factor'] = df['close'].rolling(window=20).std()

    # Calculate the 5-day rolling sum of volume to capture liquidity
    df['liquidity_factor'] = df['volume'].rolling(window=5).sum()

    # Calculate relative strength as the ratio of current close to 20-day EMA
    df['relative_strength'] = df['close'] / df['EMA_20']

    # Calculate market breadth: difference between 5-day and 20-day moving averages of (high - low)
    df['range_5'] = (df['high'] - df['low']).rolling(window=5).mean()
    df['range_20'] = (df['high'] - df['low']).rolling(window=20).mean()
    df['market_breadth'] = df['range_5'] - df['range_20']

    # Incorporate Volume Weighted Average Price (VWAP)
    df['VWAP'] = (df['amount'] / df['volume']).rolling(window=20).mean()
    df['VWAP_deviation'] = (df['close'] - df['VWAP']) / df['VWAP']

    # Calculate logarithmic returns
    df['log_returns'] = np.log(df['close'] / df['close'].shift(1))

    # Advanced volatility: Exponentially Weighted Moving Average (EWMA) of log returns
    df['EWMA_volatility'] = df['log_returns'].ewm(span=20, adjust=False).std()

    # Adaptive thresholds for dynamic indicators
    df['momentum_threshold'] = df['momentum_factor'].rolling(window=20).quantile(0.75)
    df['volatility_threshold'] = df['volatility_factor'].rolling(window=20).quantile(0.75)
    df['liquidity_threshold'] = df['liquidity_factor'].rolling(window=20).quantile(0.75)
    df['market_breadth_threshold'] = df['market_breadth'].rolling(window=20).quantile(0.75)
    df['VWAP_deviation_threshold'] = df['VWAP_deviation'].abs().rolling(window=20).quantile(0.75)
    df['EWMA_volatility_threshold'] = df['EWMA_volatility'].rolling(window=20).quantile(0.75)

    # Dynamic weights based on adaptive thresholds
    df['momentum_weight'] = df['momentum_factor'] / df['momentum_threshold']
    df['volatility_weight'] = df['volatility_factor'] / df['volatility_threshold']
    df['liquidity_weight'] = df['liquidity_factor'] / df['liquidity_threshold']
    df['market_breadth_weight'] = df['market_breadth'] / df['market_breadth_threshold']
    df['VWAP_weight'] = df['VWAP_deviation'].abs() / df['VWAP_deviation_threshold']
    df['EWMA_volatility_weight'] = df['EWMA_volatility'] / df['EWMA_volatility_threshold']

    # Integrate macroeconomic data (example: interest rate)
    # Assuming 'interest_rate' is a column in the DataFrame
    df['interest_rate_deviation'] = (df['interest_rate'] - df['interest_rate'].rolling(window=20).mean()) / df['interest_rate'].rolling(window=20).std()
    df['interest_rate_weight'] = df['interest_rate_deviation'].rank(pct=True)

    # Combine the factors with dynamic weights
    heuristic_factor = (df['momentum_factor'] * df['momentum_weight']) + \
                       (df['volatility_factor'] * df['volatility_weight']) + \
                       (df['liquidity_factor'] * df['liquidity_weight']) + \
                       (df['market_breadth'] * df['market_breadth_weight']) + \
                       (df['VWAP_deviation'] * df['VWAP_weight']) +
