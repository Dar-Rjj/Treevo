```python
import pandas as pd
import numpy as np

def heuristics_v2(df, N=20, M=20):
    # Obtain Close Prices
    close_prices = df['close']
    
    # Calculate Log Returns
    log_returns = np.log(close_prices) - np.log(close_prices.shift(1))
    
    # Compute Momentum
    cumulative_log_returns = log_returns.rolling(window=N).sum()
    upper_threshold = cumulative_log_returns.mean() + 2 * cumulative_log_returns.std()
    lower_threshold = cumulative_log_returns.mean() - 2 * cumulative_log_returns.std()
    clipped_momentum = np.clip(cumulative_log_returns, a_min=lower_threshold, a_max=upper_threshold)
    
    # Adjust for Volume
    volumes = df['volume']
    volume_relative_to_mean = volumes / volumes.rolling(window=N).mean()
    adjusted_momentum = clipped_momentum * volume_relative_to_mean
    
    # Determine Absolute Price Changes
    absolute_price_changes = abs(close_prices - close_prices.shift(1))
    
    # Calculate Advanced Volatility Measures
    std_dev_volatility = absolute_price_changes.rolling(window=M).std()
    ema_volatility = absolute_price_changes.ewm(span=M).mean()
    iqr_volatility = absolute_price_changes.rolling(window=M).quantile(0.75) - absolute_price_changes.rolling(window=M).quantile(0.25)
    
    # Combine Weighted Components
    weights = [0.4, 0.3, 0.3]
    final_factor = (weights[0] * adjusted_momentum +
                   weights[1] * std_dev_volatility +
                   weights[2] * ema_volatility)
    
    # Ensure Weights Sum to 1
    assert sum(weights) == 1.0, "Weights must sum to 1"
    
    # Review and Validate Each Component
    # Integrate Market Breadth and Economic Indicators
    # Use Market Breadth Indicators
    # Incorporate Key Economic Indicators
    # Continuously Backtest
    # Evaluate Robustness
    # Optimize Weights
    # Monitor Performance Over Time
    
    return final_factor
```
