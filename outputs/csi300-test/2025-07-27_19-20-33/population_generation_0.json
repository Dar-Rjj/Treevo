[
     {
          "algorithm": "The algorithm calculates the momentum of the closing price over the past 10 days and combines it with the relative difference between the average volume of the last 5 days and the overall average volume, aiming to generate a predictive factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    close_momentum = df['close'].pct_change(10)\n    avg_vol_5d = df['volume'].rolling(window=5).mean()\n    total_avg_vol = df['volume'].mean()\n    rel_diff_vol = (avg_vol_5d - total_avg_vol) / total_avg_vol\n    heuristics_matrix = (close_momentum + rel_diff_vol) / 2\n    return heuristics_matrix",
          "objective": -0.03873,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a proprietary heuristic factor based on weighted moving averages and standard deviations of market features, then aggregates these through a non-linear transformation to produce the final heuristics matrix.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Compute rolling means and standard deviations for each feature\n    window = 10\n    roll_mean = df.rolling(window=window).mean()\n    roll_std = df.rolling(window=window).std()\n\n    # Combine them using a non-linear transformation\n    composite = (roll_mean / (1 + roll_std)).apply(np.tanh)\n    \n    # Sum across columns to get a single time series\n    heuristics_matrix = composite.sum(axis=1)\n\n    return heuristics_matrix",
          "objective": -0.0065,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a heuristic factor based on the weighted combination of price momentum, volatility, and trading volume trends, where the weights are dynamically adjusted according to the recent market conditions.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily return\n    daily_return = df['close'].pct_change()\n    \n    # Calculate volatility (standard deviation of daily returns over the last 30 days)\n    volatility = daily_return.rolling(window=30).std()\n    \n    # Calculate price momentum (difference between current close and 5-day moving average of close)\n    momentum = df['close'] - df['close'].rolling(window=5).mean()\n    \n    # Calculate volume trend (percentage change in volume)\n    volume_trend = df['volume'].pct_change()\n    \n    # Dynamically adjust weights based on the recent trend of daily returns\n    weight_momentum = (daily_return > 0).rolling(window=30).sum() / 30\n    weight_volatility = (1 - weight_momentum)\n    weight_volume = (volume_trend > 0).rolling(window=30).sum() / 30\n    \n    # Compute the heuristic factor\n    heuristics_matrix = (weight_momentum * momentum) + (weight_volatility * volatility) + (weight_volume * volume_trend)\n    \n    # Return the resulting series\n    return heuristics_matrix",
          "objective": -0.00349,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a heuristic factor based on the relative strength index (RSI) of the close price and the volume, capturing momentum and volume trends.",
          "code": "def heuristics_v2(df):\n    def rsi(series, period=14):\n        delta = series.diff(1)\n        gain = (delta.where(delta > 0, 0)).fillna(0)\n        loss = (-delta.where(delta < 0, 0)).fillna(0)\n        avg_gain = gain.rolling(window=period).mean()\n        avg_loss = loss.rolling(window=period).mean()\n        rs = avg_gain / avg_loss\n        return 100 - (100 / (1 + rs))\n    \n    close_rsi = rsi(df['close'])\n    volume_rsi = rsi(df['volume'])\n    heuristics_matrix = (close_rsi + volume_rsi) / 2\n    return heuristics_matrix",
          "objective": -0.00224,
          "other_inf": null
     }
]