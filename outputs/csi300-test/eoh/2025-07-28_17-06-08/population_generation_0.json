[
     {
          "algorithm": "The algorithm identifies patterns in the market data by calculating the difference between the highest and lowest prices over a 10-day window, then adjusts this with the volume trend to derive a novel alpha factor.",
          "code": "def heuristics_v2(df):\n    df['high_low_diff'] = df['high'].rolling(window=10).max() - df['low'].rolling(window=10).min()\n    df['volume_trend'] = df['volume'].pct_change().rolling(window=5).mean()\n    heuristics_matrix = (df['high_low_diff'] * (1 + df['volume_trend'])).dropna()\n    return heuristics_matrix",
          "objective": -0.01964,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm, termed Heuristics_v2, computes a factor by integrating the momentum of closing prices with volume changes and volatility, summarized through a weighted combination where weights are determined based on historical correlations between each component and future returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    close_momentum = df['close'].pct_change(20)\n    volume_change = df['volume'].pct_change()\n    volatility = df['high'] - df['low']\n    \n    # Compute historical correlation for weighting (simplified using static values here for example)\n    corr_close_return = 0.5  # Example value\n    corr_vol_change = 0.3   # Example value\n    corr_volatility = 0.2   # Example value\n    \n    heuristics_matrix = (corr_close_return * close_momentum + \n                         corr_vol_change * volume_change + \n                         corr_volatility * volatility)\n    return heuristics_matrix",
          "objective": -0.01958,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a heuristic factor based on the ratio of the moving average of closing prices over different periods, aiming to capture momentum and mean-reversion signals.",
          "code": "def heuristics_v2(df):\n    short_window = 10\n    long_window = 50\n    short_mavg = df['close'].rolling(window=short_window).mean()\n    long_mavg = df['close'].rolling(window=long_window).mean()\n    heuristics_matrix = (short_mavg / long_mavg) - 1\n    return heuristics_matrix",
          "objective": -0.01654,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a composite factor by combining momentum, volatility, and trading volume indicators to predict future stock returns.",
          "code": "def heuristics_v2(df):\n    def compute_momentum(df, window=20):\n        return df['close'].pct_change(window)\n\n    def compute_volatility(df, window=20):\n        return df['close'].rolling(window).std()\n\n    def compute_trading_volume_indicator(df, window=20):\n        return df['volume'].pct_change(window)\n    \n    momentum = compute_momentum(df)\n    volatility = compute_volatility(df)\n    tvi = compute_trading_volume_indicator(df)\n    \n    heuristics_matrix = (momentum - volatility) * tvi\n    return heuristics_matrix",
          "objective": -0.01213,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a weighted combination of momentum, volatility, and trading volume to generate an interpretable alpha factor, where the weights are determined by the historical correlation of each feature with future returns.",
          "code": "def heuristics_v2(df):\n    # Compute momentum factor\n    momentum = df['close'].pct_change(periods=126)\n    \n    # Compute volatility factor\n    volatility = df['close'].pct_change().rolling(window=252).std()\n    \n    # Compute volume factor\n    volume_change = df['volume'].pct_change()\n    \n    # Combine factors into a matrix\n    heuristics_matrix = (momentum + volatility + volume_change) / 3\n    \n    return heuristics_matrix",
          "objective": -0.01046,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a composite factor by combining momentum, volatility, and trading volume indicators to predict future stock returns.",
          "code": "def heuristics_v2(df):\n    def momentum(df):\n        return df['close'].pct_change(10)\n    \n    def volatility(df):\n        return df['close'].pct_change().rolling(window=20).std()\n    \n    def volume_trend(df):\n        return df['volume'].pct_change(5)\n    \n    heuristics_matrix = (momentum(df) + volatility(df) + volume_trend(df)) / 3\n    return heuristics_matrix",
          "objective": -0.01037,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a heuristic factor based on the rolling ratio of the difference between high and low prices over the average volume for a fixed window, aiming to capture market sentiment through volatility relative to trading activity.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    df['hl_diff'] = df['high'] - df['low']\n    df['avg_volume'] = df['volume'].rolling(window=10).mean()\n    heuristics_matrix = (df['hl_diff'] / df['avg_volume']).shift(1)  # Shift by 1 to avoid lookahead bias\n    return heuristics_matrix",
          "objective": -0.0093,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm, named Heuristics_v2, calculates a novel alpha factor by combining weighted moving averages of the open and close prices with a momentum indicator derived from volume, aiming to predict future stock returns based on historical price and volume movements.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate short and long term moving averages for open and close\n    short_window = 5\n    long_window = 20\n    df['Open_Short_MA'] = df['open'].rolling(window=short_window).mean()\n    df['Close_Short_MA'] = df['close'].rolling(window=short_window).mean()\n    df['Open_Long_MA'] = df['open'].rolling(window=long_window).mean()\n    df['Close_Long_MA'] = df['close'].rolling(window=long_window).mean()\n    \n    # Momentum calculation based on volume\n    df['Volume_Momentum'] = df['volume'].pct_change(periods=long_window)\n    \n    # Combine factors into a single heuristic\n    heuristics_matrix = (df['Open_Short_MA'] - df['Open_Long_MA']) * 0.5 + (df['Close_Short_MA'] - df['Close_Long_MA']) * 0.5 + df['Volume_Momentum']\n    \n    return heuristics_matrix",
          "objective": -0.00906,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm involves calculating a novel alpha factor by combining the momentum and volatility of stock prices, specifically by first computing the 10-day and 30-day price return (momentum), then calculating the 10-day standard deviation of returns (volatility), and finally, generating a heuristics_matrix through a weighted combination of these momentum and volatility measures.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate 10-day and 30-day price returns\n    df['10_day_return'] = df['close'].pct_change(10)\n    df['30_day_return'] = df['close'].pct_change(30)\n    \n    # Calculate 10-day standard deviation of returns as a measure of volatility\n    df['daily_return'] = df['close'].pct_change()\n    df['10_day_volatility'] = df['daily_return'].rolling(window=10).std()\n    \n    # Generate the heuristics matrix using a weighted sum of momentum and volatility\n    df['heuristics'] = 0.5 * (df['10_day_return'] + df['30_day_return']) - 0.5 * df['10_day_volatility']\n    \n    heuristics_matrix = df['heuristics']\n    \n    return heuristics_matrix",
          "objective": -0.00778,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm constructs a novel alpha factor by calculating the rolling difference between the 10-day exponential moving average (EMA) of the stock's closing price and the 30-day EMA, capturing medium-term momentum and mean reversion tendencies.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    ema_10 = df['close'].ewm(span=10, adjust=False).mean()\n    ema_30 = df['close'].ewm(span=30, adjust=False).mean()\n    heuristics_matrix = ema_10 - ema_30\n    return heuristics_matrix",
          "objective": -0.00745,
          "other_inf": null
     }
]