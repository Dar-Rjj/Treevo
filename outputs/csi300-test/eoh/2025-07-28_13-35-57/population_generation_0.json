[
     {
          "algorithm": "The algorithm involves computing a weighted sum of the exponential moving averages (EMAs) of price and volume, with weights dynamically adjusted based on the recent volatility of the asset, to generate an alpha factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate EMAs for close price and volume\n    ema_close = df['close'].ewm(span=10, adjust=False).mean()\n    ema_volume = df['volume'].ewm(span=10, adjust=False).mean()\n    \n    # Calculate the standard deviation of returns as a measure of volatility\n    daily_returns = df['close'].pct_change().fillna(0)\n    volatility = daily_returns.rolling(window=20).std().fillna(0)\n    \n    # Dynamically adjust the weights based on the volatility\n    weight_price = 1 / (1 + volatility)\n    weight_volume = 1 - weight_price\n    \n    # Compute the heuristic factor\n    heuristics_matrix = (ema_close * weight_price) + (ema_volume * weight_volume)\n    \n    return heuristics_matrix",
          "objective": -0.01427,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies patterns in the relationship between daily trading volume and price changes, then constructs a heuristic factor based on these patterns, which might be predictive of future stock returns.",
          "code": "def heuristics_v2(df):\n    # Calculate the daily return\n    df['daily_return'] = df['close'].pct_change()\n    # Shift the daily return to align it with the volume data as a forward-looking indicator\n    df['shifted_daily_return'] = df['daily_return'].shift(-1)\n    # Calculate the difference between today's and yesterday's volume\n    df['volume_change'] = df['volume'].diff()\n    # Create the heuristic factor by multiplying the shifted daily return by the sign of the volume change\n    heuristics_matrix = (df['shifted_daily_return'] * df['volume_change'].apply(lambda x: 1 if x > 0 else -1)).dropna()\n    return heuristics_matrix",
          "objective": -0.01137,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates the weighted moving average of price differences and trading volumes to generate an interpretable alpha factor, with weights dynamically adjusted based on market volatility.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily price change\n    df['price_change'] = df['close'].diff()\n    \n    # Calculate standard deviation as a measure of volatility\n    df['volatility'] = df['close'].rolling(window=20).std()\n    \n    # Compute weight for each day, inversely proportional to the volatility\n    df['weight'] = 1 / (df['volatility'] + 1e-6)  # Adding small value to avoid division by zero\n    \n    # Normalize the weights to sum up to 1 in each period\n    df['weight'] /= df['weight'].sum()\n    \n    # Calculate the weighted moving average of price changes and volume\n    heuristics_matrix = (df['price_change'] * df['volume'] * df['weight']).rolling(window=20).sum()\n    \n    return heuristics_matrix",
          "objective": -0.01096,
          "other_inf": null
     },
     {
          "algorithm": "A novel algorithm that combines moving averages, trading volume changes, and price momentum to generate alpha factors, by first calculating the short-term and long-term moving averages of closing prices, then assessing the relative change in trading volume, and finally integrating these with the momentum calculated as the percentage change in closing prices over a specified period.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    short_window = 10\n    long_window = 50\n    df['SMA'] = df['close'].rolling(window=short_window).mean()\n    df['LMA'] = df['close'].rolling(window=long_window).mean()\n    df['Volume_Change'] = df['volume'].pct_change()\n    df['Momentum'] = df['close'].pct_change(periods=short_window)\n    heuristics_matrix = (df['SMA'] - df['LMA']) + df['Volume_Change'] * df['Momentum']\n    return heuristics_matrix",
          "objective": -0.00977,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a momentum-based alpha factor by combining the percentage change in closing prices over different time horizons (e.g., 5, 20, and 60 days) to generate a composite signal indicating potential future returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def calculate_percentage_change(series, periods):\n        return series.pct_change(periods=periods).fillna(0)\n\n    momentum_5 = calculate_percentage_change(df['close'], 5)\n    momentum_20 = calculate_percentage_change(df['close'], 20)\n    momentum_60 = calculate_percentage_change(df['close'], 60)\n    \n    heuristics_matrix = (momentum_5 + momentum_20 + momentum_60) / 3\n    return heuristics_matrix",
          "objective": -0.00918,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies potential alpha factors by calculating the difference between the closing price and a weighted moving average of the past n days' low prices, where weights are determined by the volume, aiming to capture both momentum and volume signals.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    n = 20  # Example lookback period for the moving average\n    # Calculate the weighted moving average of the 'low' column using 'volume' as weights\n    df['wma_low'] = (df['low'] * df['volume']).rolling(window=n).sum() / df['volume'].rolling(window=n).sum()\n    # Calculate the difference between the 'close' price and the weighted moving average of lows\n    heuristics_matrix = df['close'] - df['wma_low']\n    return heuristics_matrix",
          "objective": -0.0091,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm, named Heuristic Alpha Factor Generator (HAFG), generates a novel set of alpha factors by combining moving averages, momentum, and volume indicators to produce a comprehensive heuristic score without normalizing the data.",
          "code": "import pandas as pd\n    # Calculate short and long term moving averages for 'close' prices\n    df['SMA'] = df['close'].rolling(window=10).mean()\n    df['LMA'] = df['close'].rolling(window=50).mean()\n    # Calculate momentum factor based on change in 'close' price over 10 periods\n    df['Momentum'] = df['close'].pct_change(periods=10)\n    # Incorporate a volume trend indicator\n    df['Volume_Trend'] = df['volume'].pct_change(periods=5)\n    # Generate a heuristic score combining all factors\n    df['Heuristic_Score'] = (df['SMA'] - df['LMA']) + df['Momentum'] + df['Volume_Trend']\n    # Extracting the heuristic score series\n    heuristics_matrix = df['Heuristic_Score']\n    return heuristics_matrix",
          "objective": -0.00907,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a composite factor by first computing the exponential moving average (EMA) of the close price, then subtracting the EMA of the volume, and finally dividing this result by the high-low price range over a lookback period.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    ema_close = df['close'].ewm(span=20, adjust=False).mean()\n    ema_volume = df['volume'].ewm(span=20, adjust=False).mean()\n    price_range = df['high'] - df['low']\n    heuristics_matrix = (ema_close - ema_volume) / price_range\n    return heuristics_matrix",
          "objective": -0.00708,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm employs a combination of momentum and volatility indicators calculated from open, high, low, close, amount, and volume data, then synthesizes these into a single heuristics matrix, aiming to identify patterns predictive of future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    df['momentum'] = df['close'].pct_change()\n    df['volatility'] = df['close'].rolling(window=5).std()\n    df['heuristic_factor'] = (df['momentum'] / df['volatility']).shift(1)\n    heuristics_matrix = df['heuristic_factor'].dropna()\n    return heuristics_matrix",
          "objective": -0.00648,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm constructs a novel alpha factor by calculating the weighted sum of moving averages of different time spans and their respective price changes, then applying an exponential smoothing technique to generate the final heuristics matrix.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate simple moving averages for 5, 10, and 20 days\n    sma_5 = df['close'].rolling(window=5).mean()\n    sma_10 = df['close'].rolling(window=10).mean()\n    sma_20 = df['close'].rolling(window=20).mean()\n    \n    # Calculate price change from the previous day\n    price_change = df['close'].pct_change()\n    \n    # Calculate exponentially weighted moving average (EWMA) of price change\n    ewma_price_change = price_change.ewm(span=20, adjust=False).mean()\n    \n    # Construct the heuristic factor as a weighted sum\n    heuristics_matrix = (sma_5 * 0.3 + sma_10 * 0.4 + sma_20 * 0.3) * ewma_price_change\n    \n    return heuristics_matrix",
          "objective": -0.00564,
          "other_inf": null
     }
]