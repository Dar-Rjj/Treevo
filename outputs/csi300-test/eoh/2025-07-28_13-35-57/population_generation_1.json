[
     {
          "algorithm": "The new algorithm calculates a heuristic factor by combining the daily return with the ratio of today's volume to the average volume over the past 5 days, aiming to capture how significant volume changes impact future returns.",
          "code": "def heuristics_v2(df):\n    df['daily_return'] = df['close'].pct_change()\n    df['shifted_daily_return'] = df['daily_return'].shift(-1)\n    df['avg_volume_5d'] = df['volume'].rolling(window=5).mean()\n    df['volume_ratio'] = df['volume'] / df['avg_volume_5d']\n    heuristics_matrix = (df['shifted_daily_return'] * df['volume_ratio']).dropna()\n    return heuristics_matrix",
          "objective": -0.3775,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted combination of the Stochastic Oscillator from 'high' and 'low' prices and the rate of change (ROC) of 'volume', with weights inversely proportional to the absolute difference between the current 'close' price and its 10-period moving average, to generate an alpha factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the 10-period moving average\n    ma_10 = df['close'].rolling(window=10).mean()\n    \n    # Distance of close price from its 10-period moving average\n    dist_from_ma10 = df['close'] - ma_10\n    \n    # Calculate the Stochastic Oscillator\n    highest_high = df['high'].rolling(window=14).max()\n    lowest_low = df['low'].rolling(window=14).min()\n    k_line = 100 * ((df['close'] - lowest_low) / (highest_high - lowest_low))\n    \n    # Calculate the rate of change (ROC) of 'volume'\n    roc_volume = df['volume'].pct_change(periods=10).fillna(0)\n    \n    # Determine dynamic weights based on the distance from MA10\n    weight_k = 1 / (1 + abs(dist_from_ma10.fillna(0)))\n    weight_roc = 1 - weight_k\n    \n    # Compute the heuristic factor\n    heuristics_matrix = (k_line * weight_k) + (roc_volume * weight_roc)\n    \n    return heuristics_matrix",
          "objective": -0.02957,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm involves computing a weighted sum of the exponential moving averages (EMAs) of close price and volume, with weights dynamically adjusted based on the recent range (high-low) of the asset, to generate an alpha factor.",
          "code": "def heuristics_v2(df):\n    # Calculate EMAs for close price and volume\n    ema_close = df['close'].ewm(span=10, adjust=False).mean()\n    ema_volume = df['volume'].ewm(span=10, adjust=False).mean()\n    \n    # Calculate the daily range as a measure of price movement\n    daily_range = (df['high'] - df['low']).rolling(window=20).mean().fillna(0)\n    \n    # Dynamically adjust the weights based on the daily range\n    weight_price = 1 / (1 + daily_range)\n    weight_volume = 1 - weight_price\n    \n    # Compute the heuristic factor\n    heuristics_matrix = (ema_close * weight_price) + (ema_volume * weight_volume)\n    \n    return heuristics_matrix",
          "objective": -0.02802,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted combination of the RSI (Relative Strength Index) from the 'close' prices and the rate of change (ROC) of 'volume', with weights determined by the distance between the current 'close' price and its 20-period moving average, to generate an alpha factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the 20-period moving average\n    ma_20 = df['close'].rolling(window=20).mean()\n    \n    # Distance of close price from its 20-period moving average\n    dist_from_ma20 = df['close'] - ma_20\n    \n    # Calculate the RSI for 'close' prices\n    delta = df['close'].diff(1)\n    gain = (delta.where(delta > 0, 0)).fillna(0)\n    loss = (-delta.where(delta < 0, 0)).fillna(0)\n    avg_gain = gain.rolling(window=14).mean()\n    avg_loss = loss.rolling(window=14).mean()\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate the rate of change (ROC) of 'volume'\n    roc_volume = df['volume'].pct_change(periods=10).fillna(0)\n    \n    # Determine dynamic weights based on the distance from MA20\n    weight_rsi = 1 / (1 + abs(dist_from_ma20.fillna(0)))\n    weight_roc = 1 - weight_rsi\n    \n    # Compute the heuristic factor\n    heuristics_matrix = (rsi * weight_rsi) + (roc_volume * weight_roc)\n    \n    return heuristics_matrix",
          "objective": -0.02485,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted combination of the 5-period RSI from 'close' prices and the rate of change (ROC) of 'amount', with weights adjusted based on the standard deviation of the 'close' price over the last 10 periods, to generate an alpha factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the 10-period standard deviation of close price\n    std_10 = df['close'].rolling(window=10).std()\n    \n    # Calculate the 5-period RSI\n    delta = df['close'].diff(1)\n    gain = (delta.where(delta > 0, 0)).fillna(0)\n    loss = (-delta.where(delta < 0, 0)).fillna(0)\n    avg_gain = gain.rolling(window=5).mean()\n    avg_loss = loss.rolling(window=5).mean()\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate the rate of change (ROC) of 'amount'\n    roc_amount = df['amount'].pct_change(periods=10).fillna(0)\n    \n    # Determine dynamic weights based on the standard deviation\n    weight_rsi = 1 / (1 + std_10.fillna(0))\n    weight_roc = 1 - weight_rsi\n    \n    # Compute the heuristic factor\n    heuristics_matrix = (rsi * weight_rsi) + (roc_amount * weight_roc)\n    \n    return heuristics_matrix",
          "objective": -0.0213,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the factor by evaluating the ratio of the average closing price to the weighted average price range over a specified period, with the weight being the square root of the trading volume, aiming to enhance the signal's sensitivity to high-volume price movements.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    n = 10\n    df['PriceRange'] = df['high'] - df['low']\n    df['SqrtVolume'] = df['volume'].apply(lambda x: x**0.5)\n    df['Weighted_PriceRange'] = (df['PriceRange'] * df['SqrtVolume']).rolling(window=n).sum() / df['SqrtVolume'].rolling(window=n).sum()\n    avg_close = df['close'].rolling(window=n).mean()\n    heuristics_matrix = avg_close / df['Weighted_PriceRange']\n    return heuristics_matrix",
          "objective": -0.01908,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the factor by assessing the relationship between the high and low prices over a specified period, weighted by the trading volume, to identify potential price action signals.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    n = 20\n    df['PriceRange'] = df['high'] - df['low']\n    df['Weighted_PriceRange'] = (df['PriceRange'] * df['volume']).rolling(window=n).sum() / df['volume'].rolling(window=n).sum()\n    heuristics_matrix = df['close'] / df['Weighted_PriceRange']\n    return heuristics_matrix",
          "objective": -0.01898,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the factor by assessing the exponential moving average of the high and low price differences, weighted by the trading volume, over a specified period to capture dynamic price action signals.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    n = 20\n    df['PriceRange'] = df['high'] - df['low']\n    df['Weighted_PriceRange'] = (df['PriceRange'] * df['volume']).ewm(span=n, adjust=False).mean() / df['volume'].ewm(span=n, adjust=False).mean()\n    heuristics_matrix = df['close'] / df['Weighted_PriceRange']\n    return heuristics_matrix",
          "objective": -0.0175,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm integrates the 14-day EMA of closing prices, a modified RSI calculated using a shorter period, and the smoothed ratio of positive to total volume over a 7-day window to create a predictive factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate 14-day EMA for closing prices\n    df['EMA'] = df['close'].ewm(span=14, adjust=False).mean()\n    \n    # Calculate a modified 9-day RSI\n    delta = df['close'].diff(1)\n    up = delta.clip(lower=0)\n    down = -delta.clip(upper=0)\n    ema_up = up.ewm(com=8, adjust=False).mean()\n    ema_down = down.ewm(com=8, adjust=False).mean()\n    rs = ema_up/ema_down\n    df['RSI'] = 100 - (100 / (1 + rs))\n    \n    # Calculate the 7-day EMA of the ratio of positive volume to total volume\n    df['Volume_Pos_Ratio'] = (df['volume'] * (df['close'] > df['open']).astype(int)) / df['volume']\n    df['Volume_Pos_Ratio_EMA'] = df['Volume_Pos_Ratio'].ewm(span=7, adjust=False).mean()\n    \n    # Integrate EMA, RSI, and Volume_Pos_Ratio_EMA\n    heuristics_matrix = df['EMA'] * df['RSI'] * df['Volume_Pos_Ratio_EMA']\n    \n    return heuristics_matrix",
          "objective": -0.01722,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes a factor by integrating the exponential moving average (EMA) of the closing prices, the relative strength index (RSI), and the ratio of positive to total volume as a measure of buying pressure.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate 14-day EMA for closing prices\n    df['EMA'] = df['close'].ewm(span=14, adjust=False).mean()\n    \n    # Calculate RSI\n    delta = df['close'].diff(1)\n    up = delta.clip(lower=0)\n    down = -delta.clip(upper=0)\n    ema_up = up.ewm(com=13, adjust=False).mean()\n    ema_down = down.ewm(com=13, adjust=False).mean()\n    rs = ema_up/ema_down\n    df['RSI'] = 100 - (100 / (1 + rs))\n    \n    # Calculate the ratio of positive volume to total volume\n    df['Volume_Pos_Ratio'] = (df['volume'] * (df['close'] > df['open']).astype(int)) / df['volume']\n    \n    # Integrate EMA, RSI, and Volume_Pos_Ratio\n    heuristics_matrix = df['EMA'] * df['RSI'] * df['Volume_Pos_Ratio']\n    \n    return heuristics_matrix",
          "objective": -0.0148,
          "other_inf": null
     }
]