[
     {
          "algorithm": "The new algorithm computes a 5-day VWAP, then calculates the price-to-VWAP ratio and multiplies it by the next day's return to produce the heuristic factor.",
          "code": "def heuristics_v2(df):\n    df['daily_return'] = df['close'].pct_change()\n    df['shifted_daily_return'] = df['daily_return'].shift(-1)\n    df['vwap_5d'] = (df['amount'] / df['volume']).rolling(window=5).mean()  # Calculating 5-day VWAP\n    df['price_ratio'] = df['close'] / df['vwap_5d']\n    heuristics_matrix = (df['shifted_daily_return'] * df['price_ratio']).dropna()\n    return heuristics_matrix",
          "objective": -0.40333,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm incorporates the 5-day moving average (MA) of the close prices and calculates a score based on the ratio between the current close price and this MA, multiplied by the next day's daily return.",
          "code": "def heuristics_v2(df):\n    df['daily_return'] = df['close'].pct_change()\n    df['shifted_daily_return'] = df['daily_return'].shift(-1)\n    df['ma_5d'] = df['close'].rolling(window=5).mean()  # Calculating 5-day MA\n    df['price_ma_ratio'] = df['close'] / df['ma_5d']\n    heuristics_matrix = (df['shifted_daily_return'] * df['price_ma_ratio']).dropna()\n    return heuristics_matrix",
          "objective": -0.40262,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by incorporating the daily return with the exponential moving average (EMA) of the closing price over the past 10 days, aiming to better reflect the impact of recent price changes on future returns.",
          "code": "def heuristics_v2(df):\n    df['daily_return'] = df['close'].pct_change()\n    df['shifted_daily_return'] = df['daily_return'].shift(-1)\n    df['ema_close_10d'] = df['close'].ewm(span=10).mean()\n    df['price_ratio'] = df['close'] / df['ema_close_10d']\n    heuristics_matrix = (df['shifted_daily_return'] * df['price_ratio']).dropna()\n    return heuristics_matrix",
          "objective": -0.40255,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm incorporates the 5-day moving average (MA) of closing prices and uses it alongside the 10-day volume-weighted average price (VWAP) to predict future returns by calculating a weighted score based on the ratio of the close price to the 5-day MA and the 10-day VWAP.",
          "code": "def heuristics_v2(df):\n    df['daily_return'] = df['close'].pct_change()\n    df['shifted_daily_return'] = df['daily_return'].shift(-1)\n    df['vwap_10d'] = (df['amount'] / df['volume']).rolling(window=10).mean()  # Calculating VWAP\n    df['ma_5d'] = df['close'].rolling(window=5).mean()  # Calculating 5-day MA\n    df['price_ratio_vwap'] = df['close'] / df['vwap_10d']\n    df['price_ratio_ma'] = df['close'] / df['ma_5d']\n    heuristics_matrix = (df['shifted_daily_return'] * (df['price_ratio_vwap'] + df['price_ratio_ma'])).dropna()\n    return heuristics_matrix",
          "objective": -0.40224,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm modifies the original by incorporating the volume-weighted average price (VWAP) over a 10-day period into the heuristic, aiming to reflect the impact of both recent price and volume changes on future returns.",
          "code": "def heuristics_v2(df):\n    df['daily_return'] = df['close'].pct_change()\n    df['shifted_daily_return'] = df['daily_return'].shift(-1)\n    df['vwap_10d'] = (df['amount'] / df['volume']).rolling(window=10).mean()  # Calculating VWAP\n    df['price_ratio'] = df['close'] / df['vwap_10d']\n    heuristics_matrix = (df['shifted_daily_return'] * df['price_ratio']).dropna()\n    return heuristics_matrix",
          "objective": -0.40184,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm incorporates the ratio of the current closing price to the 10-day simple moving average (SMA) of the closing prices, aiming to capture the impact of recent price trends on future returns.",
          "code": "def heuristics_v2(df):\n    df['daily_return'] = df['close'].pct_change()\n    df['shifted_daily_return'] = df['daily_return'].shift(-1)\n    df['sma_10d'] = df['close'].rolling(window=10).mean()  # Calculating 10-day SMA\n    df['price_ratio'] = df['close'] / df['sma_10d']\n    heuristics_matrix = (df['shifted_daily_return'] * df['price_ratio']).dropna()\n    return heuristics_matrix",
          "objective": -0.40156,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor by incorporating the daily return with the ratio of today's low price to the 10-day average low price, focusing on the relationship between downward price movements and recent lower price levels.",
          "code": "def heuristics_v2(df):\n    df['daily_return'] = df['close'].pct_change()\n    df['shifted_daily_return'] = df['daily_return'].shift(-1)\n    df['avg_low_10d'] = df['low'].rolling(window=10).mean()\n    df['low_ratio'] = df['low'] / df['avg_low_10d']\n    heuristics_matrix = (df['shifted_daily_return'] * df['low_ratio']).dropna()\n    return heuristics_matrix",
          "objective": -0.40151,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor by combining the daily return with the ratio of today's high price to the 10-day average high price, aiming to capture the interaction between price movement and recent price levels.",
          "code": "def heuristics_v2(df):\n    df['daily_return'] = df['close'].pct_change()\n    df['shifted_daily_return'] = df['daily_return'].shift(-1)\n    df['avg_high_10d'] = df['high'].rolling(window=10).mean()\n    df['high_ratio'] = df['high'] / df['avg_high_10d']\n    heuristics_matrix = (df['shifted_daily_return'] * df['high_ratio']).dropna()\n    return heuristics_matrix",
          "objective": -0.4014,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a modified heuristic factor by integrating the daily return with the exponential moving average of the RSI over the past 28 days, aiming to capture a more weighted recent momentum and overbought/oversold conditions.",
          "code": "def heuristics_v2(df):\n    df['daily_return'] = df['close'].pct_change()\n    df['shifted_daily_return'] = df['daily_return'].shift(-1)\n    delta = df['close'].diff()\n    gain = delta.where(delta > 0, 0)\n    loss = -delta.where(delta < 0, 0)\n    avg_gain = gain.ewm(span=28, adjust=False).mean()\n    avg_loss = loss.ewm(span=28, adjust=False).mean()\n    rs = avg_gain / avg_loss\n    rsi_28d_ema = 100 - (100 / (1 + rs))\n    df['rsi_28d_ema'] = rsi_28d_ema\n    heuristics_matrix = (df['shifted_daily_return'] * df['rsi_28d_ema']).dropna()\n    return heuristics_matrix",
          "objective": -0.3904,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by combining the daily return with the weighted average volume over the past 5 days, where the weights are the inverse of the trading day's distance from today, aiming to better capture the significance of recent volume changes on future returns.",
          "code": "def heuristics_v2(df):\n    df['daily_return'] = df['close'].pct_change()\n    df['shifted_daily_return'] = df['daily_return'].shift(-1)\n    weights = [1, 2, 3, 4, 5]\n    df['weighted_avg_volume_5d'] = df['volume'].rolling(window=5).apply(lambda x: sum(w * v for w, v in zip(weights, x)) / sum(weights), raw=True)\n    df['volume_ratio'] = df['volume'] / df['weighted_avg_volume_5d']\n    heuristics_matrix = (df['shifted_daily_return'] * df['volume_ratio']).dropna()\n    return heuristics_matrix",
          "objective": -0.38823,
          "other_inf": null
     }
]