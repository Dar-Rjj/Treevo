[
     {
          "algorithm": "The new algorithm calculates a factor by integrating the exponential moving average (EMA) of the trading amount, the ratio of the closing price to its EMA, and an additional term that adjusts for the deviation of the closing price from its simple moving average (SMA), aiming to incorporate both liquidity, trend, and recent price fluctuations.",
          "code": "def heuristics_v2(df):\n    window_size = 20\n    df['ema_close'] = df['close'].ewm(span=window_size, adjust=False).mean()\n    df['ema_amount'] = df['amount'].ewm(span=window_size, adjust=False).mean()\n    df['sma_close'] = df['close'].rolling(window=window_size).mean()\n    adjustment_factor = (df['close'] - df['sma_close']) / df['close']\n    heuristics_matrix = df['ema_amount'] * (df['close'] / df['ema_close']) * (1 + adjustment_factor)\n    return heuristics_matrix",
          "objective": -0.03758,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor based on the weighted sum of the EMA of the trading amount and the EMA of the volume, with each component adjusted by the ratio of the closing price to its EMA, aiming to capture liquidity and transaction activity.",
          "code": "def heuristics_v2(df):\n    window_size = 20\n    df['ema_close'] = df['close'].ewm(span=window_size, adjust=False).mean()\n    df['ema_amount'] = df['amount'].ewm(span=window_size, adjust=False).mean()\n    df['ema_volume'] = df['volume'].ewm(span=window_size, adjust=False).mean()\n    heuristics_matrix = (df['ema_amount'] + df['ema_volume']) * (df['close'] / df['ema_close'])\n    return heuristics_matrix",
          "objective": -0.03665,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor based on the exponential moving average (EMA) of the trading amount and the ratio of the closing price to the EMA of the closing price, aiming to capture both liquidity and price trend information.",
          "code": "def heuristics_v2(df):\n    # Define the lookback window for calculations\n    window_size = 20\n    \n    # Calculate the exponential moving average (EMA) of the closing price\n    df['ema_close'] = df['close'].ewm(span=window_size, adjust=False).mean()\n    \n    # Calculate the EMA of the trading amount\n    df['ema_amount'] = df['amount'].ewm(span=window_size, adjust=False).mean()\n    \n    # Construct the heuristics matrix by combining the EMA of the trading amount and the ratio of the closing price to its EMA\n    heuristics_matrix = df['ema_amount'] * (df['close'] / df['ema_close'])\n    \n    return heuristics_matrix",
          "objective": -0.03662,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm introduces a weighted sum of the EMA of the trading amount and the ratio of the closing price to its EMA, where weights are determined by the standard deviation of the closing prices over the lookback window, aiming to capture liquidity and trend adjusted for volatility.",
          "code": "def heuristics_v2(df):\n    window_size = 20\n    df['ema_close'] = df['close'].ewm(span=window_size, adjust=False).mean()\n    df['ema_amount'] = df['amount'].ewm(span=window_size, adjust=False).mean()\n    std_close = df['close'].rolling(window=window_size).std()\n    weight_close_ratio = std_close / (std_close + df['amount'].rolling(window=window_size).std())\n    heuristics_matrix = (df['close'] / df['ema_close']) * weight_close_ratio + df['ema_amount'] * (1 - weight_close_ratio)\n    return heuristics_matrix",
          "objective": -0.03659,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm adjusts the calculation by using a 30-day window for EMA and SMA, integrating the ratio of the closing price to its EMA, and modifying the adjustment factor to account for the deviation of the volume from its simple moving average (SMA) instead of the closing price.",
          "code": "def heuristics_v2(df):\n    window_size = 30\n    df['ema_close'] = df['close'].ewm(span=window_size, adjust=False).mean()\n    df['sma_close'] = df['close'].rolling(window=window_size).mean()\n    df['ema_amount'] = df['amount'].ewm(span=window_size, adjust=False).mean()\n    df['sma_volume'] = df['volume'].rolling(window=window_size).mean()\n    adjustment_factor = (df['volume'] - df['sma_volume']) / df['volume']\n    heuristics_matrix = df['ema_amount'] * (df['close'] / df['ema_close']) * (1 + adjustment_factor)\n    return heuristics_matrix",
          "objective": -0.03116,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm, named AlphaRefined, computes the percentage change in closing prices, applies an exponentially weighted moving average to this change, and combines it with a momentum indicator based on the ratio of average high to average low over a fixed period.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate percentage change in close price\n    df['pct_change_close'] = df['close'].pct_change()\n    \n    # Compute exponentially weighted moving average\n    span = 30\n    df['ewma'] = df['pct_change_close'].ewm(span=span, adjust=False).mean()\n    \n    # Add momentum indicator: ratio of rolling mean of high/low\n    df['momentum'] = df['high'].rolling(window=span).mean() / df['low'].rolling(window=span).mean()\n    \n    # Heuristic formula: Exponentially Weighted Moving Average + Momentum\n    heuristics_matrix = df['ewma'] + df['momentum']\n    \n    return heuristics_matrix",
          "objective": -0.02625,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm, named AlphaHeuristics, identifies potential alpha factors by first calculating the percentage change in closing prices over a fixed period, then applying a weighted moving average to this change using trade volume as weights, and finally, adding a momentum indicator calculated from the high and low prices.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate percentage change in close price\n    df['pct_change_close'] = df['close'].pct_change()\n    \n    # Compute weighted moving average with 'volume' as weights\n    window_size = 30\n    df['wma'] = (df['pct_change_close'] * df['volume']).rolling(window=window_size).sum() / df['volume'].rolling(window=window_size).sum()\n    \n    # Add momentum indicator: ratio of high/low over a period\n    df['momentum'] = df['high'].rolling(window=window_size).mean() / df['low'].rolling(window=window_size).mean()\n    \n    # Heuristic formula: Weighted Moving Average + Momentum\n    heuristics_matrix = df['wma'] + df['momentum']\n    \n    return heuristics_matrix",
          "objective": -0.02521,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm leverages the directional movement of stock prices alongside the accumulation and distribution of trading volume to infer future stock price movements.",
          "code": "def heuristics_v2(df):\n    # Calculate daily price change\n    price_change = df['close'].diff(1).fillna(0)\n    \n    # Calculate the difference between high and low as a measure of intraday volatility\n    intraday_volatility = (df['high'] - df['low']).rolling(window=10).mean()\n    \n    # Compute the cumulative difference between up and down days in volume\n    volume_diff = (df['volume'] * (price_change > 0) - df['volume'] * (price_change < 0)).cumsum()\n    \n    # Combine the intraday volatility with the volume difference\n    heuristics_matrix = intraday_volatility * volume_diff\n    \n    return heuristics_matrix",
          "objective": -0.0249,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of the intraday price range and the cumulative volume difference over a 20-day window, using a custom weighting scheme to emphasize recent data.",
          "code": "def heuristics_v2(df):\n    # Calculate daily price change\n    price_change = df['close'].diff(1).fillna(0)\n    \n    # Calculate the difference between high and low as a measure of intraday volatility, with a 20-day rolling mean\n    intraday_volatility = (df['high'] - df['low']).rolling(window=20).mean()\n    \n    # Compute the cumulative difference between up and down days in volume\n    volume_diff = (df['volume'] * (price_change > 0) - df['volume'] * (price_change < 0)).cumsum()\n    \n    # Apply an exponential moving average to the intraday volatility for emphasis on recent data\n    ema_intraday_volatility = intraday_volatility.ewm(span=20, adjust=False).mean()\n    \n    # Combine the EMA-adjusted intraday volatility with the volume difference\n    heuristics_matrix = ema_intraday_volatility * volume_diff\n    \n    return heuristics_matrix",
          "objective": -0.02463,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm, named AlphaRefinedPlus, calculates the percentage change in closing prices, applies a 60-day exponentially weighted moving average to this change, and combines it with a momentum indicator based on the ratio of the 60-day rolling mean of high to the 60-day rolling mean of low.",
          "code": "def heuristics_v2(df):\n    # Calculate percentage change in close price\n    df['pct_change_close'] = df['close'].pct_change()\n    \n    # Compute exponentially weighted moving average\n    span = 60\n    df['ewma'] = df['pct_change_close'].ewm(span=span, adjust=False).mean()\n    \n    # Add momentum indicator: ratio of rolling mean of high/low\n    df['momentum'] = df['high'].rolling(window=span).mean() / df['low'].rolling(window=span).mean()\n    \n    # Heuristic formula: Exponentially Weighted Moving Average + Momentum\n    heuristics_matrix = df['ewma'] + df['momentum']\n    \n    return heuristics_matrix",
          "objective": -0.02414,
          "other_inf": null
     }
]