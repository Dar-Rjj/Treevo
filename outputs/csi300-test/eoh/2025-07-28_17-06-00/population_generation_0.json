[
     {
          "algorithm": "The algorithm, named AlphaHeuristics, identifies potential alpha factors by first calculating the percentage change in closing prices over a fixed period, then applying a weighted moving average to this change using trade volume as weights, and finally, adding a momentum indicator calculated from the high and low prices.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate percentage change in close price\n    df['pct_change_close'] = df['close'].pct_change()\n    \n    # Compute weighted moving average with 'volume' as weights\n    window_size = 30\n    df['wma'] = (df['pct_change_close'] * df['volume']).rolling(window=window_size).sum() / df['volume'].rolling(window=window_size).sum()\n    \n    # Add momentum indicator: ratio of high/low over a period\n    df['momentum'] = df['high'].rolling(window=window_size).mean() / df['low'].rolling(window=window_size).mean()\n    \n    # Heuristic formula: Weighted Moving Average + Momentum\n    heuristics_matrix = df['wma'] + df['momentum']\n    \n    return heuristics_matrix",
          "objective": -0.02521,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies patterns in the historical market data through a combination of moving averages and relative strength computations, aiming to forecast future stock returns by creating an interpretable alpha factor.",
          "code": "def heuristics_v2(df):\n    # Calculate short-term and long-term moving averages\n    df['MA_short'] = df['close'].rolling(window=10).mean()\n    df['MA_long'] = df['close'].rolling(window=50).mean()\n    # Compute the relative strength indicator (RSI) without normalization\n    delta = df['close'].diff(1)\n    gain = (delta.where(delta > 0, 0)).fillna(0)\n    loss = (-delta.where(delta < 0, 0)).fillna(0)\n    avg_gain = gain.rolling(window=14).mean()\n    avg_loss = loss.rolling(window=14).mean()\n    RS = avg_gain / avg_loss\n    RSI = 100 - (100 / (1 + RS))\n    # Combine MA crossover signal with RSI for the heuristics matrix\n    df['Signal'] = (df['MA_short'] > df['MA_long']).astype(int)\n    heuristics_matrix = df['Signal'] * (100 - RSI)\n    return heuristics_matrix",
          "objective": -0.01383,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a novel alpha factor by combining weighted moving averages of the closing price and volume, along with the rate of change in the amount over a fixed period, to infer momentum and liquidity signals.",
          "code": "def heuristics_v2(df):\n    close = df['close']\n    volume = df['volume']\n    amount = df['amount']\n    \n    # Weighted moving average for closing price and volume\n    wma_close = close.rolling(window=10).mean()\n    wma_volume = volume.rolling(window=10).mean()\n    \n    # Rate of change in amount\n    roc_amount = (amount - amount.shift(10)) / amount.shift(10)\n    \n    # Alpha factor as a combination of WMA close, WMA volume, and ROC amount\n    heuristics_matrix = (wma_close + wma_volume) * roc_amount\n    \n    return heuristics_matrix",
          "objective": -0.01309,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm involves generating a set of heuristics by combining various market features in a non-linear manner to create a new alpha factor aimed at predicting stock returns.",
          "code": "def heuristics_v2(df):\n    heuristics_matrix = (df['close'] - df['open']) / df['volume'] + df['high'] / df['low'] - (df['amount'] / df['close'])\n    return heuristics_matrix",
          "objective": -0.01265,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a momentum-based heuristic factor by combining the relative strength of the closing price compared to the moving average over different periods, enhancing interpretability through a weighted sum of these strengths.",
          "code": "def heuristics_v2(df):\n    def calculate_strength(price, ma):\n        return (price - ma) / ma\n\n    short_ma = df['close'].rolling(window=5).mean()\n    medium_ma = df['close'].rolling(window=20).mean()\n    long_ma = df['close'].rolling(window=60).mean()\n\n    short_strength = calculate_strength(df['close'], short_ma)\n    medium_strength = calculate_strength(df['close'], medium_ma)\n    long_strength = calculate_strength(df['close'], long_ma)\n\n    heuristics_matrix = 0.3 * short_strength + 0.4 * medium_strength + 0.3 * long_strength\n    return heuristics_matrix",
          "objective": -0.00838,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm leverages a combination of momentum, volatility, and volume indicators to generate a novel alpha factor without normalizing the data, encapsulating the steps into identifying trend strength, volatility, and liquidity conditions.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Momentum: Using close price shift to calculate simple return\n    df['momentum'] = df['close'].pct_change()\n    \n    # Volatility: Standard deviation of daily returns over a 30-day window\n    df['volatility'] = df['close'].pct_change().rolling(window=30).std()\n    \n    # Liquidity: Volume weighted by closing price\n    df['liquidity'] = df['volume'] * df['close']\n    \n    # Combine factors into a single heuristic\n    df['heuristic_score'] = df['momentum'] / (df['volatility'] + 1) * df['liquidity']\n    \n    # Extract the heuristic score series\n    heuristics_matrix = df['heuristic_score']\n    \n    return heuristics_matrix",
          "objective": -0.00752,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates the weighted moving average of closing prices and volume, then combines these with a momentum indicator to generate a novel alpha factor.",
          "code": "def heuristics_v2(df):\n    close = df['close']\n    volume = df['volume']\n    wma_close = close.rolling(window=10).apply(lambda x: (x * range(1, 11)).sum() / sum(range(1, 11)), raw=True)\n    wma_volume = volume.rolling(window=10).apply(lambda x: (x * range(1, 11)).sum() / sum(range(1, 11)), raw=True)\n    momentum = (df['close'] / df['close'].shift(5)) - 1\n    heuristics_matrix = (wma_close + wma_volume) * momentum\n    return heuristics_matrix",
          "objective": -0.00717,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies patterns in the relationship between trading volume and price movements, constructing a heuristic factor that reflects the momentum and volatility of the stock by analyzing the ratio of volume changes to price differences over time.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    df['volume_change'] = df['volume'].pct_change()\n    df['price_diff'] = df['close'].diff()\n    heuristics_matrix = (df['volume_change'] / df['price_diff']).fillna(0)\n    return heuristics_matrix",
          "objective": -0.00683,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies patterns in market features over time to generate a heuristics matrix that captures potential alpha factors by analyzing the relationship between volume and price movements.",
          "code": "def heuristics_v2(df):\n    # Calculate daily return\n    df['daily_return'] = df['close'].pct_change()\n    # Shift volume to align with next day's return\n    df['shifted_volume'] = df['volume'].shift(-1)\n    # Define a heuristic factor as the product of daily return and shifted volume\n    heuristics_matrix = df['daily_return'] * df['shifted_volume']\n    return heuristics_matrix",
          "objective": -0.00638,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a momentum-based alpha factor by comparing the current closing price with the average of the highest and lowest prices over the past N days, aiming to capture both short-term volatility and trend persistence.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    N = 5  # Number of days for the rolling window\n    avg_high_low = (df['high'].rolling(window=N).mean() + df['low'].rolling(window=N).mean()) / 2\n    heuristics_matrix = (df['close'] - avg_high_low) / avg_high_low\n    return heuristics_matrix",
          "objective": -0.00447,
          "other_inf": null
     }
]