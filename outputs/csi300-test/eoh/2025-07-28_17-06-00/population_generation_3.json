[
     {
          "algorithm": "The new algorithm calculates a factor by integrating the exponential moving average (EMA) of the trading amount, the ratio of the closing price to its EMA, and an additional term that adjusts for the deviation of the closing price from its simple moving average (SMA), aiming to incorporate both liquidity, trend, and recent price fluctuations.",
          "code": "def heuristics_v2(df):\n    window_size = 20\n    df['ema_close'] = df['close'].ewm(span=window_size, adjust=False).mean()\n    df['ema_amount'] = df['amount'].ewm(span=window_size, adjust=False).mean()\n    df['sma_close'] = df['close'].rolling(window=window_size).mean()\n    adjustment_factor = (df['close'] - df['sma_close']) / df['close']\n    heuristics_matrix = df['ema_amount'] * (df['close'] / df['ema_close']) * (1 + adjustment_factor)\n    return heuristics_matrix",
          "objective": -0.03758,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor by combining the rate of change (ROC) of the EMA of the closing price with the difference between the EMA of the trading amount and the EMA of the volume, adjusted by the ratio of the closing price to its simple moving average (SMA), to reflect momentum and liquidity.",
          "code": "def heuristics_v2(df):\n    window_size = 20\n    df['ema_close'] = df['close'].ewm(span=window_size, adjust=False).mean()\n    df['sma_close'] = df['close'].rolling(window=window_size).mean()\n    df['roc_ema_close'] = df['ema_close'].pct_change()\n    df['ema_amount'] = df['amount'].ewm(span=window_size, adjust=False).mean()\n    df['ema_volume'] = df['volume'].ewm(span=window_size, adjust=False).mean()\n    heuristics_matrix = df['roc_ema_close'] + (df['ema_amount'] - df['ema_volume']) * (df['close'] / df['sma_close'])\n    return heuristics_matrix",
          "objective": -0.03668,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor based on the weighted sum of the EMA of the trading amount and the EMA of the volume, with each component adjusted by the ratio of the closing price to its EMA, aiming to capture liquidity and transaction activity.",
          "code": "def heuristics_v2(df):\n    window_size = 20\n    df['ema_close'] = df['close'].ewm(span=window_size, adjust=False).mean()\n    df['ema_amount'] = df['amount'].ewm(span=window_size, adjust=False).mean()\n    df['ema_volume'] = df['volume'].ewm(span=window_size, adjust=False).mean()\n    heuristics_matrix = (df['ema_amount'] + df['ema_volume']) * (df['close'] / df['ema_close'])\n    return heuristics_matrix",
          "objective": -0.03665,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor based on the exponential moving average (EMA) of the trading amount and the ratio of the closing price to the EMA of the closing price, aiming to capture both liquidity and price trend information.",
          "code": "def heuristics_v2(df):\n    # Define the lookback window for calculations\n    window_size = 20\n    \n    # Calculate the exponential moving average (EMA) of the closing price\n    df['ema_close'] = df['close'].ewm(span=window_size, adjust=False).mean()\n    \n    # Calculate the EMA of the trading amount\n    df['ema_amount'] = df['amount'].ewm(span=window_size, adjust=False).mean()\n    \n    # Construct the heuristics matrix by combining the EMA of the trading amount and the ratio of the closing price to its EMA\n    heuristics_matrix = df['ema_amount'] * (df['close'] / df['ema_close'])\n    \n    return heuristics_matrix",
          "objective": -0.03662,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm introduces a weighted sum of the EMA of the trading amount and the ratio of the closing price to its EMA, where weights are determined by the standard deviation of the closing prices over the lookback window, aiming to capture liquidity and trend adjusted for volatility.",
          "code": "def heuristics_v2(df):\n    window_size = 20\n    df['ema_close'] = df['close'].ewm(span=window_size, adjust=False).mean()\n    df['ema_amount'] = df['amount'].ewm(span=window_size, adjust=False).mean()\n    std_close = df['close'].rolling(window=window_size).std()\n    weight_close_ratio = std_close / (std_close + df['amount'].rolling(window=window_size).std())\n    heuristics_matrix = (df['close'] / df['ema_close']) * weight_close_ratio + df['ema_amount'] * (1 - weight_close_ratio)\n    return heuristics_matrix",
          "objective": -0.03659,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor by combining the rate of change (ROC) of the simple moving average (SMA) of the closing price with the difference between the SMA of the trading amount and the SMA of the volume, adjusted by the ratio of the closing price to its exponential moving average (EMA), to reflect momentum and liquidity.",
          "code": "def heuristics_v2(df):\n    window_size = 10\n    df['sma_close'] = df['close'].rolling(window=window_size).mean()\n    df['ema_close'] = df['close'].ewm(span=window_size, adjust=False).mean()\n    df['roc_sma_close'] = df['sma_close'].pct_change()\n    df['sma_amount'] = df['amount'].rolling(window=window_size).mean()\n    df['sma_volume'] = df['volume'].rolling(window=window_size).mean()\n    heuristics_matrix = df['roc_sma_close'] + (df['sma_amount'] - df['sma_volume']) * (df['close'] / df['ema_close'])\n    return heuristics_matrix",
          "objective": -0.03521,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm adjusts the calculation by using a 30-day window for EMA and SMA, integrating the ratio of the closing price to its EMA, and modifying the adjustment factor to account for the deviation of the volume from its simple moving average (SMA) instead of the closing price.",
          "code": "def heuristics_v2(df):\n    window_size = 30\n    df['ema_close'] = df['close'].ewm(span=window_size, adjust=False).mean()\n    df['sma_close'] = df['close'].rolling(window=window_size).mean()\n    df['ema_amount'] = df['amount'].ewm(span=window_size, adjust=False).mean()\n    df['sma_volume'] = df['volume'].rolling(window=window_size).mean()\n    adjustment_factor = (df['volume'] - df['sma_volume']) / df['volume']\n    heuristics_matrix = df['ema_amount'] * (df['close'] / df['ema_close']) * (1 + adjustment_factor)\n    return heuristics_matrix",
          "objective": -0.03116,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of the intraday price range and the cumulative volume difference over a 20-day window, using a custom weighting scheme to emphasize recent data, but incorporates a relative strength index (RSI) for the closing prices to better capture momentum.",
          "code": "def heuristics_v2(df):\n    # Calculate daily price change\n    price_change = df['close'].diff(1).fillna(0)\n    \n    # Calculate the difference between high and low as a measure of intraday volatility, with a 20-day rolling mean\n    intraday_volatility = (df['high'] - df['low']).rolling(window=20).mean()\n    \n    # Compute the cumulative difference between up and down days in volume\n    volume_diff = (df['volume'] * (price_change > 0) - df['volume'] * (price_change < 0)).cumsum()\n    \n    # Apply an exponential moving average to the intraday volatility for emphasis on recent data\n    ema_intraday_volatility = intraday_volatility.ewm(span=20, adjust=False).mean()\n    \n    # Calculate the Relative Strength Index (RSI) for the closing prices over a 14-day period\n    gain = df['close'].diff(1).apply(lambda x: max(x, 0))\n    loss = df['close'].diff(1).apply(lambda x: abs(min(x, 0)))\n    avg_gain = gain.rolling(window=14).mean()\n    avg_loss = loss.rolling(window=14).mean()\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Combine the EMA-adjusted intraday volatility, volume difference, and RSI\n    heuristics_matrix = ema_intraday_volatility * volume_diff * rsi\n    \n    return heuristics_matrix",
          "objective": -0.02984,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted sum of the intraday price range and the cumulative volume difference over a 30-day window, using a custom weighting scheme to emphasize recent data, but incorporates a relative strength index (RSI) for the closing prices to better capture momentum, with RSI calculated over a 21-day period.",
          "code": "def heuristics_v2(df):\n    # Calculate daily price change\n    price_change = df['close'].diff(1).fillna(0)\n    \n    # Calculate the difference between high and low as a measure of intraday volatility, with a 30-day rolling mean\n    intraday_volatility = (df['high'] - df['low']).rolling(window=30).mean()\n    \n    # Compute the cumulative difference between up and down days in volume\n    volume_diff = (df['volume'] * (price_change > 0) - df['volume'] * (price_change < 0)).cumsum()\n    \n    # Apply an exponential moving average to the intraday volatility for emphasis on recent data\n    ema_intraday_volatility = intraday_volatility.ewm(span=30, adjust=False).mean()\n    \n    # Calculate the Relative Strength Index (RSI) for the closing prices over a 21-day period\n    gain = df['close'].diff(1).apply(lambda x: max(x, 0))\n    loss = df['close'].diff(1).apply(lambda x: abs(min(x, 0)))\n    avg_gain = gain.rolling(window=21).mean()\n    avg_loss = loss.rolling(window=21).mean()\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Combine the EMA-adjusted intraday volatility, volume difference, and RSI\n    heuristics_matrix = ema_intraday_volatility * volume_diff * rsi\n    \n    return heuristics_matrix",
          "objective": -0.02768,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm, named AlphaRefined, computes the percentage change in closing prices, applies an exponentially weighted moving average to this change, and combines it with a momentum indicator based on the ratio of average high to average low over a fixed period.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate percentage change in close price\n    df['pct_change_close'] = df['close'].pct_change()\n    \n    # Compute exponentially weighted moving average\n    span = 30\n    df['ewma'] = df['pct_change_close'].ewm(span=span, adjust=False).mean()\n    \n    # Add momentum indicator: ratio of rolling mean of high/low\n    df['momentum'] = df['high'].rolling(window=span).mean() / df['low'].rolling(window=span).mean()\n    \n    # Heuristic formula: Exponentially Weighted Moving Average + Momentum\n    heuristics_matrix = df['ewma'] + df['momentum']\n    \n    return heuristics_matrix",
          "objective": -0.02625,
          "other_inf": null
     }
]