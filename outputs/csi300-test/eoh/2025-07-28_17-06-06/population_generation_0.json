[
     {
          "algorithm": "The algorithm identifies patterns in historical stock data by computing the difference between the highest high and lowest low over a rolling window, then dividing this difference by the closing price to generate an interpretable alpha factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    df['RollingHigh'] = df['high'].rolling(window=20).max()\n    df['RollingLow'] = df['low'].rolling(window=20).min()\n    heuristics_matrix = (df['RollingHigh'] - df['RollingLow']) / df['close']\n    return heuristics_matrix",
          "objective": -0.02176,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a proprietary heuristic factor based on the weighted combination of market features, where the weights are dynamically adjusted by recent price movements and trading volume trends.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily return and volume change\n    df['daily_return'] = df['close'].pct_change()\n    df['volume_change'] = df['volume'].pct_change()\n    \n    # Assign weights based on the magnitude of daily return and volume change\n    df['price_weight'] = (df['daily_return'].abs() / df['daily_return'].abs().rolling(window=30).mean()).fillna(0)\n    df['volume_weight'] = (df['volume_change'].abs() / df['volume_change'].abs().rolling(window=30).mean()).fillna(0)\n    \n    # Calculate the weighted sum of features\n    df['weighted_sum'] = (df['open'] * df['price_weight'] + \n                          df['high'] * df['volume_weight'] + \n                          df['low'] * (1 - df['price_weight']) + \n                          df['close'] * (1 - df['volume_weight']))\n    \n    # Create the heuristics matrix\n    heuristics_matrix = df['weighted_sum']\n    \n    return heuristics_matrix",
          "objective": -0.01814,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm involves constructing a novel alpha factor by combining moving averages and volatility indicators, then evaluating their cross-sectional relationships to generate heuristics scores.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate 50-day and 200-day moving averages for the closing price\n    ma_50 = df['close'].rolling(window=50).mean()\n    ma_200 = df['close'].rolling(window=200).mean()\n    \n    # Calculate the standard deviation of the closing price over a 50-day period\n    std_50 = df['close'].rolling(window=50).std()\n    \n    # Create a signal based on the difference between the two moving averages\n    signal = ma_50 - ma_200\n    \n    # Create a heuristic score by dividing the signal by the standard deviation\n    heuristics_matrix = (signal / std_50).dropna()\n    \n    return heuristics_matrix",
          "objective": -0.01285,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a novel alpha factor by calculating the exponential moving average (EMA) crossover of the high and low prices, then subtracting the EMA of the volume from it to create a heuristics matrix indicating potential momentum shifts.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    short_ema_high = df['high'].ewm(span=10, adjust=False).mean()\n    long_ema_high = df['high'].ewm(span=30, adjust=False).mean()\n    short_ema_low = df['low'].ewm(span=10, adjust=False).mean()\n    long_ema_low = df['low'].ewm(span=30, adjust=False).mean()\n    ema_volume = df['volume'].ewm(span=20, adjust=False).mean()\n    crossover_high = short_ema_high - long_ema_high\n    crossover_low = short_ema_low - long_ema_low\n    heuristics_matrix = (crossover_high - crossover_low) - ema_volume\n    return heuristics_matrix",
          "objective": -0.0108,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a heuristic factor based on the interaction between volume and price changes, aiming to capture the momentum and volume trends without normalization.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Compute the daily return\n    daily_return = df['close'].pct_change()\n    # Compute the difference in volume\n    volume_diff = df['volume'].diff()\n    # Heuristic factor: daily return multiplied by the change in volume\n    heuristics_matrix = daily_return * volume_diff\n    return heuristics_matrix",
          "objective": -0.00875,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm involves calculating a weighted moving average of the stock's closing price with dynamic weights based on trading volume, then subtracting a simple moving average of the high and low prices to generate an interpretable alpha factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the weighted moving average of close prices using volume as weights\n    wma_close = (df['close'] * df['volume']).rolling(window=20).sum() / df['volume'].rolling(window=20).sum()\n    # Calculate the simple moving average of the high and low prices\n    sma_high_low = (df['high'] + df['low']) / 2\n    sma_high_low = sma_high_low.rolling(window=20).mean()\n    # Generate the heuristic factor\n    heuristics_matrix = wma_close - sma_high_low\n    return heuristics_matrix",
          "objective": -0.00638,
          "other_inf": null
     },
     {
          "algorithm": "A novel algorithm that combines moving average convergence divergence (MACD) with a relative strength index (RSI) to generate alpha factors, by first calculating the MACD and RSI from the close prices, then applying a heuristics-based weighting scheme to synthesize these indicators into a single, interpretable factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def macd_series(price, fast=12, slow=26, signal=9):\n        exp1 = price.ewm(span=fast, adjust=False).mean()\n        exp2 = price.ewm(span=slow, adjust=False).mean()\n        macd = exp1 - exp2\n        signal_line = macd.ewm(span=signal, adjust=False).mean()\n        return macd - signal_line\n\n    def rsi_series(price, periods=14):\n        delta = price.diff(1)\n        gain = delta.where(delta > 0, 0)\n        loss = -delta.where(delta < 0, 0)\n        avg_gain = gain.rolling(window=periods, min_periods=1).mean()\n        avg_loss = loss.rolling(window=periods, min_periods=1).mean()\n        rs = avg_gain / avg_loss\n        return 100 - (100 / (1 + rs))\n\n    macd = macd_series(df['close'])\n    rsi = rsi_series(df['close'])\n\n    heuristics_matrix = 0.5 * macd + 0.5 * rsi\n    return heuristics_matrix",
          "objective": -0.00338,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm, named Heuristics V2, computes a novel alpha factor by calculating the difference between the exponential moving average of closing prices and the simple moving average of volumes over different time windows, then scaling this difference by the daily return.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    close_ema = df['close'].ewm(span=10, adjust=False).mean()\n    volume_sma = df['volume'].rolling(window=10).mean()\n    daily_return = df['close'].pct_change()\n    heuristics_matrix = (close_ema - volume_sma) * daily_return\n    return heuristics_matrix",
          "objective": -0.00277,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a heuristic factor by calculating the ratio of the difference between the closing and opening prices to the average volume over the last 5 days, aiming to capture momentum influenced by recent trading activity.",
          "code": "def heuristics_v2(df):\n    df['price_diff'] = df['close'] - df['open']\n    df['avg_vol_5d'] = df['volume'].rolling(window=5).mean()\n    heuristics_matrix = (df['price_diff'] / df['avg_vol_5d']).dropna()\n    return heuristics_matrix",
          "objective": -0.00184,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm constructs a novel alpha factor by combining moving averages of different lengths and relative strength index (RSI) to gauge both momentum and mean reversion tendencies, then applies a heuristic formula to generate the final interpretable factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    close = df['close']\n    ma_short = close.rolling(window=10).mean()\n    ma_long = close.rolling(window=50).mean()\n    delta = close.diff()\n    up, down = delta.copy(), delta.copy()\n    up[up < 0] = 0\n    down[down > 0] = 0\n    roll_up = up.rolling(window=14).mean()\n    roll_down = down.abs().rolling(window=14).mean()\n    rs = roll_up / roll_down\n    rsi = 100.0 - (100.0 / (1.0 + rs))\n    heuristics_matrix = (ma_short - ma_long) / close + (rsi - 50) / 50\n    return heuristics_matrix",
          "objective": -0.00146,
          "other_inf": null
     }
]