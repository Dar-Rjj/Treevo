[
     {
          "algorithm": "The new algorithm calculates a novel factor by measuring the relative distance of the closing price to both the 5-day maximum and minimum, then averaging these distances, thereby capturing a more balanced view of the stock's position within its recent price range.",
          "code": "def heuristics_v2(df):\n    df['5d_high'] = df['high'].rolling(window=5).max()\n    df['5d_low'] = df['low'].rolling(window=5).min()\n    df['rel_dist_to_5d_max'] = (df['5d_high'] - df['close']) / (df['5d_high'] - df['5d_low'])\n    df['rel_dist_to_5d_min'] = (df['close'] - df['5d_low']) / (df['5d_high'] - df['5d_low'])\n    df['avg_rel_dist'] = (df['rel_dist_to_5d_max'] + df['rel_dist_to_5d_min']) / 2\n    heuristics_matrix = df['avg_rel_dist'].dropna()\n    return heuristics_matrix",
          "objective": -0.10202,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a novel factor by measuring the exponential moving average (EMA) of the relative distance to 5-day high and low, instead of using a simple average, to give more weight to recent price movements.",
          "code": "def heuristics_v2(df):\n    df['5d_high'] = df['high'].rolling(window=5).max()\n    df['5d_low'] = df['low'].rolling(window=5).min()\n    df['rel_dist_to_5d_max'] = (df['5d_high'] - df['close']) / (df['5d_high'] - df['5d_low'])\n    df['rel_dist_to_5d_min'] = (df['close'] - df['5d_low']) / (df['5d_high'] - df['5d_low'])\n    df['avg_rel_dist_ema'] = df[['rel_dist_to_5d_max', 'rel_dist_to_5d_min']].mean(axis=1).ewm(span=5, adjust=False).mean()\n    heuristics_matrix = df['avg_rel_dist_ema'].dropna()\n    return heuristics_matrix",
          "objective": -0.10192,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the weighted average of the volume and amount over the past 30 days, where weights are determined by the squared difference of the closing price from its 20-day mean, aiming to emphasize larger deviations in price.",
          "code": "def heuristics_v2(df):\n    df['20d_mean_close'] = df['close'].rolling(window=20).mean()\n    df['squared_dist_to_20d_mean'] = (df['close'] - df['20d_mean_close']) ** 2\n    total_weight = df['squared_dist_to_20d_mean'].rolling(window=30).sum()\n    df['weighted_volume'] = df['volume'] * df['squared_dist_to_20d_mean']\n    df['weighted_amount'] = df['amount'] * df['squared_dist_to_20d_mean']\n    df['weighted_avg'] = (df['weighted_volume'].rolling(window=30).sum() + df['weighted_amount'].rolling(window=30).sum()) / total_weight\n    heuristics_matrix = df['weighted_avg'].dropna()\n    return heuristics_matrix",
          "objective": -0.03731,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a weighted average of the volume and amount over the past 30 days, with weights determined by the squared difference of the closing price from its 10-day mean, to emphasize stronger signals of momentum and liquidity.",
          "code": "def heuristics_v2(df):\n    df['10d_mean_close'] = df['close'].rolling(window=10).mean()\n    df['sqr_dist_to_10d_mean'] = (df['close'] - df['10d_mean_close']) ** 2\n    total_weight = df['sqr_dist_to_10d_mean'].rolling(window=30).sum()\n    df['weighted_volume'] = df['volume'] * df['sqr_dist_to_10d_mean']\n    df['weighted_amount'] = df['amount'] * df['sqr_dist_to_10d_mean']\n    df['weighted_avg'] = (df['weighted_volume'].rolling(window=30).sum() + df['weighted_amount'].rolling(window=30).sum()) / total_weight\n    heuristics_matrix = df['weighted_avg'].dropna()\n    return heuristics_matrix",
          "objective": -0.03721,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the weighted average of the volume and amount over the past 30 days, with weights determined by the absolute difference of the closing price from its 20-day mean, focusing on emphasizing significant price deviations without squaring the differences.",
          "code": "def heuristics_v2(df):\n    df['20d_mean_close'] = df['close'].rolling(window=20).mean()\n    df['abs_dist_to_20d_mean'] = abs(df['close'] - df['20d_mean_close'])\n    total_weight = df['abs_dist_to_20d_mean'].rolling(window=30).sum()\n    df['weighted_volume'] = df['volume'] * df['abs_dist_to_20d_mean']\n    df['weighted_amount'] = df['amount'] * df['abs_dist_to_20d_mean']\n    df['weighted_avg'] = (df['weighted_volume'].rolling(window=30).sum() + df['weighted_amount'].rolling(window=30).sum()) / total_weight\n    heuristics_matrix = df['weighted_avg'].dropna()\n    return heuristics_matrix",
          "objective": -0.03702,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes the weighted sum of the past 30 days' volume and amount, with weights determined by the absolute difference between the closing price and its 5-day mean, emphasizing significant price deviations.",
          "code": "def heuristics_v2(df):\n    df['5d_mean_close'] = df['close'].rolling(window=5).mean()\n    df['abs_dist_to_5d_mean'] = (df['close'] - df['5d_mean_close']).abs()\n    total_weight = df['abs_dist_to_5d_mean'].rolling(window=30).sum()\n    df['weighted_volume'] = df['volume'] * df['abs_dist_to_5d_mean']\n    df['weighted_amount'] = df['amount'] * df['abs_dist_to_5d_mean']\n    df['weighted_sum'] = (df['weighted_volume'].rolling(window=30).sum() + df['weighted_amount'].rolling(window=30).sum()) / total_weight\n    heuristics_matrix = df['weighted_sum'].dropna()\n    return heuristics_matrix",
          "objective": -0.03663,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the weighted average of the volume and amount over the past 30 days, where weights are determined by the squared difference of the closing price from its 5-day mean, aiming to give more emphasis on larger deviations and shorter-term momentum.",
          "code": "def heuristics_v2(df):\n    df['5d_mean_close'] = df['close'].rolling(window=5).mean()\n    df['sq_dist_to_5d_mean'] = (df['close'] - df['5d_mean_close'])**2\n    total_weight = df['sq_dist_to_5d_mean'].rolling(window=30).sum()\n    df['weighted_volume'] = df['volume'] * df['sq_dist_to_5d_mean']\n    df['weighted_amount'] = df['amount'] * df['sq_dist_to_5d_mean']\n    df['weighted_avg'] = (df['weighted_volume'].rolling(window=30).sum() + df['weighted_amount'].rolling(window=30).sum()) / total_weight\n    heuristics_matrix = df['weighted_avg'].dropna()\n    return heuristics_matrix",
          "objective": -0.03659,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic score by integrating the 5-day moving average (MA) of low prices with the 30-day Exponential Moving Average (EMA) of volume, adjusting the focus towards shorter-term price movements and longer-term liquidity trends.",
          "code": "def heuristics_v2(df):\n    # Calculate the 5-day Moving Average (MA) of low prices\n    ma_low = df['low'].rolling(window=5).mean()\n    \n    # Calculate the 30-day Exponential Moving Average (EMA) of volume\n    ema_volume = df['volume'].ewm(span=30, adjust=False).mean()\n    \n    # Create a heuristic score by combining MA of low prices and EMA of volume\n    heuristics_matrix = (ma_low * ema_volume).dropna()\n    \n    return heuristics_matrix",
          "objective": -0.03609,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic score by integrating the 10-day moving average (MA) of high prices with the 20-day Exponential Moving Average (EMA) of volume, capturing both trend and liquidity effects.",
          "code": "def heuristics_v2(df):\n    # Calculate the 10-day Moving Average (MA) of high prices\n    ma_high = df['high'].rolling(window=10).mean()\n    \n    # Calculate the 20-day Exponential Moving Average (EMA) of volume\n    ema_volume = df['volume'].ewm(span=20, adjust=False).mean()\n    \n    # Create a heuristic score by combining MA of high prices and EMA of volume\n    heuristics_matrix = (ma_high * ema_volume).dropna()\n    \n    return heuristics_matrix",
          "objective": -0.03605,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the weighted average of the volume and amount over the past 20 days, where weights are determined by the absolute difference of the closing price from its 10-day mean, aiming to capture liquidity and momentum effects with a focus on price deviations.",
          "code": "def heuristics_v2(df):\n    df['10d_mean_close'] = df['close'].rolling(window=10).mean()\n    df['abs_dist_to_10d_mean'] = abs(df['close'] - df['10d_mean_close'])\n    total_weight = df['abs_dist_to_10d_mean'].rolling(window=20).sum()\n    df['weighted_volume'] = df['volume'] * df['abs_dist_to_10d_mean']\n    df['weighted_amount'] = df['amount'] * df['abs_dist_to_10d_mean']\n    df['weighted_avg'] = (df['weighted_volume'].rolling(window=20).sum() + df['weighted_amount'].rolling(window=20).sum()) / total_weight\n    heuristics_matrix = df['weighted_avg'].dropna()\n    return heuristics_matrix",
          "objective": -0.03591,
          "other_inf": null
     }
]