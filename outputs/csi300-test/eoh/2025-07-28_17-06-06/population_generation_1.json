[
     {
          "algorithm": "The new algorithm calculates a novel factor by measuring the relative distance of the closing price to both the 5-day maximum and minimum, then averaging these distances, thereby capturing a more balanced view of the stock's position within its recent price range.",
          "code": "def heuristics_v2(df):\n    df['5d_high'] = df['high'].rolling(window=5).max()\n    df['5d_low'] = df['low'].rolling(window=5).min()\n    df['rel_dist_to_5d_max'] = (df['5d_high'] - df['close']) / (df['5d_high'] - df['5d_low'])\n    df['rel_dist_to_5d_min'] = (df['close'] - df['5d_low']) / (df['5d_high'] - df['5d_low'])\n    df['avg_rel_dist'] = (df['rel_dist_to_5d_max'] + df['rel_dist_to_5d_min']) / 2\n    heuristics_matrix = df['avg_rel_dist'].dropna()\n    return heuristics_matrix",
          "objective": -0.10202,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies patterns in historical stock data by computing the difference between the highest high and lowest low over a rolling window, then dividing this difference by the closing price to generate an interpretable alpha factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    df['RollingHigh'] = df['high'].rolling(window=20).max()\n    df['RollingLow'] = df['low'].rolling(window=20).min()\n    heuristics_matrix = (df['RollingHigh'] - df['RollingLow']) / df['close']\n    return heuristics_matrix",
          "objective": -0.02176,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm incorporates a dynamic adjustment of weights based on the standard deviation of price and volume changes over a rolling window, then uses these weights to compute a weighted sum of open, high, low, and close prices alongside a smoothed moving average.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily return and volume change\n    df['daily_return'] = df['close'].pct_change()\n    df['volume_change'] = df['volume'].pct_change()\n    \n    # Compute the standard deviation for recent price and volume changes\n    df['price_std'] = df['daily_return'].rolling(window=30).std().fillna(0)\n    df['volume_std'] = df['volume_change'].rolling(window=30).std().fillna(0)\n    \n    # Assign weights dynamically based on the standard deviation of daily return and volume change\n    df['price_weight'] = (df['price_std'] / (df['price_std'] + df['volume_std']))\n    df['volume_weight'] = 1 - df['price_weight']\n    \n    # Calculate the smoothed moving average for close price\n    df['smooth_close'] = df['close'].rolling(window=30).mean().fillna(0)\n    \n    # Calculate the weighted sum of features\n    df['weighted_sum'] = (df['open'] * df['price_weight'] + \n                          df['high'] * df['volume_weight'] + \n                          df['low'] * (1 - df['price_weight']) + \n                          df['smooth_close'] * (1 - df['volume_weight']))\n    \n    # Create the heuristics matrix\n    heuristics_matrix = df['weighted_sum']\n    \n    return heuristics_matrix",
          "objective": -0.01864,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by measuring the average distance of the closing price from the 5-day high and low, giving a sense of how centered or extreme the current price is within its recent range.",
          "code": "def heuristics_v2(df):\n    df['5d_high'] = df['high'].rolling(window=5).max()\n    df['5d_low'] = df['low'].rolling(window=5).min()\n    df['avg_dist_to_5d_extreme'] = (df[['close', '5d_high', '5d_low']]\n                                    .apply(lambda x: (abs(x[0] - x[1]) + abs(x[0] - x[2])) / 2, axis=1))\n    heuristics_matrix = df['avg_dist_to_5d_extreme'].dropna()\n    return heuristics_matrix",
          "objective": -0.01856,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a proprietary heuristic factor based on the weighted combination of market features, where the weights are dynamically adjusted by recent price movements and trading volume trends.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily return and volume change\n    df['daily_return'] = df['close'].pct_change()\n    df['volume_change'] = df['volume'].pct_change()\n    \n    # Assign weights based on the magnitude of daily return and volume change\n    df['price_weight'] = (df['daily_return'].abs() / df['daily_return'].abs().rolling(window=30).mean()).fillna(0)\n    df['volume_weight'] = (df['volume_change'].abs() / df['volume_change'].abs().rolling(window=30).mean()).fillna(0)\n    \n    # Calculate the weighted sum of features\n    df['weighted_sum'] = (df['open'] * df['price_weight'] + \n                          df['high'] * df['volume_weight'] + \n                          df['low'] * (1 - df['price_weight']) + \n                          df['close'] * (1 - df['volume_weight']))\n    \n    # Create the heuristics matrix\n    heuristics_matrix = df['weighted_sum']\n    \n    return heuristics_matrix",
          "objective": -0.01814,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes an alpha factor by calculating the difference between the highest and lowest prices over a 20-day period, then multiplying this difference with the ratio of the current volume to the average volume over the same period.",
          "code": "def heuristics_v2(df):\n    high_rolling_max = df['high'].rolling(window=20).max()\n    low_rolling_min = df['low'].rolling(window=20).min()\n    volume_ratio = df['volume'] / df['volume'].rolling(window=20).mean()\n    heuristics_matrix = (high_rolling_max - low_rolling_min) * volume_ratio\n    return heuristics_matrix",
          "objective": -0.01721,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a novel heuristic factor by measuring the distance between the day's closing price and the nearest 5-day minimum or maximum price, capturing the stock's short-term volatility and position within its recent price range.",
          "code": "def heuristics_v2(df):\n    df['5d_high'] = df['high'].rolling(window=5).max()\n    df['5d_low'] = df['low'].rolling(window=5).min()\n    df['dist_to_5d_extreme'] = (df[['close', '5d_high', '5d_low']]\n                                .apply(lambda x: min(abs(x[0] - x[1]), abs(x[0] - x[2])), axis=1))\n    heuristics_matrix = df['dist_to_5d_extreme'].dropna()\n    return heuristics_matrix",
          "objective": -0.01718,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the alpha factor by determining the difference between the highest and lowest prices over a 20-day period, then adjusting this difference based on the relative change in volume compared to the average, where the adjustment is the ratio of the current day's return (close price divided by the open price) to the average 20-day return.",
          "code": "def heuristics_v2(df):\n    high_rolling_max = df['high'].rolling(window=20).max()\n    low_rolling_min = df['low'].rolling(window=20).min()\n    volume_ratio = df['volume'] / df['volume'].rolling(window=20).mean()\n    daily_return = df['close'] / df['open']\n    avg_daily_return = daily_return.rolling(window=20).mean()\n    return_ratio = daily_return / avg_daily_return\n    heuristics_matrix = (high_rolling_max - low_rolling_min) * volume_ratio * return_ratio\n    return heuristics_matrix",
          "objective": -0.01707,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates 20-day and 100-day moving averages, uses the 20-day period's standard deviation, and then combines these into a heuristic score.",
          "code": "def heuristics_v2(df):\n    # Calculate 20-day and 100-day moving averages for the closing price\n    ma_20 = df['close'].rolling(window=20).mean()\n    ma_100 = df['close'].rolling(window=100).mean()\n    \n    # Calculate the standard deviation of the closing price over a 20-day period\n    std_20 = df['close'].rolling(window=20).std()\n    \n    # Create a signal based on the difference between the two moving averages\n    signal = ma_20 - ma_100\n    \n    # Create a heuristic score by dividing the signal by the standard deviation\n    heuristics_matrix = (signal / std_20).dropna()\n    \n    return heuristics_matrix",
          "objective": -0.01555,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the alpha factor by first determining the difference between the highest and lowest prices over a 20-day window, then dividing this difference by the average closing price over the same period, and finally multiplying the result with the ratio of current volume to the median volume over those 20 days.",
          "code": "def heuristics_v2(df):\n    high_rolling_max = df['high'].rolling(window=20).max()\n    low_rolling_min = df['low'].rolling(window=20).min()\n    avg_close = df['close'].rolling(window=20).mean()\n    volume_ratio = df['volume'] / df['volume'].rolling(window=20).median()\n    heuristics_matrix = ((high_rolling_max - low_rolling_min) / avg_close) * volume_ratio\n    return heuristics_matrix",
          "objective": -0.01542,
          "other_inf": null
     }
]