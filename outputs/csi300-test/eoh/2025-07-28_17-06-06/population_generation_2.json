[
     {
          "algorithm": "The new algorithm calculates a novel factor by measuring the relative distance of the closing price to both the 5-day maximum and minimum, then averaging these distances, thereby capturing a more balanced view of the stock's position within its recent price range.",
          "code": "def heuristics_v2(df):\n    df['5d_high'] = df['high'].rolling(window=5).max()\n    df['5d_low'] = df['low'].rolling(window=5).min()\n    df['rel_dist_to_5d_max'] = (df['5d_high'] - df['close']) / (df['5d_high'] - df['5d_low'])\n    df['rel_dist_to_5d_min'] = (df['close'] - df['5d_low']) / (df['5d_high'] - df['5d_low'])\n    df['avg_rel_dist'] = (df['rel_dist_to_5d_max'] + df['rel_dist_to_5d_min']) / 2\n    heuristics_matrix = df['avg_rel_dist'].dropna()\n    return heuristics_matrix",
          "objective": -0.10202,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a novel factor by measuring the exponential moving average (EMA) of the relative distance to 5-day high and low, instead of using a simple average, to give more weight to recent price movements.",
          "code": "def heuristics_v2(df):\n    df['5d_high'] = df['high'].rolling(window=5).max()\n    df['5d_low'] = df['low'].rolling(window=5).min()\n    df['rel_dist_to_5d_max'] = (df['5d_high'] - df['close']) / (df['5d_high'] - df['5d_low'])\n    df['rel_dist_to_5d_min'] = (df['close'] - df['5d_low']) / (df['5d_high'] - df['5d_low'])\n    df['avg_rel_dist_ema'] = df[['rel_dist_to_5d_max', 'rel_dist_to_5d_min']].mean(axis=1).ewm(span=5, adjust=False).mean()\n    heuristics_matrix = df['avg_rel_dist_ema'].dropna()\n    return heuristics_matrix",
          "objective": -0.10192,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic score by integrating the 14-day moving average (MA) of closing prices with the 14-day RSI, capturing both trend and momentum.",
          "code": "def heuristics_v2(df):\n    # Calculate the 14-day Relative Strength Index (RSI)\n    delta = df['close'].diff(1)\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n\n    # Calculate the 14-day Moving Average (MA) of closing prices\n    ma = df['close'].rolling(window=14).mean()\n\n    # Create a heuristic score by combining RSI and MA\n    heuristics_matrix = (rsi / ma).dropna()\n    \n    return heuristics_matrix",
          "objective": -0.02421,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies patterns in historical stock data by computing the difference between the highest high and lowest low over a rolling window, then dividing this difference by the closing price to generate an interpretable alpha factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    df['RollingHigh'] = df['high'].rolling(window=20).max()\n    df['RollingLow'] = df['low'].rolling(window=20).min()\n    heuristics_matrix = (df['RollingHigh'] - df['RollingLow']) / df['close']\n    return heuristics_matrix",
          "objective": -0.02176,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a novel factor by averaging the relative distance of the closing price to both the 10-day maximum and minimum, providing a balanced view over a longer recent price range.",
          "code": "def heuristics_v2(df):\n    df['10d_high'] = df['high'].rolling(window=10).max()\n    df['10d_low'] = df['low'].rolling(window=10).min()\n    df['rel_dist_to_10d_max'] = (df['10d_high'] - df['close']) / (df['10d_high'] - df['10d_low'])\n    df['rel_dist_to_10d_min'] = (df['close'] - df['10d_low']) / (df['10d_high'] - df['10d_low'])\n    df['avg_rel_dist'] = (df['rel_dist_to_10d_max'] + df['rel_dist_to_10d_min']) / 2\n    heuristics_matrix = df['avg_rel_dist'].dropna()\n    return heuristics_matrix",
          "objective": -0.02144,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the difference between the 10-day rolling maximum high and the 5-day rolling minimum low, then divides this difference by the closing price to generate a factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    df['RollingHigh'] = df['high'].rolling(window=10).max()\n    df['RollingLow'] = df['low'].rolling(window=5).min()\n    heuristics_matrix = (df['RollingHigh'] - df['RollingLow']) / df['close']\n    return heuristics_matrix",
          "objective": -0.0203,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic score by combining the relative strength index (RSI) over a 21-day period with the average true range (ATR) over a 7-day period, adjusting the balance between longer-term momentum and shorter-term volatility.",
          "code": "def heuristics_v2(df):\n    # Calculate the 21-day Relative Strength Index (RSI)\n    delta = df['close'].diff(1)\n    gain = (delta.where(delta > 0, 0)).rolling(window=21).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=21).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n\n    # Calculate the 7-day Average True Range (ATR)\n    tr = df[['high', 'low']].diff().abs().max(axis=1)\n    atr = tr.rolling(window=7).mean()\n\n    # Create a heuristic score by combining RSI and ATR\n    heuristics_matrix = (rsi / atr).dropna()\n    \n    return heuristics_matrix",
          "objective": -0.02022,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic score by combining the relative strength index (RSI) over a 14-day period with the average true range (ATR) over a 14-day period, capturing both momentum and volatility.",
          "code": "def heuristics_v2(df):\n    # Calculate the 14-day Relative Strength Index (RSI)\n    delta = df['close'].diff(1)\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n\n    # Calculate the 14-day Average True Range (ATR)\n    tr = df[['high', 'low']].diff().abs().max(axis=1)\n    atr = tr.rolling(window=14).mean()\n\n    # Create a heuristic score by combining RSI and ATR\n    heuristics_matrix = (rsi / atr).dropna()\n    \n    return heuristics_matrix",
          "objective": -0.01933,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm incorporates a dynamic adjustment of weights based on the standard deviation of price and volume changes over a rolling window, then uses these weights to compute a weighted sum of open, high, low, and close prices alongside a smoothed moving average.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate daily return and volume change\n    df['daily_return'] = df['close'].pct_change()\n    df['volume_change'] = df['volume'].pct_change()\n    \n    # Compute the standard deviation for recent price and volume changes\n    df['price_std'] = df['daily_return'].rolling(window=30).std().fillna(0)\n    df['volume_std'] = df['volume_change'].rolling(window=30).std().fillna(0)\n    \n    # Assign weights dynamically based on the standard deviation of daily return and volume change\n    df['price_weight'] = (df['price_std'] / (df['price_std'] + df['volume_std']))\n    df['volume_weight'] = 1 - df['price_weight']\n    \n    # Calculate the smoothed moving average for close price\n    df['smooth_close'] = df['close'].rolling(window=30).mean().fillna(0)\n    \n    # Calculate the weighted sum of features\n    df['weighted_sum'] = (df['open'] * df['price_weight'] + \n                          df['high'] * df['volume_weight'] + \n                          df['low'] * (1 - df['price_weight']) + \n                          df['smooth_close'] * (1 - df['volume_weight']))\n    \n    # Create the heuristics matrix\n    heuristics_matrix = df['weighted_sum']\n    \n    return heuristics_matrix",
          "objective": -0.01864,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by measuring the average distance of the closing price from the 5-day high and low, giving a sense of how centered or extreme the current price is within its recent range.",
          "code": "def heuristics_v2(df):\n    df['5d_high'] = df['high'].rolling(window=5).max()\n    df['5d_low'] = df['low'].rolling(window=5).min()\n    df['avg_dist_to_5d_extreme'] = (df[['close', '5d_high', '5d_low']]\n                                    .apply(lambda x: (abs(x[0] - x[1]) + abs(x[0] - x[2])) / 2, axis=1))\n    heuristics_matrix = df['avg_dist_to_5d_extreme'].dropna()\n    return heuristics_matrix",
          "objective": -0.01856,
          "other_inf": null
     }
]