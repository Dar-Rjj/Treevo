[
     {
          "algorithm": "The new algorithm calculates a heuristic factor by combining the ratio of the 30-day moving average trading volume to the 150-day moving average, adjusted by the relative change in the closing price over the past 60 days, providing a measure that integrates liquidity and long-term price momentum.",
          "code": "def heuristics_v2(df):\n    avg_vol_30 = df['volume'].rolling(window=30).mean()\n    avg_vol_150 = df['volume'].rolling(window=150).mean()\n    close_change_60 = df['close'].pct_change(periods=60)\n    heuristics_matrix = (avg_vol_30 / avg_vol_150) * (1 + close_change_60)\n    return heuristics_matrix",
          "objective": -0.03302,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by considering the ratio of the 30-day moving average of volume to the 150-day moving average, adjusted by the average percentage change in the closing price over a 20-day period.",
          "code": "def heuristics_v2(df):\n    avg_vol_30 = df['volume'].rolling(window=30).mean()\n    avg_vol_150 = df['volume'].rolling(window=150).mean()\n    close_change_20_avg = df['close'].pct_change(periods=20).rolling(window=20).mean()\n    heuristics_matrix = (avg_vol_30 / avg_vol_150) * (1 + close_change_20_avg)\n    return heuristics_matrix",
          "objective": -0.03065,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by incorporating the relative change in trading volume over the past 30 days compared to the 150-day moving average, and further adjusts this ratio by the percentage change in the high price over the same 30-day period.",
          "code": "def heuristics_v2(df):\n    avg_vol_30 = df['volume'].rolling(window=30).mean()\n    avg_vol_150 = df['volume'].rolling(window=150).mean()\n    high_change_30 = df['high'].pct_change(periods=30)\n    heuristics_matrix = (avg_vol_30 / avg_vol_150) * (1 + high_change_30)\n    return heuristics_matrix",
          "objective": -0.03063,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by incorporating the relative change in trading volume over the past 30 days compared to the 150-day moving average, and further adjusts this ratio by the percentage change in the low price over the same 30-day period.",
          "code": "def heuristics_v2(df):\n    avg_vol_30 = df['volume'].rolling(window=30).mean()\n    avg_vol_150 = df['volume'].rolling(window=150).mean()\n    low_change_30 = df['low'].pct_change(periods=30)\n    heuristics_matrix = (avg_vol_30 / avg_vol_150) * (1 + low_change_30)\n    return heuristics_matrix",
          "objective": -0.03061,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by incorporating the relative change in trading volume over the past 30 days compared to the 150-day moving average, and further adjusts this ratio by the percentage change in the closing price over a 30-day period, giving insight into liquidity and price trend.",
          "code": "def heuristics_v2(df):\n    avg_vol_30 = df['volume'].rolling(window=30).mean()\n    avg_vol_150 = df['volume'].rolling(window=150).mean()\n    close_change_30 = df['close'].pct_change(periods=30)\n    heuristics_matrix = (avg_vol_30 / avg_vol_150) * (1 + close_change_30)\n    return heuristics_matrix",
          "objective": -0.0306,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the heuristic factor by measuring the ratio of the 30-day moving average volume to the 150-day moving average, then adjusting this by the square root of the absolute value of the 30-day closing price change, to balance liquidity signals with a smoothed price momentum.",
          "code": "def heuristics_v2(df):\n    avg_vol_30 = df['volume'].rolling(window=30).mean()\n    avg_vol_150 = df['volume'].rolling(window=150).mean()\n    close_change_30 = df['close'].pct_change(periods=30)\n    adjustment_factor = (1 + close_change_30.abs().pow(0.5))\n    heuristics_matrix = (avg_vol_30 / avg_vol_150) * adjustment_factor\n    return heuristics_matrix",
          "objective": -0.03032,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the heuristic factor by measuring the ratio of the 30-day moving average volume to the 150-day moving average, then adjusting this by the cube root of the absolute value of the 30-day closing price change, providing a more nuanced balance between liquidity and smoothed price momentum.",
          "code": "def heuristics_v2(df):\n    avg_vol_30 = df['volume'].rolling(window=30).mean()\n    avg_vol_150 = df['volume'].rolling(window=150).mean()\n    close_change_30 = df['close'].pct_change(periods=30)\n    adjustment_factor = (1 + close_change_30.abs().pow(1/3))\n    heuristics_matrix = (avg_vol_30 / avg_vol_150) * adjustment_factor\n    return heuristics_matrix",
          "objective": -0.02995,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by assessing the ratio of the average trading volume over the past 30 days to the 250-day moving average of the trading volume, indicating periods of relative liquidity and potential for price movement.",
          "code": "def heuristics_v2(df):\n    avg_vol_30 = df['volume'].rolling(window=30).mean()\n    avg_vol_250 = df['volume'].rolling(window=250).mean()\n    heuristics_matrix = avg_vol_30 / avg_vol_250\n    return heuristics_matrix",
          "objective": -0.02946,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by evaluating the ratio of the average trading volume over the past 30 days to the 150-day moving average of the trading volume, indicating periods of relative liquidity and potential for price movement.",
          "code": "def heuristics_v2(df):\n    avg_vol_30 = df['volume'].rolling(window=30).mean()\n    avg_vol_150 = df['volume'].rolling(window=150).mean()\n    heuristics_matrix = avg_vol_30 / avg_vol_150\n    return heuristics_matrix",
          "objective": -0.02933,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a heuristic factor by evaluating the ratio of the average trading volume over the past 20 days to the 200-day moving average of the trading volume, indicating periods of relative liquidity and potential for price movement.",
          "code": "def heuristics_v2(df):\n    avg_vol_20 = df['volume'].rolling(window=20).mean()\n    avg_vol_200 = df['volume'].rolling(window=200).mean()\n    heuristics_matrix = avg_vol_20 / avg_vol_200\n    return heuristics_matrix",
          "objective": -0.02864,
          "other_inf": null
     }
]