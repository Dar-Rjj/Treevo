[
     {
          "algorithm": "The algorithm computes a custom heuristics factor by combining exponential moving averages of different window sizes for close prices and volume, along with the difference between high and low prices, to generate a potentially predictive alpha factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    ema_close_short = df['close'].ewm(span=5, adjust=False).mean()\n    ema_close_long = df['close'].ewm(span=20, adjust=False).mean()\n    ema_volume_short = df['volume'].ewm(span=5, adjust=False).mean()\n    ema_volume_long = df['volume'].ewm(span=20, adjust=False).mean()\n    price_range = df['high'] - df['low']\n    heuristics_matrix = (ema_close_short / ema_close_long) * (ema_volume_short / ema_volume_long) * price_range\n    return heuristics_matrix",
          "objective": -0.01944,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a set of heuristic factors based on price and volume changes, then combines them to form a composite alpha factor indicating potential future stock return.",
          "code": "def heuristics_v2(df):\n    def calculate_factors(data):\n        data['price_change'] = data['close'].pct_change()\n        data['volume_change'] = data['volume'].pct_change()\n        data['volatility'] = data['high'] - data['low']\n        data['momentum'] = data['close'] - data['open']\n        return (data['price_change'] + data['volume_change'] + data['volatility'] + data['momentum']) / 4\n\n    heuristics_matrix = calculate_factors(df)\n    return heuristics_matrix",
          "objective": -0.01841,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a heuristic factor based on the ratio of the difference between the high and low prices to the closing price, suggesting that larger ratios might indicate higher volatility and thus could be used as a predictor for future returns.",
          "code": "def heuristics_v2(df):\n    heuristics_matrix = (df['high'] - df['low']) / df['close']\n    return heuristics_matrix",
          "objective": -0.01715,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a momentum-based alpha factor by evaluating the ratio of the 10-day moving average of the close price to the 50-day moving average, intending to capture short-term versus long-term trends.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    ma_10 = df['close'].rolling(window=10).mean()\n    ma_50 = df['close'].rolling(window=50).mean()\n    heuristics_matrix = ma_10 / ma_50\n    return heuristics_matrix",
          "objective": -0.01654,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a weighted combination of the rate of change (ROC) of close prices and the ratio of trading volume to amount, with weights determined based on their respective exponential moving averages, aiming to identify potential momentum and liquidity trends.",
          "code": "def heuristics_v2(df):\n    roc_close = df['close'].pct_change()\n    vol_to_amount_ratio = df['volume'] / df['amount']\n    ema_roc = roc_close.ewm(span=5, adjust=False).mean()\n    ema_vol_to_amt = vol_to_amount_ratio.ewm(span=5, adjust=False).mean()\n    weight_roc = ema_roc / (ema_roc + ema_vol_to_amt)\n    weight_vol_to_amt = 1 - weight_roc\n    heuristics_matrix = (weight_roc * roc_close + weight_vol_to_amt * vol_to_amount_ratio).rename('heuristics_factor')\n    return heuristics_matrix",
          "objective": -0.01182,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a custom momentum and volatility factor by combining the percentage change in closing price with the standard deviation of daily returns over a trailing window, aiming to generate a novel interpretable alpha factor.",
          "code": "def heuristics_v2(df):\n    # Calculate the percentage change in close prices\n    pct_change_close = df['close'].pct_change()\n    # Calculate the standard deviation of daily returns over a 30-day window\n    std_daily_returns = pct_change_close.rolling(window=30).std()\n    # Combine the two factors to create a new heuristics matrix\n    heuristics_matrix = (pct_change_close + std_daily_returns).dropna()\n    return heuristics_matrix",
          "objective": -0.00743,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm constructs a novel alpha factor by calculating the weighted sum of the exponential moving averages of the price and volume, with weights determined by the relative strength index (RSI) of the closing prices, aiming to capture momentum and volume trends.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def rsi(series, period=14):\n        delta = series.diff(1)\n        gain = (delta.where(delta > 0, 0)).fillna(0)\n        loss = (-delta.where(delta < 0, 0)).fillna(0)\n        avg_gain = gain.rolling(window=period).mean()\n        avg_loss = loss.rolling(window=period).mean()\n        rs = avg_gain / avg_loss\n        return 100 - (100 / (1 + rs))\n\n    close_rsi = rsi(df['close'])\n    ema_price = df['close'].ewm(span=20, adjust=False).mean()\n    ema_volume = df['volume'].ewm(span=20, adjust=False).mean()\n    heuristics_matrix = (ema_price * close_rsi/100) + (ema_volume * (100-close_rsi)/100)\n    return heuristics_matrix",
          "objective": -0.00709,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a weighted combination of price and volume momentum, where weights are determined by the historical consistency of each feature's directional movement, aiming to generate a predictive factor for future stock returns.",
          "code": "def heuristics_v2(df):\n    def calculate_consistency(series):\n        return (series.diff().dropna() > 0).rolling(window=20).mean()\n\n    open_consistency = calculate_consistency(df['open'])\n    close_consistency = calculate_consistency(df['close'])\n    volume_consistency = calculate_consistency(df['volume'])\n\n    open_factor = df['open'].pct_change() * open_consistency\n    close_factor = df['close'].pct_change() * close_consistency\n    volume_factor = df['volume'].pct_change() * volume_consistency\n\n    heuristics_matrix = (open_factor + close_factor) / 2 + volume_factor\n    return heuristics_matrix",
          "objective": -0.00483,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm, termed Dynamic Momentum Divergence (DMD), calculates the difference between the moving average of daily returns and its exponential weighted moving average, aiming to identify potential momentum reversals.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def calculate_daily_returns(prices):\n        return prices.pct_change().dropna()\n    \n    daily_returns = calculate_daily_returns(df['close'])\n    ma_10 = daily_returns.rolling(window=10).mean()\n    ewma_10 = daily_returns.ewm(span=10).mean()\n    divergence = ma_10 - ewma_10\n    heuristics_matrix = pd.Series(divergence, index=df.index[10:])\n    return heuristics_matrix",
          "objective": -0.00461,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a set of heuristic-based alpha factors by analyzing patterns in the input DataFrame, such as momentum, volatility, and liquidity, and combines them into a single factor to predict future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def calculate_momentum(df):\n        return df['close'].pct_change(periods=30).fillna(0)\n\n    def calculate_volatility(df):\n        daily_returns = df['close'].pct_change().fillna(0)\n        return daily_returns.rolling(window=60).std().fillna(0)\n\n    def calculate_liquidity(df):\n        return (df['volume'] / df['amount']).fillna(0)\n\n    momentum = calculate_momentum(df)\n    volatility = calculate_volatility(df)\n    liquidity = calculate_liquidity(df)\n    \n    heuristics_matrix = 0.5 * momentum - 0.3 * volatility + 0.2 * liquidity\n    return heuristics_matrix",
          "objective": -0.00375,
          "other_inf": null
     }
]