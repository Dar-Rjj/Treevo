[
     {
          "algorithm": "The algorithm computes a novel heuristic factor based on the weighted sum of moving averages and differences between high and low prices, designed to capture trends and volatility.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the moving averages\n    ma_5 = df['close'].rolling(window=5).mean()\n    ma_10 = df['close'].rolling(window=10).mean()\n\n    # Calculate the difference between high and low\n    diff_high_low = df['high'] - df['low']\n\n    # Combine the factors into a single heuristic\n    heuristics_matrix = (ma_5 - ma_10) + 0.5 * diff_high_low\n\n    return heuristics_matrix",
          "objective": -0.01269,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a custom technical indicator by first calculating the moving average of the 'close' price over 20 days, then subtracts the 5-day exponential moving average of the 'volume' from it, aiming to reflect the momentum and liquidity status.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    close_20_ma = df['close'].rolling(window=20).mean()\n    volume_5_ema = df['volume'].ewm(span=5, adjust=False).mean()\n    heuristics_matrix = close_20_ma - volume_5_ema\n    return heuristics_matrix",
          "objective": -0.01099,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm, named HeuristicsV2, calculates a novel alpha factor by combining the ratio of the closing price to the average of the high and low prices with the exponential moving average of trading volume, capturing both price momentum and liquidity.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the average of high and low prices\n    avg_high_low = (df['high'] + df['low']) / 2\n    # Calculate the ratio of close price to average of high and low prices\n    price_ratio = df['close'] / avg_high_low\n    # Calculate the exponential moving average of volume\n    ema_volume = df['volume'].ewm(span=10).mean()\n    # Combine the price ratio with EMA of volume for the alpha factor\n    heuristics_matrix = price_ratio * ema_volume\n    return heuristics_matrix",
          "objective": -0.01071,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a weighted combination of momentum, volatility, and trading volume as novel alpha factors, where the weights are determined based on historical return performance.",
          "code": "def heuristics_v2(df):\n    # Calculate momentum factor (Close - Close 30 days ago)\n    momentum = df['close'] - df['close'].shift(30)\n    \n    # Calculate volatility factor (Standard deviation of daily returns over 30 days)\n    daily_returns = df['close'].pct_change()\n    volatility = daily_returns.rolling(window=30).std()\n    \n    # Calculate volume factor (Average volume over 30 days)\n    volume_avg = df['volume'].rolling(window=30).mean()\n    \n    # Combine the factors into a single score\n    heuristics_matrix = momentum + volatility + volume_avg\n    \n    return heuristics_matrix",
          "objective": -0.00982,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a novel alpha factor by calculating the moving average crossover of closing prices with two different window sizes, then applying a logarithmic transformation to the ratio of these averages, and finally subtracting the volume's exponential moving average.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    short_window = 10\n    long_window = 30\n    ema_volume_window = 20\n    close_short_rolling = df['close'].rolling(window=short_window).mean()\n    close_long_rolling = df['close'].rolling(window=long_window).mean()\n    log_ratio = np.log(close_short_rolling / close_long_rolling)\n    ema_volume = df['volume'].ewm(span=ema_volume_window, adjust=False).mean()\n    heuristics_matrix = log_ratio - ema_volume\n    return heuristics_matrix",
          "objective": -0.0092,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a proprietary heuristic factor based on the weighted sum of recent price movements and volume trends, aiming to predict future stock returns.",
          "code": "def heuristics_v2(df):\n    # Calculate the change in close price\n    price_change = df['close'].diff()\n    # Calculate the 5-day moving average of price change\n    avg_price_change_5 = price_change.rolling(window=5).mean()\n    # Calculate the daily volume change\n    volume_change = df['volume'].diff()\n    # Calculate the 5-day moving average of volume change\n    avg_volume_change_5 = volume_change.rolling(window=5).mean()\n    # Define the heuristic factor as a combination of average price change and volume change\n    heuristics_matrix = (avg_price_change_5 * 0.6) + (avg_volume_change_5 * 0.4)\n    return heuristics_matrix",
          "objective": -0.00917,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm leverages a combination of technical indicators and price/volume relationship analysis to generate an alpha factor, specifically through calculating the ratio of the weighted moving average (WMA) of closing prices over the WMA of volumes, with weights decreasing linearly for more recent data points, aiming to highlight potentially undervalued or overvalued states in the market.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Assuming df is a DataFrame with at least 'close' and 'volume' columns\n    n = 5  # Define the number of days for WMA\n    weights = list(range(1, n + 1))\n    \n    def wma(series, weights):\n        return (series * weights).sum() / sum(weights)\n    \n    close_wma = df['close'].rolling(window=n).apply(lambda x: wma(x, weights), raw=True)\n    volume_wma = df['volume'].rolling(window=n).apply(lambda x: wma(x, weights), raw=True)\n    \n    heuristics_matrix = close_wma / volume_wma\n    return heuristics_matrix",
          "objective": -0.00718,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a composite factor by aggregating price and volume changes, along with relative strength indicators, to predict future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    df['price_change'] = df['close'] - df['open']\n    df['volume_change'] = df['volume'].diff()\n    df['relative_strength'] = (df['close'] - df['low']) / (df['high'] - df['low'])\n    heuristics_matrix = 0.5 * df['price_change'] + 0.3 * df['volume_change'] + 0.2 * df['relative_strength']\n    return heuristics_matrix",
          "objective": -0.00248,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm extracts a set of heuristics by combining simple arithmetic and logical operations on the input features to create a predictive factor, without normalizing the data.",
          "code": "def heuristics_v2(df):\n    heuristics_matrix = (df['close'] - df['open']) / df['volume'] + (df['high'] - df['low']) / df['amount']\n    return heuristics_matrix",
          "objective": -0.00246,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a composite factor by combining the momentum of the closing price with the volatility ratio, where the momentum is calculated as the difference between the current and past period's closing price, and the volatility ratio is the average true range over the past 10 days divided by the simple moving average of the closing price over the same period.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    close = df['close']\n    momentum = close - close.shift(1)\n    high, low = df['high'], df['low']\n    tr = pd.concat([high - low, (high - close.shift(1)).abs(), (low - close.shift(1)).abs()], axis=1).max(axis=1)\n    atr = tr.rolling(window=10).mean()\n    sma_close = close.rolling(window=10).mean()\n    volatility_ratio = atr / sma_close\n    heuristics_matrix = momentum + volatility_ratio\n    return heuristics_matrix",
          "objective": -0.00172,
          "other_inf": null
     }
]