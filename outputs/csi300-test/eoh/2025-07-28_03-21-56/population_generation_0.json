[
     {
          "algorithm": "The algorithm calculates a composite factor by combining moving averages and volatility measures, then applies a heuristic adjustment based on price momentum to generate the final alpha factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    close = df['close']\n    ma_short = close.rolling(window=10).mean()\n    ma_long = close.rolling(window=50).mean()\n    std_dev = close.rolling(window=30).std()\n    momentum = close / close.shift(1) - 1\n    heuristics_matrix = (ma_short - ma_long) / std_dev + momentum\n    return heuristics_matrix",
          "objective": -0.03593,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm involves calculating a novel heuristic factor for each date by taking the difference between the highest high and lowest low over a rolling 7-day window, then dividing this by the average volume over the same period.",
          "code": "def heuristics_v2(df):\n    df['high_rolling_max'] = df['high'].rolling(window=7).max()\n    df['low_rolling_min'] = df['low'].rolling(window=7).min()\n    df['volume_rolling_mean'] = df['volume'].rolling(window=7).mean()\n    heuristics_matrix = (df['high_rolling_max'] - df['low_rolling_min']) / df['volume_rolling_mean']\n    return heuristics_matrix",
          "objective": -0.03584,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm involves calculating a weighted sum of logarithmic returns, volume changes, and the ratio of closing to opening prices, then applying a momentum-indicating transformation to generate alpha factors.",
          "code": "def heuristics_v2(df):\n    log_returns = np.log(df['close'] / df['close'].shift(1))\n    volume_change = df['volume'].pct_change()\n    close_open_ratio = df['close'] / df['open']\n    weighted_sum = (log_returns * 0.5) + (volume_change * 0.3) + (close_open_ratio * 0.2)\n    heuristics_matrix = (weighted_sum - weighted_sum.rolling(window=20).mean()) / weighted_sum.rolling(window=20).std()\n    return heuristics_matrix",
          "objective": -0.03581,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm extracts alpha factors by computing the rolling mean of the difference between the daily high and low prices, then applying a weighted sum with the volume, to generate a series that reflects the relationship between price volatility and trading volume.",
          "code": "def heuristics_v2(df):\n    # Calculate the daily range\n    daily_range = df['high'] - df['low']\n    \n    # Compute the rolling mean of the daily range\n    rolling_mean_range = daily_range.rolling(window=20).mean()\n    \n    # Generate the heuristic factor by incorporating the volume\n    heuristics_matrix = rolling_mean_range * df['volume']\n    \n    return heuristics_matrix",
          "objective": -0.03494,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a heuristics-based factor by first determining the weighted difference between the daily high and low prices, adjusted by the ratio of the day's volume to the 30-day average volume, then further refined by the rate of change in closing prices over the past 10 days.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate 30-day average volume\n    avg_vol_30 = df['volume'].rolling(window=30).mean()\n    \n    # Calculate the volume ratio\n    vol_ratio = df['volume'] / avg_vol_30\n    \n    # Calculate the high-low price difference\n    hl_diff = df['high'] - df['low']\n    \n    # Adjust high-low difference by volume ratio\n    weighted_hl_diff = hl_diff * vol_ratio\n    \n    # Calculate the 10-day rate of change in close prices\n    roc_close_10 = df['close'].pct_change(periods=10)\n    \n    # Combine the weighted high-low difference with the ROC of close prices\n    heuristics_matrix = (weighted_hl_diff + roc_close_10).dropna()\n    \n    return heuristics_matrix",
          "objective": -0.0185,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a momentum-based alpha factor by first determining the average return over a short period and then subtracting the average return over a longer period, aiming to capture the difference in momentum.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    short_period = 5\n    long_period = 20\n    short_returns = df['close'].pct_change(short_period).rolling(window=short_period).mean()\n    long_returns = df['close'].pct_change(long_period).rolling(window=long_period).mean()\n    heuristics_matrix = short_returns - long_returns\n    return heuristics_matrix",
          "objective": -0.01669,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm leverages a combination of momentum, volatility, and volume trends over varying lookback windows to generate a set of alpha factors, which are then aggregated into a final heuristics matrix.",
          "code": "def heuristics_v2(df):\n    def calculate_momentum(df, window):\n        return df['close'].pct_change(window)\n    \n    def calculate_volatility(df, window):\n        return df['close'].rolling(window).std()\n    \n    def calculate_volume_trend(df, window):\n        return df['volume'].rolling(window).mean().pct_change()\n    \n    short_window = 10\n    medium_window = 30\n    long_window = 90\n    \n    momentum_short = calculate_momentum(df, short_window)\n    momentum_medium = calculate_momentum(df, medium_window)\n    momentum_long = calculate_momentum(df, long_window)\n    \n    volatility_short = calculate_volatility(df, short_window)\n    volatility_medium = calculate_volatility(df, medium_window)\n    volatility_long = calculate_volatility(df, long_window)\n    \n    volume_trend_short = calculate_volume_trend(df, short_window)\n    volume_trend_medium = calculate_volume_trend(df, medium_window)\n    volume_trend_long = calculate_volume_trend(df, long_window)\n    \n    heuristics_matrix = (momentum_short + momentum_medium + momentum_long +\n                         -volatility_short - volatility_medium - volatility_long +\n                         volume_trend_short + volume_trend_medium + volume_trend_long) / 9\n    \n    return heuristics_matrix",
          "objective": -0.01543,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a novel alpha factor by combining the ratio of close to open prices with the change in volume, then applying a simple moving average to smooth out short-term fluctuations.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def sma(series, window=5):\n        return series.rolling(window=window).mean()\n    \n    price_ratio = df['close'] / df['open']\n    volume_change = df['volume'].pct_change()\n    combined_factor = price_ratio * volume_change\n    heuristics_matrix = sma(combined_factor)\n    return heuristics_matrix",
          "objective": -0.01082,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm leverages a combination of price and volume momentum, alongside volatility measures, to generate an interpretable alpha factor without normalization.",
          "code": "def heuristics_v2(df):\n    def simple_moving_average(series, window=10):\n        return series.rolling(window=window).mean()\n\n    df['momentum'] = (df['close'] - df['close'].shift(10)) / df['close'].shift(10)\n    df['volume_change'] = (df['volume'] - df['volume'].shift(10)) / df['volume'].shift(10)\n    df['volatility'] = df['close'].pct_change().rolling(window=10).std()\n    heuristics_matrix = 0.5 * df['momentum'] + 0.3 * df['volume_change'] - 0.2 * df['volatility']\n    return heuristics_matrix",
          "objective": -0.00977,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm involves creating a composite factor by combining moving averages and price momentum, then calculating the product of short-term and long-term trends to predict future returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    short_term_ma = df['close'].rolling(window=10).mean()\n    long_term_ma = df['close'].rolling(window=60).mean()\n    price_momentum = df['close'] / df['close'].shift(5) - 1\n    heuristics_matrix = (short_term_ma - long_term_ma) * price_momentum\n    return heuristics_matrix",
          "objective": -0.00909,
          "other_inf": null
     }
]