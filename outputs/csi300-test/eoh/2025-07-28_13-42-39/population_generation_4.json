[
     {
          "algorithm": "The new algorithm calculates a composite factor by first computing the rolling mean of the ratio between the difference of high and low prices and the trading amount, then dividing this rolling mean by the 50-day exponentially weighted moving average of the close price.",
          "code": "def heuristics_v2(df):\n    df['ratio'] = (df['high'] - df['low']) / df['amount']\n    df['rolling_mean'] = df['ratio'].rolling(window=20).mean()\n    df['close_ewma_50'] = df['close'].ewm(span=50, adjust=False).mean()\n    heuristics_matrix = df['rolling_mean'] / df['close_ewma_50']\n    return heuristics_matrix",
          "objective": -0.03785,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by first computing the rolling standard deviation of the ratio between the difference of high and low prices and the trading amount, then dividing this rolling standard deviation by the 50-day exponentially weighted moving average of the close price.",
          "code": "def heuristics_v2(df):\n    df['ratio'] = (df['high'] - df['low']) / df['amount']\n    df['rolling_std'] = df['ratio'].rolling(window=20).std()\n    df['close_ewma_50'] = df['close'].ewm(span=50, adjust=False).mean()\n    heuristics_matrix = df['rolling_std'] / df['close_ewma_50']\n    return heuristics_matrix",
          "objective": -0.03344,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by taking the rolling standard deviation of the ratio between the difference of high and low prices and the trading amount, then dividing this value by the 50-day simple moving average of the close price.",
          "code": "def heuristics_v2(df):\n    df['ratio'] = (df['high'] - df['low']) / df['amount']\n    df['rolling_std'] = df['ratio'].rolling(window=20).std()\n    df['close_sma_50'] = df['close'].rolling(window=50).mean()\n    heuristics_matrix = df['rolling_std'] / df['close_sma_50']\n    return heuristics_matrix",
          "objective": -0.03318,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor by combining the relative strength index (RSI) over a 14-day period with the difference between the 5-day and 10-day simple moving averages of the closing price.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the 5-day and 10-day simple moving averages of the closing price\n    df['MA_5'] = df['close'].rolling(window=5).mean()\n    df['MA_10'] = df['close'].rolling(window=10).mean()\n    \n    # Calculate the difference between the 5-day and 10-day moving averages\n    ma_diff = df['MA_5'] - df['MA_10']\n    \n    # Calculate the daily price change\n    price_change = df['close'].diff(1)\n    \n    # Separate gains and losses\n    gain = price_change.where(price_change > 0, 0)\n    loss = -price_change.where(price_change < 0, 0)\n    \n    # Calculate the average gain and loss over a 14-day period\n    avg_gain = gain.rolling(window=14).mean()\n    avg_loss = loss.rolling(window=14).mean()\n    \n    # Calculate the relative strength (RS)\n    rs = avg_gain / avg_loss\n    \n    # Calculate the RSI\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Final heuristic matrix\n    heuristics_matrix = rsi + ma_diff\n    \n    return heuristics_matrix",
          "objective": -0.03263,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a volatility-adjusted momentum factor by first computing the 10-day high and low averages, then adjusting these values with the 10-day standard deviation of the close price, and finally applying a 30-day simple moving average to smooth out the resulting values.",
          "code": "def heuristics_v2(df):\n    df['high_avg'] = df['high'].rolling(window=10).mean()\n    df['low_avg'] = df['low'].rolling(window=10).mean()\n    df['std_close'] = df['close'].rolling(window=10).std()\n    adjusted_high = df['high_avg'] / df['std_close']\n    adjusted_low = df['low_avg'] / df['std_close']\n    direction_movement = adjusted_high / adjusted_low\n    heuristics_matrix = direction_movement.rolling(window=30).mean()\n    return heuristics_matrix",
          "objective": -0.02817,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor by first determining the 30-day EMA of the high price and the 30-day EMA of the low price, then subtracting these two, and finally dividing the result by the 50-day SMA of the close price.",
          "code": "def heuristics_v2(df):\n    df['high_ema_30'] = df['high'].ewm(span=30, adjust=False).mean()\n    df['low_ema_30'] = df['low'].ewm(span=30, adjust=False).mean()\n    diff_ema = df['high_ema_30'] - df['low_ema_30']\n    df['close_sma_50'] = df['close'].rolling(window=50).mean()\n    heuristics_matrix = diff_ema / df['close_sma_50']\n    return heuristics_matrix",
          "objective": -0.02774,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by using the exponential moving average (EMA) of closing prices and volumes, then computes the ratio of the close to its EMA, and finally combines this with the momentum of volume change.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    close = df['close']\n    volume = df['volume']\n    close_ema = close.ewm(span=20, adjust=False).mean()\n    vol_change = volume.pct_change()\n    factor1 = close / close_ema\n    factor2 = (vol_change + 1).cumprod() - 1\n    heuristics_matrix = (factor1 * factor2)\n    return heuristics_matrix",
          "objective": -0.02769,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a composite factor by first calculating the moving average of closing prices and volumes, then deriving a ratio of the close to its moving average, and finally combining this with the momentum of volume change, all without normalization.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    close = df['close']\n    volume = df['volume']\n    close_ma = close.rolling(window=20).mean()\n    vol_change = volume.pct_change()\n    factor1 = close / close_ma\n    factor2 = (vol_change + 1).cumprod() - 1\n    heuristics_matrix = (factor1 * factor2)\n    return heuristics_matrix",
          "objective": -0.02764,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a momentum-based alpha factor by assessing the ratio of the 10-day high average to the 10-day low average, then applying a 30-day simple moving average (SMA) to smooth out the resulting values.",
          "code": "def heuristics_v2(df):\n    df['high_avg'] = df['high'].rolling(window=10).mean()\n    df['low_avg'] = df['low'].rolling(window=10).mean()\n    direction_movement = df['high_avg'] / df['low_avg']\n    heuristics_matrix = direction_movement.rolling(window=30).mean()\n    return heuristics_matrix",
          "objective": -0.02623,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a momentum-based alpha factor by assessing the ratio of the 15-day high average to the 15-day low average, then applying a 20-day simple moving average (SMA) to smooth out the resulting values.",
          "code": "def heuristics_v2(df):\n    df['high_avg'] = df['high'].rolling(window=15).mean()\n    df['low_avg'] = df['low'].rolling(window=15).mean()\n    direction_movement = df['high_avg'] / df['low_avg']\n    heuristics_matrix = direction_movement.rolling(window=20).mean()\n    return heuristics_matrix",
          "objective": -0.02621,
          "other_inf": null
     }
]