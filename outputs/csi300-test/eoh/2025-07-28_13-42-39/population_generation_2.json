[
     {
          "algorithm": "The new algorithm calculates a composite factor by first computing the rolling mean of the ratio between the difference of high and low prices and the trading amount, then dividing this rolling mean by the 50-day exponentially weighted moving average of the close price.",
          "code": "def heuristics_v2(df):\n    df['ratio'] = (df['high'] - df['low']) / df['amount']\n    df['rolling_mean'] = df['ratio'].rolling(window=20).mean()\n    df['close_ewma_50'] = df['close'].ewm(span=50, adjust=False).mean()\n    heuristics_matrix = df['rolling_mean'] / df['close_ewma_50']\n    return heuristics_matrix",
          "objective": -0.03785,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by first computing the rolling standard deviation of the ratio between the difference of high and low prices and the trading amount, then dividing this rolling standard deviation by the 50-day exponentially weighted moving average of the close price.",
          "code": "def heuristics_v2(df):\n    df['ratio'] = (df['high'] - df['low']) / df['amount']\n    df['rolling_std'] = df['ratio'].rolling(window=20).std()\n    df['close_ewma_50'] = df['close'].ewm(span=50, adjust=False).mean()\n    heuristics_matrix = df['rolling_std'] / df['close_ewma_50']\n    return heuristics_matrix",
          "objective": -0.03344,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by taking the rolling standard deviation of the ratio between the difference of high and low prices and the trading amount, then dividing this value by the 50-day simple moving average of the close price.",
          "code": "def heuristics_v2(df):\n    df['ratio'] = (df['high'] - df['low']) / df['amount']\n    df['rolling_std'] = df['ratio'].rolling(window=20).std()\n    df['close_sma_50'] = df['close'].rolling(window=50).mean()\n    heuristics_matrix = df['rolling_std'] / df['close_sma_50']\n    return heuristics_matrix",
          "objective": -0.03318,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor by combining the relative strength index (RSI) over a 14-day period with the difference between the 5-day and 10-day simple moving averages of the closing price.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the 5-day and 10-day simple moving averages of the closing price\n    df['MA_5'] = df['close'].rolling(window=5).mean()\n    df['MA_10'] = df['close'].rolling(window=10).mean()\n    \n    # Calculate the difference between the 5-day and 10-day moving averages\n    ma_diff = df['MA_5'] - df['MA_10']\n    \n    # Calculate the daily price change\n    price_change = df['close'].diff(1)\n    \n    # Separate gains and losses\n    gain = price_change.where(price_change > 0, 0)\n    loss = -price_change.where(price_change < 0, 0)\n    \n    # Calculate the average gain and loss over a 14-day period\n    avg_gain = gain.rolling(window=14).mean()\n    avg_loss = loss.rolling(window=14).mean()\n    \n    # Calculate the relative strength (RS)\n    rs = avg_gain / avg_loss\n    \n    # Calculate the RSI\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Final heuristic matrix\n    heuristics_matrix = rsi + ma_diff\n    \n    return heuristics_matrix",
          "objective": -0.03263,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a composite factor by first calculating the moving average of closing prices and volumes, then deriving a ratio of the close to its moving average, and finally combining this with the momentum of volume change, all without normalization.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    close = df['close']\n    volume = df['volume']\n    close_ma = close.rolling(window=20).mean()\n    vol_change = volume.pct_change()\n    factor1 = close / close_ma\n    factor2 = (vol_change + 1).cumprod() - 1\n    heuristics_matrix = (factor1 * factor2)\n    return heuristics_matrix",
          "objective": -0.02764,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a momentum-based alpha factor by assessing the ratio of the 10-day high average to the 10-day low average, then applying a 30-day simple moving average (SMA) to smooth out the resulting values.",
          "code": "def heuristics_v2(df):\n    df['high_avg'] = df['high'].rolling(window=10).mean()\n    df['low_avg'] = df['low'].rolling(window=10).mean()\n    direction_movement = df['high_avg'] / df['low_avg']\n    heuristics_matrix = direction_movement.rolling(window=30).mean()\n    return heuristics_matrix",
          "objective": -0.02623,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a momentum-based alpha factor by assessing the ratio of the 15-day high average to the 15-day low average, then applying a 20-day simple moving average (SMA) to smooth out the resulting values.",
          "code": "def heuristics_v2(df):\n    df['high_avg'] = df['high'].rolling(window=15).mean()\n    df['low_avg'] = df['low'].rolling(window=15).mean()\n    direction_movement = df['high_avg'] / df['low_avg']\n    heuristics_matrix = direction_movement.rolling(window=20).mean()\n    return heuristics_matrix",
          "objective": -0.02621,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor by combining the difference between the 20-day and 50-day simple moving averages of the closing price with the average true range (ATR) over a 14-day period.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the 20-day and 50-day simple moving averages of the closing price\n    df['MA_20'] = df['close'].rolling(window=20).mean()\n    df['MA_50'] = df['close'].rolling(window=50).mean()\n    \n    # Calculate the difference between the 20-day and 50-day moving averages\n    ma_diff = df['MA_20'] - df['MA_50']\n    \n    # Calculate the True Range\n    df['true_range'] = df[['high', 'low']].diff(axis=1).abs().max(axis=1)\n    \n    # Calculate the Average True Range (ATR) over a 14-day period\n    atr = df['true_range'].rolling(window=14).mean()\n    \n    # Final heuristic matrix\n    heuristics_matrix = ma_diff + atr\n    \n    return heuristics_matrix",
          "objective": -0.02387,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes the rolling median of the ratio between the difference of high and low prices and the adjusted close price, then subtracts the 20-day simple moving average of the adjusted close price from this value.",
          "code": "def heuristics_v2(df):\n    def custom_alpha(row):\n        return (row['high'] - row['low']) / row['adj_close']\n    \n    df['custom_factor'] = df.apply(custom_alpha, axis=1)\n    df['custom_factor_rolling_median'] = df['custom_factor'].rolling(window=10).median()\n    df['adj_close_sma'] = df['adj_close'].rolling(window=20).mean()\n    heuristics_matrix = df['custom_factor_rolling_median'] - df['adj_close_sma']\n    return heuristics_matrix",
          "objective": -0.0227,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a momentum-based alpha factor by combining the difference between the 20-day high and low averages with a 60-day simple moving average (SMA) to smooth the values.",
          "code": "def heuristics_v2(df):\n    df['high_avg'] = df['high'].rolling(window=20).mean()\n    df['low_avg'] = df['low'].rolling(window=20).mean()\n    direction_movement = df['high_avg'] - df['low_avg']\n    heuristics_matrix = direction_movement.rolling(window=60).mean()\n    return heuristics_matrix",
          "objective": -0.02046,
          "other_inf": null
     }
]