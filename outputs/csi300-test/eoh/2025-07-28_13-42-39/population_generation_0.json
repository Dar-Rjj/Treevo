[
     {
          "algorithm": "The algorithm computes a composite factor by first calculating the moving average of closing prices and volumes, then deriving a ratio of the close to its moving average, and finally combining this with the momentum of volume change, all without normalization.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    close = df['close']\n    volume = df['volume']\n    close_ma = close.rolling(window=20).mean()\n    vol_change = volume.pct_change()\n    factor1 = close / close_ma\n    factor2 = (vol_change + 1).cumprod() - 1\n    heuristics_matrix = (factor1 * factor2)\n    return heuristics_matrix",
          "objective": -0.02764,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm constructs a novel alpha factor by computing the rolling average of the ratio between the difference of high and low prices and the closing price, then subtracting the 30-day simple moving average of the close price from this value.",
          "code": "def heuristics_v2(df):\n    def custom_alpha(row):\n        return (row['high'] - row['low']) / row['close']\n    \n    df['custom_factor'] = df.apply(custom_alpha, axis=1)\n    df['custom_factor_rolling_avg'] = df['custom_factor'].rolling(window=10).mean()\n    df['close_sma'] = df['close'].rolling(window=30).mean()\n    heuristics_matrix = df['custom_factor_rolling_avg'] - df['close_sma']\n    return heuristics_matrix",
          "objective": -0.01737,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a momentum-based alpha factor by computing the difference between the 20-day and 50-day moving averages of the closing price, aiming to capture short-term versus medium-term trends.",
          "code": "def heuristics_v2(df):\n    df['MA_20'] = df['close'].rolling(window=20).mean()\n    df['MA_50'] = df['close'].rolling(window=50).mean()\n    heuristics_matrix = df['MA_20'] - df['MA_50']\n    return heuristics_matrix",
          "objective": -0.01155,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a composite factor by taking the rolling mean of the ratio between the difference of high and low prices to the trading volume, over a 20-day window, aiming to capture volatility relative to volume as an indicator.",
          "code": "def heuristics_v2(df):\n    heuristics_matrix = (df['high'] - df['low']) / df['volume']\n    heuristics_matrix = heuristics_matrix.rolling(window=20).mean()\n    return heuristics_matrix",
          "objective": -0.00916,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes the weighted difference between the average of the high and low prices over a short-term window and a long-term window, aiming to capture momentum and mean reversion tendencies.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    short_window = 5\n    long_window = 20\n    short_avg = (df['high'].rolling(window=short_window).mean() + df['low'].rolling(window=short_window).mean()) / 2\n    long_avg = (df['high'].rolling(window=long_window).mean() + df['low'].rolling(window=long_window).mean()) / 2\n    heuristics_matrix = (short_avg - long_avg) * 1.5\n    return heuristics_matrix",
          "objective": -0.00602,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes the momentum of a stock by averaging the percentage change in closing prices over the last 5 days and then subtracts the average daily range (high price - low price) over the same period, aiming to capture both short-term trend and volatility in its heuristic.",
          "code": "def heuristics_v2(df):\n    df['close_change'] = df['close'].pct_change()\n    df['daily_range'] = df['high'] - df['low']\n    avg_close_change = df['close_change'].rolling(window=5).mean()\n    avg_daily_range = df['daily_range'].rolling(window=5).mean()\n    heuristics_matrix = avg_close_change - avg_daily_range\n    return heuristics_matrix",
          "objective": -0.00504,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a composite factor by combining momentum, volatility, and trading volume indicators to predict future stock returns.",
          "code": "def heuristics_v2(df):\n    # Calculate momentum factor using the difference between today's close and the 10-day moving average of close prices\n    momentum = df['close'] - df['close'].rolling(window=10).mean()\n    \n    # Calculate volatility factor using the standard deviation of the last 5 days' closing prices\n    volatility = df['close'].rolling(window=5).std()\n    \n    # Calculate activity factor using the 5-day moving average of trading volume\n    activity = df['volume'].rolling(window=5).mean()\n    \n    # Combine factors into a single heuristics score\n    heuristics_matrix = (momentum / volatility) * activity\n    \n    return heuristics_matrix",
          "objective": -0.00419,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm involves calculating a momentum-based alpha factor by combining the relative strength index (RSI) of the closing price with the rate of change (ROC) of trading volume, then applying a weighted moving average to smooth out noise.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def rsi(series, periods=14):\n        delta = series.diff()\n        gain = delta.where(delta > 0, 0)\n        loss = -delta.where(delta < 0, 0)\n        avg_gain = gain.rolling(window=periods).mean()\n        avg_loss = loss.rolling(window=periods).mean()\n        rs = avg_gain / avg_loss\n        return 100 - (100 / (1 + rs))\n\n    def roc(series, periods=12):\n        return series.pct_change(periods=periods)\n\n    close_prices = df['close']\n    volumes = df['volume']\n\n    rsi_values = rsi(close_prices)\n    roc_volumes = roc(volumes)\n\n    heuristics_matrix = (rsi_values * 0.6 + roc_volumes * 0.4).rolling(window=5).mean()\n\n    return heuristics_matrix",
          "objective": -0.00404,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies patterns in the ratio of average daily trading volume to price volatility, and computes a factor based on the smoothed moving averages of this ratio over different time frames.",
          "code": "import pandas as pd\nimport numpy as np\n\ndef heuristics_v2(df):\n    # Calculate the daily trading volume to close price ratio\n    vol_to_close = df['volume'] / df['close']\n    \n    # Calculate the rolling standard deviation of the close price (volatility)\n    close_volatility = df['close'].rolling(window=20).std()\n    \n    # Compute the ratio of average daily trading volume to price volatility\n    ratio = vol_to_close / close_volatility\n    \n    # Smooth the ratio with short, medium, and long-term moving averages\n    short_term_ma = ratio.rolling(window=5).mean()\n    medium_term_ma = ratio.rolling(window=20).mean()\n    long_term_ma = ratio.rolling(window=60).mean()\n    \n    # Generate the heuristic factor as a weighted sum of the moving averages\n    heuristics_matrix = 0.2 * short_term_ma + 0.3 * medium_term_ma + 0.5 * long_term_ma\n    \n    return heuristics_matrix",
          "objective": -0.00306,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm involves computing a weighted sum of percentage changes in open, high, low, and close prices, alongside the volume change, to form a heuristic factor that potentially signals future returns.",
          "code": "def heuristics_v2(df):\n    # Compute percentage changes\n    pct_change_open = df['open'].pct_change()\n    pct_change_high = df['high'].pct_change()\n    pct_change_low = df['low'].pct_change()\n    pct_change_close = df['close'].pct_change()\n    volume_change = df['volume'].diff()\n\n    # Create a weighted combination\n    heuristics_matrix = 0.25 * pct_change_open + 0.25 * pct_change_high + 0.25 * pct_change_low + 0.25 * pct_change_close + volume_change\n\n    return heuristics_matrix",
          "objective": -0.00248,
          "other_inf": null
     }
]