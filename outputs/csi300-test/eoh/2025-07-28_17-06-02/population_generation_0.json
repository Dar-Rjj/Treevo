[
     {
          "algorithm": "The algorithm calculates a set of technical and fundamental heuristics based on price and volume data, combining moving averages, momentum indicators, and volatility measures to create a composite factor aimed at predicting future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate simple moving averages\n    sma_5 = df['close'].rolling(window=5).mean()\n    sma_10 = df['close'].rolling(window=10).mean()\n    sma_ratio = (sma_5 / sma_10) - 1\n    \n    # Momentum indicator\n    momentum = df['close'] / df['close'].shift(5) - 1\n    \n    # Volatility measure\n    daily_returns = df['close'].pct_change()\n    volatility = daily_returns.rolling(window=20).std()\n    \n    # Price range\n    price_range = (df['high'] - df['low']) / df['close']\n    \n    # Volume weighted by close price\n    volume_weighted = df['volume'] * df['close']\n    \n    # Composite heuristic\n    heuristics_matrix = (sma_ratio + momentum - volatility + price_range + volume_weighted) / 5\n    return heuristics_matrix",
          "objective": -0.03499,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm constructs a novel heuristic factor by combining price momentum, trading volume, and volatility indicators to predict future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate the momentum as the difference between the current close and the 30-day average close\n    momentum = df['close'] - df['close'].rolling(window=30).mean()\n    \n    # Calculate the volume change as the percentage change in volume from the previous day\n    volume_change = df['volume'].pct_change()\n    \n    # Calculate the average true range (a measure of volatility) over the last 14 days\n    tr1 = abs(df[\"high\"] - df[\"low\"])\n    tr2 = abs(df[\"high\"] - df[\"close\"].shift())\n    tr3 = abs(df[\"low\"] - df[\"close\"].shift())\n    true_range = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)\n    avg_true_range = true_range.rolling(window=14).mean()\n    \n    # Combine the factors into a heuristics matrix, assigning equal weights for simplicity\n    heuristics_matrix = (momentum + volume_change + avg_true_range) / 3\n    \n    return heuristics_matrix",
          "objective": -0.01681,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a momentum-based alpha factor by taking the ratio of the average closing price over the last 10 days to the average closing price over the last 50 days, aiming to capture short-term versus medium-term trends.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def compute_heuristic(df):\n        short_term = df['close'].rolling(window=10).mean()\n        long_term = df['close'].rolling(window=50).mean()\n        return short_term / long_term\n\n    heuristics_matrix = compute_heuristic(df)\n    return heuristics_matrix",
          "objective": -0.01654,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes the moving average convergence divergence (MACD) with a twist, using a custom short-term and long-term exponential moving average (EMA) of the closing prices, and then subtracts the long EMA from the short EMA to generate the alpha factor.",
          "code": "def heuristics_v2(df):\n    def ema(data, window):\n        return data.ewm(span=window, adjust=False).mean()\n    \n    short_ema = ema(df['close'], 12)\n    long_ema = ema(df['close'], 26)\n    heuristics_matrix = short_ema - long_ema\n    return heuristics_matrix",
          "objective": -0.00731,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a momentum-based alpha factor by computing the rate of change between today's closing price and the average closing price over the past 30 days, then applying a simple moving average filter to smooth out short-term fluctuations.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    close_prices = df['close']\n    avg_30d_close = close_prices.rolling(window=30).mean()\n    roc = (close_prices - avg_30d_close) / avg_30d_close\n    heuristics_matrix = roc.rolling(window=10).mean().dropna()\n    return heuristics_matrix",
          "objective": -0.0064,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a heuristic factor by combining momentum, volatility, and volume changes, where the main steps involve computing price momentum, standard deviation of returns for volatility, and percentage change in volume to construct the final factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    close_prices = df['close']\n    volumes = df['volume']\n\n    # Momentum (using 5-day simple moving average)\n    momentum = close_prices / close_prices.shift(5) - 1\n\n    # Volatility (using 5-day standard deviation of daily returns)\n    daily_returns = close_prices.pct_change()\n    volatility = daily_returns.rolling(window=5).std()\n\n    # Volume change (percentage change over 5 days)\n    volume_change = volumes.pct_change(5)\n\n    # Heuristic factor\n    heuristics_matrix = (momentum - volatility) * volume_change\n\n    return heuristics_matrix",
          "objective": -0.00636,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies patterns in trading volume and price movements to construct a heuristic factor that aims at predicting future stock returns, involving steps such as calculating daily return, volume change, and combining these with high and low prices to form a composite indicator.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    daily_return = df['close'].pct_change()\n    volume_change = df['volume'].pct_change()\n    range_ratio = (df['high'] - df['low']) / df['close']\n    heuristics_matrix = (daily_return + volume_change) * range_ratio\n    return heuristics_matrix",
          "objective": -0.00557,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a set of heuristic-based alpha factors including momentum, volatility, and volume-related features over different time windows to predict future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def calculate_momentum(series, window):\n        return series.pct_change(periods=window).dropna()\n\n    def calculate_volatility(series, window):\n        return series.pct_change().rolling(window=window).std().dropna()\n\n    def calculate_volume_ratio(df, short_window, long_window):\n        short_vol = df['volume'].rolling(window=short_window).mean()\n        long_vol = df['volume'].rolling(window=long_window).mean()\n        return (short_vol / long_vol).dropna()\n    \n    momentum_5 = calculate_momentum(df['close'], 5)\n    momentum_20 = calculate_momentum(df['close'], 20)\n    volatility_20 = calculate_volatility(df['close'], 20)\n    volume_ratio = calculate_volume_ratio(df, 5, 20)\n    \n    heuristics_matrix = pd.concat([momentum_5, momentum_20, volatility_20, volume_ratio], axis=1).mean(axis=1)\n    heuristics_matrix.name = 'heuristic_factor'\n    return heuristics_matrix",
          "objective": -0.00151,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates the moving average convergence divergence (MACD) of the closing prices and combines it with the relative strength index (RSI) of the volume to generate an alpha factor.",
          "code": "def heuristics_v2(df):\n    short_window = 12\n    long_window = 26\n    signal_window = 9\n    rsi_window = 14\n\n    exp1 = df['close'].ewm(span=short_window, adjust=False).mean()\n    exp2 = df['close'].ewm(span=long_window, adjust=False).mean()\n    macd = exp1 - exp2\n    signal = macd.ewm(span=signal_window, adjust=False).mean()\n    hist = macd - signal\n\n    delta = df['volume'].diff(1)\n    gain = (delta.where(delta > 0, 0)).rolling(window=rsi_window).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=rsi_window).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n\n    heuristics_matrix = (hist + rsi) / 2\n    return heuristics_matrix",
          "objective": -0.00137,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a novel alpha factor by combining weighted moving averages and the relative strength index (RSI) of the closing prices, aiming to capture both momentum and mean-reversion tendencies in the market.",
          "code": "import pandas as pd\n    import numpy as np\n    from ta.momentum import RSIIndicator\n\n    # Calculate short and long term weighted moving averages of the close price\n    wma_short = df['close'].ewm(span=5, adjust=False).mean()\n    wma_long = df['close'].ewm(span=20, adjust=False).mean()\n\n    # Compute the RSI for the closing prices with a 14-day window\n    rsi = RSIIndicator(close=df['close'], window=14).rsi()\n\n    # Create a heuristic based on the difference between short and long WMA, adjusted by the RSI value\n    heuristics_matrix = (wma_short - wma_long) * (70 - rsi)\n\n    return heuristics_matrix",
          "objective": Infinity,
          "other_inf": null
     }
]