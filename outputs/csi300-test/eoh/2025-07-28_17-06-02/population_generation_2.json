[
     {
          "algorithm": "The new algorithm calculates a set of technical and fundamental heuristics based on price and volume data, incorporating moving averages, relative strength index, and average true range with adjusted parameters to create a composite factor aimed at predicting future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate simple moving averages\n    sma_7 = df['close'].rolling(window=7).mean()\n    sma_14 = df['close'].rolling(window=14).mean()\n    sma_ratio = (sma_7 / sma_14) - 1\n    \n    # Relative Strength Index (RSI)\n    delta = df['close'].diff(1)\n    gain = (delta.where(delta > 0, 0)).rolling(window=21).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=21).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Average True Range (ATR)\n    tr = df['high'] - df['low']\n    atr = tr.rolling(window=21).mean()\n    \n    # Volume weighted by close price\n    volume_weighted = df['volume'] * df['close']\n    \n    # Composite heuristic\n    heuristics_matrix = (sma_ratio + rsi - atr + volume_weighted) / 4\n    return heuristics_matrix",
          "objective": -0.03566,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a set of technical and fundamental heuristics based on price and volume data, incorporating moving averages, relative strength index, and average true range to create a composite factor aimed at predicting future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate simple moving averages\n    sma_5 = df['close'].rolling(window=5).mean()\n    sma_10 = df['close'].rolling(window=10).mean()\n    sma_ratio = (sma_5 / sma_10) - 1\n    \n    # Relative Strength Index (RSI)\n    delta = df['close'].diff(1)\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Average True Range (ATR)\n    tr = df['high'] - df['low']\n    atr = tr.rolling(window=14).mean()\n    \n    # Volume weighted by close price\n    volume_weighted = df['volume'] * df['close']\n    \n    # Composite heuristic\n    heuristics_matrix = (sma_ratio + rsi - atr + volume_weighted) / 4\n    return heuristics_matrix",
          "objective": -0.0356,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite factor by incorporating longer-term moving averages, adjusting the momentum calculation period, and including a relative strength index (RSI) to capture overbought or oversold conditions.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate simple moving averages\n    sma_10 = df['close'].rolling(window=10).mean()\n    sma_30 = df['close'].rolling(window=30).mean()\n    sma_ratio = (sma_10 / sma_30) - 1\n    \n    # Momentum indicator\n    momentum = df['close'] / df['close'].shift(10) - 1\n    \n    # Volatility measure\n    daily_returns = df['close'].pct_change()\n    volatility = daily_returns.rolling(window=20).std()\n    \n    # Price range\n    price_range = (df['high'] - df['low']) / df['close']\n    \n    # Volume weighted by close price\n    volume_weighted = df['volume'] * df['close']\n    \n    # Relative Strength Index (RSI)\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Composite heuristic\n    heuristics_matrix = (sma_ratio + momentum - volatility + price_range + volume_weighted + rsi) / 6\n    return heuristics_matrix",
          "objective": -0.03552,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a set of technical and fundamental heuristics based on price and volume data, using exponential moving averages, a modified RSI with a shorter lookback period, and the standard deviation of returns to create a composite factor aimed at predicting future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate exponential moving averages\n    ema_5 = df['close'].ewm(span=5, adjust=False).mean()\n    ema_10 = df['close'].ewm(span=10, adjust=False).mean()\n    ema_ratio = (ema_5 / ema_10) - 1\n    \n    # Modified Relative Strength Index (RSI) with a 7-day lookback\n    delta = df['close'].diff(1)\n    gain = (delta.where(delta > 0, 0)).rolling(window=7).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=7).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Standard Deviation of Returns\n    std_dev = df['close'].pct_change().rolling(window=21).std()\n    \n    # Volume weighted by close price\n    volume_weighted = df['volume'] * df['close']\n    \n    # Composite heuristic\n    heuristics_matrix = (ema_ratio + rsi - std_dev + volume_weighted) / 4\n    return heuristics_matrix",
          "objective": -0.03551,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a set of technical and fundamental heuristics based on price and volume data, combining moving averages, momentum indicators, and volatility measures to create a composite factor aimed at predicting future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate simple moving averages\n    sma_5 = df['close'].rolling(window=5).mean()\n    sma_10 = df['close'].rolling(window=10).mean()\n    sma_ratio = (sma_5 / sma_10) - 1\n    \n    # Momentum indicator\n    momentum = df['close'] / df['close'].shift(5) - 1\n    \n    # Volatility measure\n    daily_returns = df['close'].pct_change()\n    volatility = daily_returns.rolling(window=20).std()\n    \n    # Price range\n    price_range = (df['high'] - df['low']) / df['close']\n    \n    # Volume weighted by close price\n    volume_weighted = df['volume'] * df['close']\n    \n    # Composite heuristic\n    heuristics_matrix = (sma_ratio + momentum - volatility + price_range + volume_weighted) / 5\n    return heuristics_matrix",
          "objective": -0.03499,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm modifies the original by using exponential moving averages, adjusting the momentum lookback period, and incorporating the average true range for volatility, aiming to generate a more responsive and robust composite factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate exponential moving averages\n    ema_5 = df['close'].ewm(span=5, adjust=False).mean()\n    ema_10 = df['close'].ewm(span=10, adjust=False).mean()\n    ema_ratio = (ema_5 / ema_10) - 1\n    \n    # Momentum indicator with adjusted lookback\n    momentum = df['close'] / df['close'].shift(10) - 1\n    \n    # Volatility measure using average true range\n    tr = df['high'] - df['low']\n    atr = tr.rolling(window=14).mean()\n    \n    # Price range\n    price_range = (df['high'] - df['low']) / df['close']\n    \n    # Volume weighted by close price\n    volume_weighted = df['volume'] * df['close']\n    \n    # Composite heuristic\n    heuristics_matrix = (ema_ratio + momentum - atr + price_range + volume_weighted) / 5\n    return heuristics_matrix",
          "objective": -0.03493,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm integrates a trend-following signal using the Exponential Moving Average (EMA) crossover, a relative strength comparison with the overall market, and a cash flow indicator based on the product of volume and price changes.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate short and long EMA\n    ema_short = df['close'].ewm(span=12, adjust=False).mean()\n    ema_long = df['close'].ewm(span=26, adjust=False).mean()\n    \n    # EMA crossover signal\n    ema_crossover = ema_short - ema_long\n    \n    # Relative Strength Indicator compared to the overall market\n    df['market_close'] = df.groupby(df.index)['close'].transform('mean')  # Assuming 'df' contains multiple stocks\n    relative_strength = df['close'] / df['market_close'] - 1\n    \n    # Cash Flow Indicator\n    cash_flow = (df['volume'] * (df['close'] - df['close'].shift(1))).cumsum()\n    \n    # Combine the factors into a heuristics matrix, assigning equal weights for simplicity\n    heuristics_matrix = (ema_crossover + relative_strength + cash_flow) / 3\n    \n    return heuristics_matrix",
          "objective": -0.02326,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm modifies the original by changing the periods for the weighted moving averages, adjusting the ROC lookback period, and altering the ATR calculation window, alongside incorporating a simple moving average (SMA) as an additional component.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate weighted moving averages\n    wma_7 = df['close'].ewm(span=7, adjust=False).mean()\n    wma_14 = df['close'].ewm(span=14, adjust=False).mean()\n    wma_ratio = (wma_7 / wma_14) - 1\n    \n    # Rate of Change (ROC) indicator\n    roc = (df['close'] - df['close'].shift(7)) / df['close'].shift(7)\n    \n    # Average True Range (ATR) for volatility\n    tr = df['high'] - df['low']\n    atr = tr.rolling(window=10).mean()\n    \n    # Price range\n    price_range = (df['high'] - df['low']) / df['close']\n    \n    # Volume momentum\n    volume_momentum = df['volume'] / df['volume'].shift(3) - 1\n    \n    # Simple Moving Average (SMA)\n    sma_50 = df['close'].rolling(window=50).mean()\n    sma_signal = (df['close'] - sma_50) / df['close']\n    \n    # Composite heuristic\n    heuristics_matrix = (wma_ratio + roc - atr + price_range + volume_momentum + sma_signal) / 6\n    return heuristics_matrix",
          "objective": -0.02116,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm computes an alpha factor by integrating the percentage change in closing price with the average true range over a 10-day period, aiming to capture both momentum and volatility.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Percentage Change in Closing Price\n    pct_change = df['close'].pct_change()\n    \n    # Average True Range (ATR)\n    tr1 = df['high'] - df['low']\n    tr2 = abs(df['high'] - df['close'].shift())\n    tr3 = abs(df['low'] - df['close'].shift())\n    true_range = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)\n    atr = true_range.rolling(window=10).mean()\n    \n    # Heuristics matrix combining percentage change and ATR\n    heuristics_matrix = pct_change + atr\n    return heuristics_matrix",
          "objective": -0.02064,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm will integrate directional movement (as captured through a smoothed difference between high and low prices using an exponential moving average), with the mean reversion tendency (using the distance between the current close price and its long-term exponentially weighted moving average) and liquidity (measured via the exponentially smoothed cumulative volume at closing prices).",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Directional Movement Index (DMI) with Exponential Smoothing\n    dmi = (df['high'] - df['low']).ewm(span=10).mean()\n    \n    # Mean Reversion Component with Exponential Weighted Moving Average\n    mean_reversion = df['close'] - df['close'].ewm(span=50).mean()\n    \n    # Liquidity Indicator based on Exponentially Smoothed Cumulative Volume Adjusted Close\n    liquidity = ((df['close'] * df['volume']).cumsum()).ewm(span=20).mean()\n    \n    # Combine the factors into a heuristics matrix, assigning equal weights for simplicity\n    heuristics_matrix = (dmi + mean_reversion + liquidity) / 3\n    \n    return heuristics_matrix",
          "objective": -0.02061,
          "other_inf": null
     }
]