[
     {
          "algorithm": "A new algorithm for generating alpha factors that adjusts the weights and periods of trend, momentum, and volatility indicators to predict future stock returns.",
          "code": "def heuristics_v2(df):\n    # Calculate simple moving averages with different windows\n    sma_short = df['close'].rolling(window=20).mean()\n    sma_long = df['close'].rolling(window=50).mean()\n    \n    # Calculate the difference between short and long SMAs\n    sma_diff = sma_short - sma_long\n    \n    # Calculate the rate of change over 20 periods\n    roc_20 = df['close'].pct_change(periods=20)\n    \n    # Calculate the average true range over 21 periods\n    tr = df['high'] - df['low']\n    atr_21 = tr.rolling(window=21).mean()\n    \n    # Combine the factors into a single heuristics matrix with new weights\n    heuristics_matrix = 0.6 * sma_diff + 0.2 * roc_20 - 0.2 * atr_21\n    \n    return heuristics_matrix",
          "objective": -0.01878,
          "other_inf": null
     },
     {
          "algorithm": "A novel algorithm for generating alpha factors that combines trend, momentum, and volatility indicators to predict future stock returns through a weighted aggregation approach.",
          "code": "import pandas as pd\n    \n    # Calculate simple moving averages\n    sma_short = df['close'].rolling(window=10).mean()\n    sma_long = df['close'].rolling(window=30).mean()\n    \n    # Calculate the difference between short and long SMAs\n    sma_diff = sma_short - sma_long\n    \n    # Calculate the rate of change over 12 periods\n    roc_12 = df['close'].pct_change(periods=12)\n    \n    # Calculate the average true range over 14 periods\n    tr = df['high'] - df['low']\n    atr_14 = tr.rolling(window=14).mean()\n    \n    # Combine the factors into a single heuristics matrix\n    heuristics_matrix = 0.5 * sma_diff + 0.3 * roc_12 - 0.2 * atr_14\n    \n    return heuristics_matrix",
          "objective": -0.01584,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a proprietary factor by dividing the ratio of the current closing price to the average of the high and low prices over the past 20 days, minus the exponential moving average of the volume over the same period, aiming to capture relative strength and liquidity dynamics.",
          "code": "def heuristics_v2(df):\n    avg_high_low = (df['high'].rolling(window=20).mean() + df['low'].rolling(window=20).mean()) / 2\n    vol_ema = df['volume'].ewm(span=20, adjust=False).mean()\n    heuristics_matrix = (df['close'] / avg_high_low) - vol_ema\n    return heuristics_matrix",
          "objective": -0.01397,
          "other_inf": null
     },
     {
          "algorithm": "A modified version of the algorithm that introduces a momentum indicator based on the exponential moving average (EMA) and a volatility measure using Bollinger Bands to enhance the signal for predicting future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate short and long period Exponential Moving Averages\n    ema_short = df['close'].ewm(span=10, adjust=False).mean()\n    ema_long = df['close'].ewm(span=30, adjust=False).mean()\n    \n    # Difference between short and long EMAs\n    ema_diff = ema_short - ema_long\n    \n    # Rate of change over 12 periods\n    roc_12 = df['close'].pct_change(periods=12)\n    \n    # Bollinger Bands: Middle Band (20-day SMA), Upper and Lower Bands\n    mb = df['close'].rolling(window=20).mean()\n    bb_width = 2 * df['close'].rolling(window=20).std()\n    \n    # Heuristic matrix combining EMA difference, ROC, and Bollinger Bands width\n    heuristics_matrix = 0.5 * ema_diff + 0.3 * roc_12 - 0.2 * bb_width\n    \n    return heuristics_matrix",
          "objective": -0.00832,
          "other_inf": null
     }
]