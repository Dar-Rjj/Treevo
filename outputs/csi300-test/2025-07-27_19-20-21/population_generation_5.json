[
     {
          "algorithm": "The new algorithm integrates the concepts of trend and mean reversion by combining the Percentage Price Oscillator (PPO) with the Bollinger Bands to generate a signal that predicts future stock returns.",
          "code": "def heuristics_v3(df):\n    # Calculate the 12-period EMA and 26-period EMA\n    ema_12 = df['close'].ewm(span=12, adjust=False).mean()\n    ema_26 = df['close'].ewm(span=26, adjust=False).mean()\n    \n    # Calculate the Percentage Price Oscillator (PPO)\n    ppo_line = ((ema_12 - ema_26) / ema_26) * 100\n    \n    # Calculate Bollinger Bands\n    sma_20 = df['close'].rolling(window=20).mean()\n    std_20 = df['close'].rolling(window=20).std()\n    upper_band = sma_20 + (2 * std_20)\n    lower_band = sma_20 - (2 * std_20)\n    \n    # Calculate the %B indicator (position within Bollinger Bands)\n    b_percentage = (df['close'] - lower_band) / (upper_band - lower_band)\n    \n    # Combine PPO and %B into a single heuristic matrix\n    heuristics_matrix = 0.5 * ppo_line + 0.5 * (1 - b_percentage)\n    \n    return heuristics_matrix",
          "objective": -0.03909,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm combines the Williams %R, On-Balance Volume (OBV), and the Aroon Oscillator to assess overbought/oversold conditions, cumulative buying/selling pressure, and short-term trend strength.",
          "code": "def heuristics_v2(df):\n    # Calculate Williams %R\n    highest_high = df['high'].rolling(window=14).max()\n    lowest_low = df['low'].rolling(window=14).min()\n    williams_r = -100 * (highest_high - df['close']) / (highest_high - lowest_low)\n    \n    # Calculate On-Balance Volume (OBV)\n    obv = (df['volume'] * ((df['close'] > df['close'].shift(1)).astype(int) - (df['close'] < df['close'].shift(1)).astype(int))).cumsum()\n    \n    # Calculate Aroon Oscillator\n    aroon_up = 100 * df['high'].rolling(window=25).apply(lambda x: (x.argmax() + 1) / 25)\n    aroon_down = 100 * df['low'].rolling(window=25).apply(lambda x: (x.argmin() + 1) / 25)\n    aroon_oscillator = aroon_up - aroon_down\n    \n    # Combine Williams %R, OBV, and Aroon Oscillator into a single heuristic matrix\n    heuristics_matrix = 0.4 * williams_r + 0.3 * obv + 0.3 * aroon_oscillator\n    \n    return heuristics_matrix",
          "objective": -0.02818,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite heuristic score by combining the relative strength index (RSI) with the moving average convergence divergence (MACD) and the Chaikin Money Flow (CMF), with different weights and periods for RSI, MACD, and CMF.",
          "code": "def heuristics_v2(df):\n    # Calculate RSI\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=10).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=10).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate MACD\n    ema_9 = df['close'].ewm(span=9, adjust=False).mean()\n    ema_21 = df['close'].ewm(span=21, adjust=False).mean()\n    macd_line = ema_9 - ema_21\n    signal_line = macd_line.ewm(span=5, adjust=False).mean()\n    macd_hist = macd_line - signal_line\n    \n    # Calculate Chaikin Money Flow\n    mfm = ((df['close'] - df['low']) - (df['high'] - df['close'])) / (df['high'] - df['low'])\n    mf_volume = mfm * df['volume']\n    cmf = mf_volume.rolling(window=15).sum() / df['volume'].rolling(window=15).sum()\n    \n    # Combine RSI, MACD, and CMF into a single heuristic matrix\n    heuristics_matrix = 0.5 * rsi + 0.2 * macd_hist + 0.3 * cmf\n    \n    return heuristics_matrix",
          "objective": -0.0249,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a composite heuristic score by combining the relative strength index (RSI) with the moving average convergence divergence (MACD) and the Chaikin Money Flow (CMF) to assess momentum, trend, and money flow respectively.",
          "code": "def heuristics_v2(df):\n    # Calculate RSI\n    delta = df['close'].diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rs = gain / loss\n    rsi = 100 - (100 / (1 + rs))\n    \n    # Calculate MACD\n    ema_12 = df['close'].ewm(span=12, adjust=False).mean()\n    ema_26 = df['close'].ewm(span=26, adjust=False).mean()\n    macd_line = ema_12 - ema_26\n    signal_line = macd_line.ewm(span=9, adjust=False).mean()\n    macd_hist = macd_line - signal_line\n    \n    # Calculate Chaikin Money Flow\n    mfm = ((df['close'] - df['low']) - (df['high'] - df['close'])) / (df['high'] - df['low'])\n    mf_volume = mfm * df['volume']\n    cmf = mf_volume.rolling(window=20).sum() / df['volume'].rolling(window=20).sum()\n    \n    # Combine RSI, MACD, and CMF into a single heuristic matrix\n    heuristics_matrix = 0.4 * rsi + 0.3 * macd_hist + 0.3 * cmf\n    \n    return heuristics_matrix",
          "objective": -0.0222,
          "other_inf": null
     }
]