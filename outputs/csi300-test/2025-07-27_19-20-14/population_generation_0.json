[
     {
          "algorithm": "The algorithm calculates a momentum-based alpha factor by considering the difference between the 20-day and 50-day simple moving averages of closing prices, combined with a volatility adjustment based on the standard deviation of returns over the same period.",
          "code": "def heuristics_v2(df):\n    df['SMA_20'] = df['close'].rolling(window=20).mean()\n    df['SMA_50'] = df['close'].rolling(window=50).mean()\n    df['returns'] = df['close'].pct_change()\n    df['volatility'] = df['returns'].rolling(window=20).std()\n    df['momentum'] = df['SMA_20'] - df['SMA_50']\n    heuristics_matrix = (df['momentum'] / df['volatility']).fillna(0)\n    return heuristics_matrix",
          "objective": -0.00837,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a custom momentum indicator based on the difference between the closing price and the average of the high and low prices, then scales this by the volume, aiming to capture both price dynamics and trading activity.",
          "code": "def heuristics_v2(df):\n    df['price_diff'] = df['close'] - (df['high'] + df['low']) / 2\n    df['heuristic_factor'] = df['price_diff'] * df['volume']\n    heuristics_matrix = df['heuristic_factor'].copy()\n    return heuristics_matrix",
          "objective": -0.00708,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm extracts a custom ratio of the difference between the adjusted close price and the average of high and low prices over a rolling window, aiming to capture momentum and volatility aspects.",
          "code": "def heuristics_v2(df):\n    heuristics_matrix = (df['close'] - (df['high'] + df['low']) / 2).rolling(window=10).mean()\n    return heuristics_matrix",
          "objective": -0.00318,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm identifies patterns in the historical price and volume data to generate a set of heuristics based on moving averages, volatility, and trading volume to predict future stock returns.",
          "code": "def heuristics_v2(df):\n    heuristics_matrix = (df['close'].rolling(window=10).mean() - df['close'].rolling(window=30).mean()) / df['close'].rolling(window=30).std() + (df['volume'] - df['volume'].rolling(window=10).mean()) / df['volume'].rolling(window=10).std()\n    return heuristics_matrix",
          "objective": -0.00268,
          "other_inf": null
     }
]