```python
import pandas as pd
import numpy as np
from scipy.stats import zscore

def heuristics_v2(df):
    # Calculate Intraday Return
    intraday_return = df['close'] - df['open']
    
    # Calculate Intraday High-Low Range
    high_low_range = df['high'] - df['low']
    
    # Combine Intraday Return and High-Low Range
    combined_factor = intraday_return * high_low_range
    
    # Smooth using Adaptive Exponential Moving Average (AEMA)
    def aema(data, fast_alpha, slow_alpha):
        alpha = np.where(data > data.shift(1), fast_alpha, slow_alpha)
        aema = data.ewm(alpha=alpha).mean()
        return aema
    
    smoothed_factor = aema(combined_factor, fast_alpha=0.2, slow_alpha=0.05)
    
    # Apply Volume Weighting
    volume_weighted_factor = smoothed_factor * df['volume']
    
    # Incorporate Previous Day's Closing Gap
    closing_gap = df['open'].diff()
    volume_weighted_smoothed_factor = volume_weighted_factor + closing_gap
    
    # Integrate Long-Term Momentum
    long_term_return = df['close'] - df['close'].shift(50)
    normalized_long_term_return = long_term_return / high_low_range
    
    # Include Enhanced Dynamic Volatility Component
    intraday_returns_rolling_std = df['close'].pct_change().rolling(window=20).std()
    atr = df[['high', 'low', 'close']].join(df[['high', 'low', 'close']].shift(1)).max(axis=1) - \
          df[['high', 'low', 'close']].join(df[['high', 'low', 'close']].shift(1)).min(axis=1)
    atr = atr.rolling(window=14).mean()
    combined_volatility = (intraday_returns_rolling_std + atr) / 2
    
    # Adjust Volatility Component with Volume
    volume_adjusted_volatility = combined_volatility * df['volume']
    
    # Incorporate Market Sentiment
    sentiment_score = df.get('sentiment', 0)  # Assuming external sentiment data is available in the DataFrame
    scaled_sentiment_score = 2 * (sentiment_score - sentiment_score.min()) / (sentiment_score.max() - sentiment_score.min()) - 1
    
    # Incorporate Liquidity Metrics
    turnover_ratio = df['volume'] / df.get('shares_outstanding', 1)  # Assuming shares outstanding is available
    bid_ask_spread = df.get('ask_price', df['high']) - df.get('bid_price', df['low'])  # Assuming bid and ask prices are available
    
    # Final Factor Calculation
    final_factor = (volume_weighted_smoothed_factor +
                    normalized_long_term_return +
                    volume_adjusted_volatility +
                    scaled_sentiment_score +
                    turnover_ratio +
                    bid_ask_spread)
    
    # Apply Non-Linear Transformation
    final_factor = np.log(1 + final_factor)
    
    return final_factor
```
