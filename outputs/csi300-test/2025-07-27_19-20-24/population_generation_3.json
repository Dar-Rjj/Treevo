[
     {
          "algorithm": "The new algorithm calculates a factor based on the ratio of the daily return to the sum of the absolute difference between the daily high and the previous day's close, and the daily low and the previous day's close, over the past 20 days.",
          "code": "def heuristics_v2(df):\n    daily_return = df['close'].pct_change()\n    diff_high_close = (df['high'] - df['close'].shift(1)).abs()\n    diff_low_close = (df['low'] - df['close'].shift(1)).abs()\n    avg_diff = (diff_high_close + diff_low_close).rolling(window=20).mean()\n    heuristics_matrix = daily_return / avg_diff\n    return heuristics_matrix",
          "objective": -0.02896,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a factor based on the ratio of the daily return to the average daily range (high minus low) over the past 20 days, aiming to capture the stock's volatility-adjusted performance.",
          "code": "def heuristics_v2(df):\n    daily_return = df['close'].pct_change()\n    avg_range = (df['high'] - df['low']).rolling(window=20).mean()\n    heuristics_matrix = daily_return / avg_range\n    return heuristics_matrix",
          "objective": -0.02414,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm incorporates a 12-month momentum, a 90-day moving average of the standard deviation over the last 180 days for volatility, and a 10-day change in the average volume for liquidity, combining these with different weights to predict future returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Long-term momentum: 12-month return\n    long_momentum = df['close'].pct_change(240)\n    \n    # Medium-term volatility trend: 90-day moving average of standard deviation over the last 180 days\n    vol_trend_180 = df['close'].pct_change().rolling(window=180).std().rolling(window=90).mean()\n    \n    # Short-term liquidity shift: Change in the 10-day average volume\n    avg_vol_10 = df['volume'].rolling(window=10).mean()\n    liquidity_shift = (avg_vol_10 - avg_vol_10.shift(1)) / avg_vol_10.shift(1)\n    \n    # Composite heuristic score\n    heuristics_matrix = 0.5 * long_momentum + 0.3 * (1/vol_trend_180) + 0.2 * liquidity_shift\n    \n    return heuristics_matrix",
          "objective": -0.02185,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a composite factor by combining momentum, volatility, and liquidity indicators, specifically using the rate of change, standard deviation, and volume changes over different time frames.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Calculate rate of change (Momentum Indicator) for 10 days\n    roc_10 = df['close'].pct_change(periods=10)\n    \n    # Calculate standard deviation (Volatility Indicator) for 20 days\n    std_20 = df['close'].rolling(window=20).std()\n    \n    # Calculate percentage change in volume (Liquidity Indicator) for 5 days\n    vol_change_5 = df['volume'].pct_change(periods=5)\n    \n    # Create a composite heuristic\n    heuristics_matrix = (roc_10 + std_20 + vol_change_5) / 3\n    \n    return heuristics_matrix",
          "objective": -0.02158,
          "other_inf": null
     }
]