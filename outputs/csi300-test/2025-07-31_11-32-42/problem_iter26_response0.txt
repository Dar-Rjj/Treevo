```python
import pandas as pd
import numpy as np

def heuristics_v2(df):
    # Calculate Intraday High-Low Spread
    intraday_high_low_spread = df['high'] - df['low']
    
    # Evaluate Open-to-Close Movement
    open_to_close_movement = df['close'] - df['open']
    
    # Integrate Intraday and Opening Gaps
    integrated_metric = intraday_high_low_spread - open_to_close_movement
    
    # Incorporate Advanced Volume Impact
    log_volume = np.log(df['volume'] + 1)
    volume_adjusted_metric = integrated_metric * log_volume
    
    # Factor in Adjusted Price Range as a Stability Measure
    price_range_ratio = (df['high'] - df['low']) / (df['open'] + df['close'])
    stability_adjusted_metric = volume_adjusted_metric / price_range_ratio
    
    # Calculate Volume-Weighted Prices
    vwap_close = (df['close'] * df['volume']).cumsum() / df['volume'].cumsum()
    vwap_open = (df['open'] * df['volume']).cumsum() / df['volume'].cumsum()
    
    # Synthesize VWAPCHL into the Model
    vwapchl = (vwap_close - vwap_open) / (df['high'] - df['low'])
    
    # Incorporate Momentum Indicators
    N = 20
    M = 10
    P = 14
    Q = 10
    sma = df['close'].rolling(window=N).mean()
    roc = (df['close'] / df['close'].shift(M) - 1) * 100
    gain = (df['close'] - df['close'].shift(1)).clip(lower=0)
    loss = (df['close'] - df['close'].shift(1)).clip(upper=0)
    avg_gain = gain.rolling(window=P).mean()
    avg_loss = abs(loss.rolling(window=P).mean())
    rs = avg_gain / avg_loss
    mom = df['close'] - df['close'].shift(Q)
    
    # Incorporate Volume-Related Features
    R = 10
    S = 10
    typical_price = (df['high'] + df['low'] + df['close']) / 3
    vwap = (typical_price * df['volume']).cumsum() / df['volume'].cumsum()
    vroc = (df['volume'] / df['volume'].shift(S) - 1) * 100
    obv = (np.sign(df['close'].diff()) * df['volume']).cumsum()
    
    # Generate Volatility-Based Factors
    T = 14
    U = 20
    tr = df[['high', 'low']].apply(lambda x: max(x['high'] - x['low'], 
                                                  x['high'] - df['close'].shift(1), 
                                                  df['close'].shift(1) - x['low']), axis=1)
    atr = tr.rolling(window=T).mean()
    std_dev = df['close'].rolling(window=U).std()
    
    # Create Open-Close Relationship Factors
    ocr = df['close'] / df['open']
    gs = df['open'] - df['close'].shift(1)
    
    # Final Integration
    final_factor = (
        stability_adjusted_metric * vwapchl * 
        (sma + roc + rs + mom) + 
        (vwap + vroc + obv) + 
        (atr + std_dev) + 
        (ocr + gs)
    )
    
    return final_factor
```
