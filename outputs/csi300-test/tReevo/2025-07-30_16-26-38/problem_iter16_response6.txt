```python
import pandas as pd
import numpy as np

def heuristics_v2(df):
    # Calculate Close-to-Open Return
    df['close_to_open_return'] = df['open'].shift(-1) - df['close']
    
    # Volume Weighting
    df['volume_weighted_return'] = df['close_to_open_return'] * df['volume']
    
    # Determine Dynamic Volatility
    df['true_range'] = df[['high', 'low', 'close']].max(axis=1) - df[['high', 'low', 'close']].min(axis=1)
    df['volatility'] = df['true_range'].rolling(window=20).std()
    df['ema_volatility'] = df['volatility'].ewm(span=20, adjust=False).mean()
    
    # Adjust Window Size Based on Dynamic Volatility
    def get_window_size(ema_vol):
        if ema_vol > df['ema_volatility'].median():
            return 5  # High volatility, smaller window
        else:
            return 20  # Low volatility, larger window
    
    df['window_size'] = df['ema_volatility'].apply(get_window_size)
    
    # Incorporate Momentum
    momentum_period = 10
    df['momentum'] = df['close'].pct_change(momentum_period)
    df['adjusted_volume_weighted_return'] = df['volume_weighted_return'] * df['momentum']
    
    # Rolling Statistics with Adaptive Window
    rolling_mean = []
    rolling_std = []
    for i in range(len(df)):
        window = df.iloc[i]['window_size']
        mean = df.loc[:i, 'adjusted_volume_weighted_return'].rolling(window=window).mean().iloc[-1]
        std = df.loc[:i, 'adjusted_volume_weighted_return'].rolling(window=window).std().iloc[-1]
        rolling_mean.append(mean)
        rolling_std.append(std)
    
    df['rolling_mean'] = rolling_mean
    df['rolling_std'] = rolling_std
    
    # Final Alpha Factor
    df['alpha_factor'] = (df['adjusted_volume_weighted_return'] - df['rolling_mean']) / df['rolling_std']
    
    return df['alpha_factor'].dropna()
```
