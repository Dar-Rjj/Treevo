```python
import pandas as pd
import numpy as np

def heuristics_v2(df):
    # Calculate Close-to-Open Return
    df['close_to_open_return'] = df['close'].shift(-1) - df['open']
    
    # Volume Weighting
    df['volume_weighted_return'] = df['close_to_open_return'] * df['volume']
    
    # Adaptive Window Calculation
    # Determine Volatility using High, Low, and Close prices
    df['true_range'] = df[['high', 'low', 'close']].apply(lambda x: max(x) - min(x), axis=1)
    df['volatility'] = df['true_range'].rolling(window=20).std()
    
    # Adjust Window Size based on Volatility
    df['window_size'] = 60
    df.loc[df['volatility'] > df['volatility'].mean(), 'window_size'] = 30
    df.loc[df['volatility'] < df['volatility'].mean(), 'window_size'] = 90
    
    # Momentum and Liquidity Considerations
    df['momentum'] = df['close'].pct_change().rolling(window=20).mean()
    df['liquidity'] = df['volume'].rolling(window=20).mean()
    
    # Rolling Statistics with Adaptive Window
    def rolling_stats(x, window):
        return x.rolling(window=window).agg(['mean', 'std'])
    
    df['adaptive_window_mean'] = np.nan
    df['adaptive_window_std'] = np.nan
    
    for i in range(len(df)):
        window = int(df.iloc[i]['window_size'])
        if i + window <= len(df):
            stats = rolling_stats(df['volume_weighted_return'][i:i+window], window)
            df.at[df.index[i], 'adaptive_window_mean'] = stats['mean'].iloc[-1]
            df.at[df.index[i], 'adaptive_window_std'] = stats['std'].iloc[-1]
    
    # Combine Metrics
    df['adjusted_factor'] = (df['adaptive_window_mean'] / df['adaptive_window_std']) * df['momentum'] * df['liquidity']
    
    # Return the factor values
    return df['adjusted_factor'].dropna()

# Example usage:
# df = pd.read_csv('your_data.csv', index_col='date', parse_dates=True)
# factor_values = heuristics_v2(df)
# print(factor_values)
```
