```python
import pandas as pd
import numpy as np

def heuristics_v2(df):
    # Calculate Close-to-Open Return
    df['close_to_open_return'] = df['open'].shift(-1) - df['close']
    
    # Enhanced Volume and Amount Weighting
    df['volume_amount_weighted_return'] = (df['volume'] + df['amount']) * df['close_to_open_return']
    
    # Dynamic Volatility Thresholds
    df['volatility'] = df[['high', 'low', 'close']].rolling(window=30).std().mean(axis=1)
    high_vol_threshold = df['volatility'].quantile(0.75)
    low_vol_threshold = df['volatility'].quantile(0.25)
    
    # Adjust window size based on volatility
    def get_window_size(volatility, high_vol, low_vol):
        if volatility > high_vol:
            return 5
        elif volatility < low_vol:
            return 60
        else:
            return 30
    
    df['window_size'] = df['volatility'].apply(lambda vol: get_window_size(vol, high_vol_threshold, low_vol_threshold))
    
    # Rolling Statistics with adaptive windows
    df['weighted_return_mean'] = df.groupby('window_size')['volume_amount_weighted_return'].transform(lambda x: x.rolling(x.name).mean())
    df['weighted_return_std'] = df.groupby('window_size')['volume_amount_weighted_return'].transform(lambda x: x.rolling(x.name).std())
    
    # Alpha factor: z-score of the weighted close-to-open return
    df['alpha_factor'] = (df['volume_amount_weighted_return'] - df['weighted_return_mean']) / df['weighted_return_std']
    
    return df['alpha_factor'].dropna()
```
