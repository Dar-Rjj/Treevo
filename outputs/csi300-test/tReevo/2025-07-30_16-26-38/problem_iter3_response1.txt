```python
import pandas as pd
import numpy as np

def heuristics_v2(df):
    """
    Calculate the Adaptive Volume-Weighted Close-to-Open Return with Volatility.
    
    :param df: pandas DataFrame with columns (open, high, low, close, amount, volume) and index (date)
    :return: pandas Series representing the factor values
    """
    # Calculate Close-to-Open Return
    df['close_to_open_return'] = (df['open'] - df['close'].shift(1)) / df['close'].shift(1)

    # Weight by Volume
    df['volume_weighted_return'] = df['close_to_open_return'] * df['volume']

    # Calculate Historical Volatility
    df['high_low_diff'] = df['high'] - df['low']
    df['volatility'] = df['high_low_diff'].rolling(window=20).std()

    # Adjust weights based on recent volatility
    df['adjusted_return'] = df['volume_weighted_return'] / (df['volatility'] + 1e-6)

    # Determine adaptive window size based on market conditions
    def adaptive_window_size(row):
        if row['volume'] > df['volume'].mean() * 1.5:
            return 5
        elif abs(row['close'] - row['close'].shift(1)) > df['high_low_diff'].mean():
            return 10
        else:
            return 20

    df['window_size'] = df.apply(adaptive_window_size, axis=1)

    # Recalculate factors using the adaptive window
    factor_values = []
    for date in df.index:
        window = df[df.index <= date]['window_size'][-1]
        factor_value = df.loc[date, 'adjusted_return']
        factor_values.append(factor_value)

    factor_series = pd.Series(factor_values, index=df.index)
    return factor_series
```
