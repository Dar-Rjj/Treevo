```python
import pandas as pd
import numpy as np

def heuristics_v2(df):
    # Calculate Close-to-Open Return
    df['close_to_open_return'] = df['open'].shift(-1) - df['close']
    
    # Volume Weighting
    df['volume_ema'] = df['volume'].ewm(span=20, adjust=False).mean()
    df['volume_weight'] = np.where(df['volume'] > df['volume_ema'], 1.2, 0.8)
    df['volume_weighted_return'] = df['close_to_open_return'] * df['volume_weight']
    
    # Adaptive Window Calculation
    df['hlc_volatility'] = df[['high', 'low', 'close']].pct_change().rolling(window=20).std().mean(axis=1)
    adaptive_window = np.where(df['hlc_volatility'] > df['hlc_volatility'].median(), 10, 30)
    
    # Rolling Statistics with Adaptive Window
    df['rolling_mean'] = df.groupby('volume_weighted_return')['volume_weighted_return'].transform(lambda x: x.rolling(adaptive_window, min_periods=5).mean())
    df['rolling_std'] = df.groupby('volume_weighted_return')['volume_weighted_return'].transform(lambda x: x.rolling(adaptive_window, min_periods=5).std())
    
    # Dynamic Volatility Adjustment
    df['volatility_ratio'] = df['rolling_std'] / df['volume'].rolling(20).std()
    df['adjusted_weight'] = np.where(df['volatility_ratio'] > df['volatility_ratio'].median(), 1.5, 0.5)
    df['factor_value'] = df['rolling_mean'] * df['adjusted_weight']
    
    return df['factor_value'].dropna()

# Example usage:
# df = pd.read_csv('your_data.csv', parse_dates=['date'])
# df.set_index('date', inplace=True)
# factor_values = heuristics_v2(df)
# print(factor_values)
```
