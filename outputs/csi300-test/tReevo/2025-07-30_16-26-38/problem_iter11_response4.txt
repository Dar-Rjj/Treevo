```python
import pandas as pd
import numpy as np

def heuristics_v2(df):
    # Calculate Close-to-Open Return
    df['Close_to_Open_Return'] = df['open'].shift(-1) - df['close']
    
    # Volume Weighting
    df['Volume_Weighted_Return'] = df['Close_to_Open_Return'] * df['volume']
    
    # Determine Volatility using High, Low, and Close prices
    df['Typical_Price'] = (df['high'] + df['low'] + df['close']) / 3
    df['Volatility'] = df['Typical_Price'].rolling(window=20).std()
    
    # Adjust Window Size Based on Volatility
    def adaptive_window(std):
        if std > df['Volatility'].median():
            return 5  # Smaller window for high volatility
        else:
            return 20  # Larger window for low volatility
    
    # Apply adaptive window function to each row
    df['Adaptive_Window'] = df['Volatility'].apply(adaptive_window)
    
    # Calculate Rolling Statistics with Adaptive Window
    rolling_mean = []
    rolling_std = []
    for i in range(len(df)):
        window_size = int(df['Adaptive_Window'].iloc[i])
        if i < window_size:
            rolling_mean.append(np.nan)
            rolling_std.append(np.nan)
        else:
            mean = df['Volume_Weighted_Return'].iloc[i-window_size:i].mean()
            std = df['Volume_Weighted_Return'].iloc[i-window_size:i].std()
            rolling_mean.append(mean)
            rolling_std.append(std)
    
    df['Rolling_Mean'] = rolling_mean
    df['Rolling_Std'] = rolling_std
    
    # Final alpha factor: normalized rolling mean
    df['Alpha_Factor'] = (df['Rolling_Mean'] - df['Rolling_Mean'].mean()) / df['Rolling_Std']
    
    return df['Alpha_Factor']
```
