```python
import pandas as pd
import numpy as np

def heuristics_v2(df):
    # Calculate Close-to-Open Return
    close_to_open_return = df['open'].shift(-1) - df['close']
    
    # Volume Weighting
    volume_weighted_return = close_to_open_return * df['volume']
    
    # Volatility Calculation
    volatility = df[['high', 'low', 'close']].std(axis=1, ddof=0).rolling(window=5).std()
    
    # Volatility Adjustment
    adjusted_return = volume_weighted_return / (volatility + 1e-8)  # Adding a small constant to avoid division by zero
    
    # Adaptive Window Calculation based on Volatility
    def adaptive_window(volatility, low_vol_threshold=0.1, high_vol_threshold=0.3):
        if volatility < low_vol_threshold:
            return 20
        elif volatility > high_vol_threshold:
            return 5
        else:
            return 10
    
    # Apply the adaptive window function to get the window sizes
    window_sizes = volatility.apply(adaptive_window)
    
    # Rolling Statistics with Adaptive Window
    rolling_mean = adjusted_return.rolling(window=window_sizes, min_periods=1).mean()
    rolling_std = adjusted_return.rolling(window=window_sizes, min_periods=1).std()
    
    # Final Factor: Z-Score of the Adjusted Return
    factor = (adjusted_return - rolling_mean) / (rolling_std + 1e-8)  # Adding a small constant to avoid division by zero
    
    return factor
```
