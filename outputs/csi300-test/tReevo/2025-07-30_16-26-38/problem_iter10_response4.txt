```python
import pandas as pd
import numpy as np

def heuristics_v2(df):
    # Calculate Close-to-Open Return
    df['next_open'] = df['open'].shift(-1)
    df['close_to_open_return'] = df['next_open'] - df['close']
    
    # Volume Weighting
    df['volume_weighted_return'] = df['close_to_open_return'] * df['volume']
    
    # True Range
    df['tr1'] = df['high'] - df['low']
    df['tr2'] = (df['high'] - df['close'].shift(1)).abs()
    df['tr3'] = (df['low'] - df['close'].shift(1)).abs()
    df['true_range'] = df[['tr1', 'tr2', 'tr3']].max(axis=1)
    
    # Average True Range and Standard Deviation of Close Prices
    df['atr_20'] = df['true_range'].rolling(window=20).mean()
    df['std_close_20'] = df['close'].rolling(window=20).std()
    
    # Determine Adaptive Window Size
    def adaptive_window(atr, std_close):
        if atr > std_close:
            return 5  # Decrease window size
        else:
            return 15  # Increase window size
    
    df['window_size'] = df.apply(lambda row: adaptive_window(row['atr_20'], row['std_close_20']), axis=1)
    df['window_size'] = df['window_size'].fillna(method='ffill').fillna(15)  # Fill initial NaNs with 15
    
    # Rolling Mean and Standard Deviation of Volume Weighted Close-to-Open Return
    rolling_mean = df.groupby('window_size')['volume_weighted_return'].transform(lambda x: x.rolling(min(len(x), int(x.name))).mean())
    rolling_std = df.groupby('window_size')['volume_weighted_return'].transform(lambda x: x.rolling(min(len(x), int(x.name))).std())
    
    # Final Alpha Factor
    df['alpha_factor'] = (df['volume_weighted_return'] - rolling_mean) / rolling_std
    return df['alpha_factor']
```
