```python
import pandas as pd
import numpy as np

def heuristics_v2(df):
    # Calculate Close-to-Open Return
    df['close_to_open_return'] = df['open'].shift(-1) - df['close']
    
    # Volume Weighting
    df['volume_weighted_return'] = df['close_to_open_return'] * df['volume']
    
    # Volatility Calculation
    df['volatility'] = df['high'].rolling(window=20).std() + df['low'].rolling(window=20).std() + df['close'].rolling(window=20).std()
    
    # Adaptive Window Size
    def get_adaptive_window_size(volatility, min_window=5, max_window=20):
        if volatility > 0.5:
            return min_window
        elif volatility < 0.2:
            return max_window
        else:
            return int((max_window - min_window) * (volatility - 0.2) / 0.3) + min_window
    
    # Apply adaptive window size
    df['window_size'] = df['volatility'].apply(get_adaptive_window_size)
    
    # Rolling Statistics
    df['rolling_mean'] = df.apply(lambda row: df.loc[:row.name, 'volume_weighted_return'].rolling(window=row['window_size']).mean().iloc[-1], axis=1)
    df['rolling_std'] = df.apply(lambda row: df.loc[:row.name, 'volume_weighted_return'].rolling(window=row['window_size']).std().iloc[-1], axis=1)
    
    # Normalize the factor
    df['factor'] = (df['volume_weighted_return'] - df['rolling_mean']) / df['rolling_std']
    
    # Return the factor
    return df['factor']

# Example usage:
# df = pd.read_csv('your_data.csv', index_col='date', parse_dates=True)
# factor_values = heuristics_v2(df)
# print(factor_values)
```
