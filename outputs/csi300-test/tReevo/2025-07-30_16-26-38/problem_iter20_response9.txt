```python
import pandas as pd

def heuristics_v2(df):
    # Calculate Close-to-Open Return
    df['close_to_open_return'] = df['open'].shift(-1) - df['close']
    
    # Volume Weighting
    df['volume_weighted_return'] = df['close_to_open_return'] * df['volume']
    
    # Dynamic Volatility Adjustment
    def calculate_volatility(high, low, close, window=20):
        return (high - low) / close.rolling(window).std()
    
    df['volatility'] = calculate_volatility(df['high'], df['low'], df['close'])
    
    # Define volatility multipliers
    def volatility_multiplier(volatility, high_threshold=0.05, low_threshold=0.02):
        if volatility > high_threshold:
            return 1.2  # High volatility multiplier
        elif volatility < low_threshold:
            return 0.8  # Low volatility multiplier
        else:
            return 1.0  # Neutral multiplier
    
    df['volatility_multiplier'] = df['volatility'].apply(volatility_multiplier)
    df['adjusted_return'] = df['volume_weighted_return'] * df['volatility_multiplier']
    
    # Refined Adaptive Window Calculation
    def adaptive_window_size(volatility, base_window=20, high_volatility_decrease=5, low_volatility_increase=10):
        if volatility > 0.05:
            return max(base_window - high_volatility_decrease, 5)  # Minimum window size of 5
        elif volatility < 0.02:
            return min(base_window + low_volatility_increase, 50)  # Maximum window size of 50
        else:
            return base_window
    
    df['window_size'] = df['volatility'].apply(adaptive_window_size)
    
    # Rolling Statistics
    def rolling_stats(series, window_series):
        result = []
        for i in range(len(series)):
            window = int(window_series.iloc[i])
            if i < window:
                result.append(None)
            else:
                result.append(series.iloc[i-window:i].mean())
        return pd.Series(result, index=series.index)
    
    df['rolling_mean'] = rolling_stats(df['adjusted_return'], df['window_size'])
    df['rolling_std'] = df['adjusted_return'].rolling(window=df['window_size']).std()
    
    # Alpha Factor
    df['alpha_factor'] = df['rolling_mean'] / df['rolling_std']
    
    return df['alpha_factor'].dropna()

# Example usage
# df = pd.read_csv('your_data.csv', parse_dates=['date'], index_col='date')
# alpha_factor = heuristics_v2(df)
# print(alpha_factor)
```
