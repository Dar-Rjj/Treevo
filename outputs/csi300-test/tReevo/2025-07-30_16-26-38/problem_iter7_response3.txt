```python
import pandas as pd
import numpy as np

def heuristics_v2(df):
    # Calculate Close-to-Open Return
    df['Close_to_Open_Return'] = df['open'].shift(-1) - df['close']
    
    # Volume Weighting
    df['Volume_Weighted_Return'] = df['Close_to_Open_Return'] * df['volume']
    
    # Volatility Calculation
    df['High_Low_Closing_Volatility'] = (df['high'] - df['low']) / df['close']
    volatility_rolling_std = df['High_Low_Closing_Volatility'].rolling(window=20).std()
    df['Volatility'] = volatility_rolling_std
    
    # Adaptive Window Size
    def adaptive_window(volatility, low_vol_threshold=0.005, high_vol_threshold=0.015, min_window=10, max_window=30):
        if volatility < low_vol_threshold:
            return max_window
        elif volatility > high_vol_threshold:
            return min_window
        else:
            return int((max_window - min_window) * (volatility - low_vol_threshold) / (high_vol_threshold - low_vol_threshold)) + min_window
        
    df['Adaptive_Window_Size'] = df['Volatility'].apply(adaptive_window)
    
    # Rolling Statistics
    rolling_mean = df.apply(lambda x: df['Volume_Weighted_Return'].rolling(window=x['Adaptive_Window_Size']).mean(), axis=1)
    rolling_std = df.apply(lambda x: df['Volume_Weighted_Return'].rolling(window=x['Adaptive_Window_Size']).std(), axis=1)
    
    df['Rolling_Mean_Adaptive'] = rolling_mean
    df['Rolling_Std_Adaptive'] = rolling_std
    
    # Final Factor
    df['Alpha_Factor'] = (df['Volume_Weighted_Return'] - df['Rolling_Mean_Adaptive']) / df['Rolling_Std_Adaptive']

    return df['Alpha_Factor'].shift(1)  # Shift to align with the current date for trading
```
