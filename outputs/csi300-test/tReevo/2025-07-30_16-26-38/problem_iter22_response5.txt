```python
import pandas as pd
import numpy as np
from scipy.stats import linregress

def heuristics_v2(df):
    # Calculate Close-to-Open Return
    df['Close_to_Open_Return'] = df['open'].shift(-1) - df['close']
    
    # Volume Weighting
    df['Volume_Weighted_Return'] = df['Close_to_Open_Return'] * df['volume']
    
    # Incorporate Liquidity
    rolling_avg_volume = df['volume'].rolling(window=20).mean()
    df['Liquidity_Adjusted_Return'] = df['Volume_Weighted_Return'] / rolling_avg_volume
    
    # Adaptive Window Calculation
    def calculate_volatility(high, low, close, window=20):
        hl_diff = high - low
        hc_diff = np.abs(high - close.shift(1))
        lc_diff = np.abs(low - close.shift(1))
        tr = np.maximum(hl_diff, np.maximum(hc_diff, lc_diff))
        return tr.rolling(window=window).std()
    
    volatility = calculate_volatility(df['high'], df['low'], df['close'])
    df['Adaptive_Window'] = 20 + (volatility - volatility.mean()) / volatility.std() * 5
    df['Adaptive_Window'] = df['Adaptive_Window'].clip(lower=10, upper=30)
    
    # Rolling Statistics
    df['Rolling_Mean'] = df.groupby('Liquidity_Adjusted_Return').rolling(window=df['Adaptive_Window'].astype(int)).mean().reset_index(0, drop=True)
    df['Rolling_Std'] = df.groupby('Liquidity_Adjusted_Return').rolling(window=df['Adaptive_Window'].astype(int)).std().reset_index(0, drop=True)
    
    # Incorporate Directional Price Momentum
    def calculate_price_momentum(close, window=5):
        close_values = close.values
        time_values = np.arange(len(close_values))
        slope, _, _, _, _ = linregress(time_values[-window:], close_values[-window:])
        return slope
    
    df['Price_Momentum'] = df['close'].rolling(window=5).apply(calculate_price_momentum, raw=False)
    
    # Combine with Volume Weighted Close-to-Open Return
    df['Final_Factor'] = df['Liquidity_Adjusted_Return'] + df['Price_Momentum']
    
    return df['Final_Factor']
```
