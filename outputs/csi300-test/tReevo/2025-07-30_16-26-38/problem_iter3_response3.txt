```python
import pandas as pd
import numpy as np

def heuristics_v2(df, short_term_window=10, long_term_window=50):
    # Calculate Volume-Weighted Price
    df['volume_weighted_price'] = (df['open'] + df['high'] + df['low'] + df['close']) / 4 * df['volume']
    total_volume = df['volume'].rolling(window=long_term_window).sum()
    df['vwp'] = df['volume_weighted_price'].rolling(window=long_term_window).sum() / total_volume
    
    # Calculate Price Momentum with Adaptive Window
    volatility = df['close'].pct_change().rolling(window=short_term_window).std()
    adaptive_window = (volatility < volatility.rolling(window=long_term_window).quantile(0.5)).astype(int) * short_term_window + \
                     (volatility >= volatility.rolling(window=long_term_window).quantile(0.5)).astype(int) * long_term_window
    df['momentum'] = df['vwp'].pct_change(periods=adaptive_window)
    
    # Calculate Close-to-Open Return
    df['close_to_open_return'] = df['open'] / df['close'].shift(1) - 1
    
    # Combine Volume-Weighted Momentum and Close-to-Open Return
    df['factor'] = df['momentum'] + df['close_to_open_return']
    
    # Return the factor as a Series
    return df['factor'].dropna()

# Example usage
# df = pd.DataFrame({
#     'open': [...],
#     'high': [...],
#     'low': [...],
#     'close': [...],
#     'amount': [...],
#     'volume': [...]
# }, index=pd.to_datetime([...]))
# factor = heuristics_v2(df)
```
