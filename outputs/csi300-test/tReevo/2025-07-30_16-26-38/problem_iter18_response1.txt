```python
import pandas as pd
import numpy as np

def heuristics_v2(df):
    # Calculate Close-to-Open Return
    df['Close_to_Open_Return'] = df['open'].shift(-1) - df['close']
    
    # Volume Weighting
    df['Volume_Weighted_Return'] = df['Close_to_Open_Return'] * df['volume']
    
    # Adaptive Window Calculation
    def calculate_volatility(high, low, close, window=20):
        hl_diff = high - low
        hc_diff = np.abs(high - close.shift(1))
        lc_diff = np.abs(low - close.shift(1))
        tr = np.maximum(hl_diff, np.maximum(hc_diff, lc_diff))
        return tr.rolling(window=window).std()
    
    df['Volatility'] = calculate_volatility(df['high'], df['low'], df['close'])
    volatility_median = df['Volatility'].median()
    
    def adjust_window(volatility, high_vol_threshold, low_vol_threshold):
        if volatility > high_vol_threshold:
            return 5  # Decrease window size
        elif volatility < low_vol_threshold:
            return 30  # Increase window size
        else:
            return 10  # Default window size
    
    df['Adaptive_Window'] = df['Volatility'].apply(lambda x: adjust_window(x, 1.5 * volatility_median, 0.5 * volatility_median))
    
    # Rolling Statistics
    df['Rolling_Mean'] = df.groupby('Adaptive_Window')['Volume_Weighted_Return'].transform(lambda x: x.rolling(window=x.name, min_periods=1).mean())
    df['Rolling_Std'] = df.groupby('Adaptive_Window')['Volume_Weighted_Return'].transform(lambda x: x.rolling(window=x.name, min_periods=1).std())
    
    # Factor Value
    df['Factor_Value'] = (df['Volume_Weighted_Return'] - df['Rolling_Mean']) / df['Rolling_Std']
    
    return df['Factor_Value']
```
