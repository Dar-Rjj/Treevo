```python
import pandas as pd
import numpy as np

def heuristics_v2(df):
    # Calculate Close-to-Open Return
    df['close_to_open_return'] = df['open'].shift(-1) - df['close']
    
    # Volume Weighting
    df['volume_weighted_return'] = df['close_to_open_return'] * df['volume']

    # Volatility Calculation using True Range
    df['true_range'] = df[['high', 'low', 'close']].apply(lambda x: max(x[0] - x[1], abs(x[0] - x[2]), abs(x[1] - x[2])), axis=1)
    
    # Rolling Standard Deviation of True Range over a fixed window (e.g., 20 days)
    fixed_window = 20
    df['tr_volatility'] = df['true_range'].rolling(window=fixed_window).std()
    
    # Adaptive Window Calculation based on Volatility
    def adaptive_window(volatility, high_threshold, low_threshold, high_window, low_window, mid_window):
        if volatility > high_threshold:
            return high_window
        elif volatility < low_threshold:
            return low_window
        else:
            return mid_window
    
    high_threshold = 0.01
    low_threshold = 0.005
    high_window = 5
    low_window = 30
    mid_window = 10
    
    df['adaptive_window'] = df['tr_volatility'].apply(adaptive_window, args=(high_threshold, low_threshold, high_window, low_window, mid_window))
    
    # Rolling Statistics with Adaptive Window
    df['rolling_mean'] = df.groupby('adaptive_window')['volume_weighted_return'].transform(lambda x: x.rolling(window=x.name).mean())
    df['rolling_std'] = df.groupby('adaptive_window')['volume_weighted_return'].transform(lambda x: x.rolling(window=x.name).std())
    
    # Volatility Adjusted Factor
    df['volatility_adjusted_factor'] = df['rolling_mean'] / df['rolling_std']
    
    # Drop rows with NaN values
    df.dropna(inplace=True)
    
    # Return the factor values as a pandas Series
    return df['volatility_adjusted_factor']
```
