```python
import pandas as pd
import numpy as np

def heuristics_v2(df):
    # Calculate Close-to-Open Return
    df['close_to_open_return'] = df['open'].shift(-1) - df['close']
    
    # Volume Weighting
    df['volume_ema'] = df['volume'].ewm(span=20, adjust=False).mean()
    volume_momentum = np.where(df['volume'] > df['volume_ema'], 1.5, 0.5)
    df['volume_weighted_return'] = df['close_to_open_return'] * df['volume'] * volume_momentum
    
    # Adaptive Window Calculation
    df['volatility'] = df[['high', 'low', 'close']].std(axis=1).rolling(window=20).mean()
    base_window_size = 20
    df['adaptive_window'] = np.where(df['volatility'] > df['volatility'].mean(), max(5, base_window_size - 5), min(30, base_window_size + 5))
    
    # Rolling Statistics
    def rolling_stats(series, window):
        return series.rolling(window=window, min_periods=1).mean(), series.rolling(window=window, min_periods=1).std()

    windows = df['adaptive_window'].astype(int)
    df['rolling_mean'] = df.groupby(windows)['volume_weighted_return'].transform(lambda x: x.rolling(window=x.name, min_periods=1).mean())
    df['rolling_std'] = df.groupby(windows)['volume_weighted_return'].transform(lambda x: x.rolling(window=x.name, min_periods=1).std())

    # Final Alpha Factor
    df['alpha_factor'] = (df['volume_weighted_return'] - df['rolling_mean']) / df['rolling_std']
    
    return df['alpha_factor']
```
