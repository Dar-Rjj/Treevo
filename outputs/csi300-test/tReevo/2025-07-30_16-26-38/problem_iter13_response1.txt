```python
import pandas as pd
import numpy as np

def heuristics_v2(df):
    # Calculate Close-to-Open Return
    df['NextDayOpen'] = df['open'].shift(-1)
    df['CloseToOpenReturn'] = df['NextDayOpen'] - df['close']
    
    # Volume Weighting
    df['VolumeWeightedReturn'] = df['CloseToOpenReturn'] * df['volume']
    
    # Determine Volatility using High, Low, and Close prices
    df['Volatility'] = df[['high', 'low', 'close']].rolling(window=20).std().mean(axis=1)
    
    # Define thresholds for high and low volatility
    high_vol_threshold = df['Volatility'].quantile(0.75)
    low_vol_threshold = df['Volatility'].quantile(0.25)
    
    # Adjust Window Size Based on Volatility
    def adjust_window(vol):
        if vol > high_vol_threshold:
            return 10
        elif vol < low_vol_threshold:
            return 30
        else:
            return 20
    
    df['AdaptiveWindow'] = df['Volatility'].apply(adjust_window)
    
    # Calculate Rolling Statistics with Adaptive Window
    def rolling_stats(series, window_series):
        results = []
        for i in range(len(series)):
            window = int(window_series.iloc[i])
            if i < window - 1:
                results.append(np.nan)
            else:
                results.append(series[i - window + 1:i + 1].mean())
        return pd.Series(results, index=series.index)
    
    df['RollingMean'] = rolling_stats(df['VolumeWeightedReturn'], df['AdaptiveWindow'])
    df['RollingStd'] = rolling_stats(df['VolumeWeightedReturn'] ** 2, df['AdaptiveWindow']).apply(np.sqrt)
    
    # Calculate the final factor
    df['AlphaFactor'] = (df['RollingMean'] / df['RollingStd']).fillna(0)
    
    return df['AlphaFactor']
```
