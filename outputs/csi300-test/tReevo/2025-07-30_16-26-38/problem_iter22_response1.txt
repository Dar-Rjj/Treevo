```python
import pandas as pd
import numpy as np

def heuristics_v2(df):
    # Calculate Close-to-Open Return
    df['close_to_open_return'] = df['open'].shift(-1) - df['close']
    
    # Volume Weighting
    df['volume_weighted_return'] = df['close_to_open_return'] * df['volume']
    
    # Determine Volatility using High, Low, and Close prices
    df['true_range'] = np.maximum(np.maximum(df['high'] - df['low'], abs(df['high'] - df['close'].shift(1))), 
                                  abs(df['low'] - df['close'].shift(1)))
    df['atr_14'] = df['true_range'].rolling(window=14).mean()
    df['std_close_14'] = df['close'].rolling(window=14).std()
    df['composite_volatility'] = (df['atr_14'] + df['std_close_14']) / 2
    
    # Adjust Window Size based on Composite Volatility
    def adjust_window_size(vol):
        if vol > df['composite_volatility'].quantile(0.75):
            return 5  # Decrease window size
        else:
            return 20  # Increase window size
        
    df['window_size'] = df['composite_volatility'].apply(adjust_window_size)
    
    # Rolling Statistics with Adaptive Window
    def rolling_stats(x, window):
        return x.rolling(window=window).mean(), x.rolling(window=window).std()
    
    df['rolling_mean'] = np.nan
    df['rolling_std'] = np.nan
    
    for idx, row in df.iterrows():
        window = int(row['window_size'])
        mean, std = rolling_stats(df.loc[:idx, 'volume_weighted_return'], window)
        df.at[idx, 'rolling_mean'] = mean.iloc[-1]
        df.at[idx, 'rolling_std'] = std.iloc[-1]
    
    # Factor Value
    df['alpha_factor'] = (df['rolling_mean'] - df['rolling_std']) / df['rolling_std']
    
    return df['alpha_factor'].dropna()
```
