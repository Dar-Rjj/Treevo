```python
import pandas as pd
import numpy as np

def heuristics_v2(df):
    # Calculate Intraday Range
    df['intraday_range'] = df['high'] - df['low']
    
    # Calculate Intraday Volatility (last 20 days average)
    df['intraday_volatility'] = df['intraday_range'].rolling(window=20).mean()
    
    # Calculate Daily Return
    df['daily_return'] = df['close'].pct_change()
    
    # Calculate Adjusted Momentum (sum of last 20 days' daily returns)
    df['adjusted_momentum'] = df['daily_return'].rolling(window=20).sum()
    
    # Divide by Intraday Volatility to get the final adjusted momentum score
    df['adjusted_momentum_score'] = df['adjusted_momentum'] / df['intraday_volatility']
    
    # Incorporate Volume Weighting
    df['average_volume'] = df['volume'].rolling(window=20).mean()
    df['volume_weighted_momentum'] = df['adjusted_momentum_score'] * df['average_volume']
    
    # Incorporate Market Sentiment
    df['market_return'] = df['close'].pct_change()
    df['volume_weighted_momentum'] = df['volume_weighted_momentum'] * np.where(df['market_return'] > 0, 1.05, 0.95)
    
    # Multi-Period Analysis
    periods = [10, 20, 30, 40]
    results = []
    for period in periods:
        df[f'intraday_volatility_{period}'] = df['intraday_range'].rolling(window=period).mean()
        df[f'adjusted_momentum_{period}'] = df['daily_return'].rolling(window=period).sum()
        df[f'adjusted_momentum_score_{period}'] = df[f'adjusted_momentum_{period}'] / df[f'intraday_volatility_{period}']
        df[f'average_volume_{period}'] = df['volume'].rolling(window=period).mean()
        df[f'volume_weighted_momentum_{period}'] = df[f'adjusted_momentum_score_{period}'] * df[f'average_volume_{period}']
        df[f'volume_weighted_momentum_{period}'] = df[f'volume_weighted_momentum_{period}'] * np.where(df['market_return'] > 0, 1.05, 0.95)
        results.append(df[f'volume_weighted_momentum_{period}'])
    
    # Adaptive Weighting
    std_devs = [df[r].std() for r in results]
    weights = 1 / (np.array(std_devs) + 1e-8)  # Add small constant to avoid division by zero
    weights = weights / weights.sum()  # Normalize weights
    
    # Combine the results using a weighted sum
    combined_factor = sum(w * r for w, r in zip(weights, results))
    
    return combined_factor
```
