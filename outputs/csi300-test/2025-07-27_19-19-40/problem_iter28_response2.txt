```python
def heuristics_v2(df: pd.DataFrame) -> pd.Series:
    # Calculate adaptive rolling means based on volatility (using standard deviation over 20 periods)
    df['std_20'] = df['close'].rolling(window=20).std()
    window_size = (df['std_20'] / df['std_20'].mean()).apply(lambda x: max(5, min(20, int(10 * x))))
    
    # Short-term rolling mean of close prices with adaptive window
    df['short_term_rolling_mean_close'] = df.apply(lambda row: df.loc[:row.name, 'close'][-window_size[row.name]:].mean(), axis=1)
    
    # Long-term rolling mean of close prices with fixed 20-period window
    df['long_term_rolling_mean_close'] = df['close'].rolling(window=20).mean()

    # Momentum factor using the difference between the current close and the short-term rolling mean, scaled by the current volume
    momentum_factor = (df['close'] - df['short_term_rolling_mean_close']) * df['volume']

    # Mean reversion ratio using the short-term and long-term rolling means
    mean_reversion_ratio = df['short_term_rolling_mean_close'] / df['long_term_rolling_mean_close']

    # Volatility factor (inverse of standard deviation to capture risk aversion)
    volatility_factor = 1 / df['std_20']

    # Liquidity factor (amount/volume as a measure of price per unit traded, high values indicate more liquidity)
    liquidity_factor = df['amount'] / df['volume']

    # Market sentiment factor (using the positive/negative change in close prices over 14 periods)
    delta = df['close'].diff(1)
    gain = (delta.where(delta > 0, 0)).rolling(window=14).sum()
    loss = (-delta.where(delta < 0, 0)).rolling(window=14).sum()
    market_sentiment = (gain - loss) / (gain + loss)

    # Combine the momentum, mean reversion, volatility, liquidity, and market sentiment factors
    alpha_factor = 0.3 * momentum_factor + 0.2 * mean_reversion_ratio + 0.1 * volatility_factor + 0.2 * liquidity_factor + 0.2 * market_sentiment

    return alpha_factor
```
