```python
import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression

def heuristics_v2(df):
    # Momentum factor
    short_term_return = df['close'].pct_change(5)
    medium_term_return = df['close'].pct_change(20)
    momentum_factor = 0.7 * short_term_return + 0.3 * medium_term_return

    # Volume-based alpha factor
    N = 20
    average_volume = df['volume'].rolling(window=N).mean()
    volume_ratio = df['volume'] / average_volume
    volume_change = df['volume'].pct_change()
    
    M = 10
    volume_trend = df['volume'].rolling(window=M).apply(lambda x: np.polyfit(range(M), x, 1)[0], raw=False)
    volume_consistency = df['volume'].diff().rolling(window=N).std()
    
    volume_factor = (volume_ratio + volume_change + volume_trend - volume_consistency) / 4

    # Volatility-based alpha factor
    price_range = df['high'] - df['low']
    P = 20
    close_std = df['close'].rolling(window=P).std()
    volatility_measure = np.sqrt(price_range * close_std)
    volatility_trend = price_range.rolling(window=P).apply(lambda x: np.polyfit(range(P), x, 1)[0], raw=False)
    volatility_factor = (volatility_measure + volatility_trend) / 2

    # Transaction amount-based alpha factor
    transaction_amount = df['amount']
    Q = 20
    R = 10
    transaction_amount_sum = transaction_amount.rolling(window=Q).sum()
    transaction_stability = transaction_amount.rolling(window=Q).std() / transaction_amount.rolling(window=Q).mean()
    transaction_trend = transaction_amount.rolling(window=R).apply(lambda x: np.polyfit(range(R), x, 1)[0], raw=False)
    transaction_factor = (transaction_amount_sum + transaction_trend - transaction_stability) / 3

    # Gap opening factor
    S = 20
    gap_opening = df['open'] - df['close'].shift(1)
    positive_gaps = gap_opening.rolling(window=S).apply(lambda x: (x > 0).sum(), raw=False)
    negative_gaps = gap_opening.rolling(window=S).apply(lambda x: (x < 0).sum(), raw=False)
    gap_intensity = gap_opening.abs().rolling(window=S).mean()
    gap_trend = gap_opening.rolling(window=S).apply(lambda x: np.polyfit(range(S), x, 1)[0], raw=False)
    gap_factor = (positive_gaps - negative_gaps + gap_intensity + gap_trend) / 4

    # Combine all factors into a single composite factor
    composite_factor = (
        0.25 * momentum_factor +
        0.25 * volume_factor +
        0.25 * volatility_factor +
        0.25 * transaction_factor +
        0.25 * gap_factor
    )

    return composite_factor
```
