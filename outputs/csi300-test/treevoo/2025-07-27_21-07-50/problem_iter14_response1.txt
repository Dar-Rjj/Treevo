```python
import pandas as pd
import numpy as np

def heuristics_v2(df):
    # Calculate 5-day and 20-day SMA of Close Price
    df['SMA_5'] = df['close'].rolling(window=5).mean()
    df['SMA_20'] = df['close'].rolling(window=20).mean()
    
    # Determine the relationship between 5-day and 20-day SMA of Close Price
    df['SMA_trend'] = np.where(df['SMA_5'] > df['SMA_20'], 1, -1)
    
    # Calculate 5-day SMA of Volume
    df['SMA_vol_5'] = df['volume'].rolling(window=5).mean()
    
    # Evaluate the change in 5-day SMA of Volume
    df['SMA_vol_change'] = df['SMA_vol_5'].pct_change()
    
    # Calculate Daily Price Range (High - Low)
    df['daily_range'] = df['high'] - df['low']
    
    # Compute the Average Daily Price Range over the past 20 days
    df['avg_daily_range_20'] = df['daily_range'].rolling(window=20).mean()
    
    # Calculate the ratio of today's Daily Price Range to the 20-day Average Daily Price Range
    df['range_ratio'] = df['daily_range'] / df['avg_daily_range_20']
    
    # Assess the gap between Open and Close Prices
    df['gap'] = df['open'] - df['close'].shift(1)
    
    # Analyze the distribution and frequency of positive versus negative gaps
    df['positive_gap'] = df['gap'].apply(lambda x: 1 if x > 0 else 0)
    df['negative_gap'] = df['gap'].apply(lambda x: 1 if x < 0 else 0)
    
    # Calculate the Volume-Weighted Average Price (VWAP) for each day
    df['VWAP'] = (df['amount'] / df['volume']).cumsum() / (df['volume'].cumsum())
    
    # Use VWAP to identify significant deviations from the average price
    df['VWAP_deviation'] = (df['close'] - df['VWAP']) / df['VWAP']
    
    # Compare VWAP trends with simple moving averages to highlight divergences
    df['VWAP_vs_SMA_20'] = np.where(df['VWAP'] > df['SMA_20'], 1, -1)
    
    # Compute the 14-day Relative Strength Index (RSI) based on close prices
    def rsi(series, n=14):
        delta = series.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=n).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=n).mean()
        rs = gain / loss
        return 100 - (100 / (1 + rs))
    
    df['RSI_14'] = rsi(df['close'])
    
    # Evaluate overbought and oversold conditions using RSI
    df['RSI_signal'] = np.where(df['RSI_14'] > 70, 1, np.where(df['RSI_14'] < 30, -1, 0))
    
    # Integrate RSI with SMA signals to filter out potential false breakout signals
    df['combined_signal'] = df['SMA_trend'] * df['RSI_signal']
    
    # Calculate the standard deviation of high, low, and close prices over the last 30 days
    df['std_high_30'] = df['high'].rolling(window=30).std()
    df['std_low_30'] = df['low'].rolling(window=30).std()
    df['std_close_30'] = df['close'].rolling(window=30).std()
    
    # Examine the ratio of the 30-day standard deviation to the daily return
    df['daily_return'] = df['close'].pct_change()
    df['volatility_ratio'] = (df['std_close_30'] / df['daily_return']).replace([np.inf, -np.inf], np.nan).fillna(0)
    
    # Track the net amount traded at the bid versus the ask
    df['net_amount'] = df['amount'] - df['amount'].shift(1)
    
    # Measure the imbalance ratio over a specific period
    df['imbalance_ratio'] = df['net_amount'].rolling(window=10).sum() / df['volume'].rolling(window=10).sum()
    

