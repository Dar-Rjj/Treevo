```python
import pandas as pd
import numpy as np

def heuristics_v2(df):
    # Momentum factor
    sma_14 = df['close'].rolling(window=14).mean()
    sma_50 = df['close'].rolling(window=50).mean()
    momentum = sma_14 - sma_50
    
    # Volatility
    daily_returns = df['close'].pct_change()
    volatility = daily_returns.rolling(window=20).std()
    
    # Volume ratio
    volume_7 = df['volume'].rolling(window=7).mean()
    volume_21 = df['volume'].rolling(window=21).mean()
    volume_ratio = volume_7 / volume_21
    
    # Money Flow Index
    typical_price = (df['high'] + df['low'] + df['close']) / 3
    raw_money_flow = typical_price * df['volume']
    positive_money_flow = np.where(typical_price > typical_price.shift(1), raw_money_flow, 0)
    negative_money_flow = np.where(typical_price < typical_price.shift(1), raw_money_flow, 0)
    positive_money_flow_sum = positive_money_flow.rolling(window=14).sum()
    negative_money_flow_sum = negative_money_flow.rolling(window=14).sum()
    money_flow_ratio = positive_money_flow_sum / negative_money_flow_sum
    mfi = 100 - (100 / (1 + money_flow_ratio))
    
    # Relative strength
    ema_14 = df['close'].ewm(span=14, adjust=False).mean()
    ema_200 = df['close'].ewm(span=200, adjust=False).mean()
    relative_strength = ema_14 / ema_200
    
    # Market sentiment
    market_sentiment = (df['close'] - df['open']).rolling(window=10).sum()
    
    # Combine factors
    recent_performance = {
        'momentum': momentum.dropna().tail(30).mean(),
        'volatility': -volatility.dropna().tail(30).mean(),  # Use negative as we want lower volatility
        'volume_ratio': volume_ratio.dropna().tail(30).mean(),
        'mfi': mfi.dropna().tail(30).mean(),
        'relative_strength': relative_strength.dropna().tail(30).mean(),
        'market_sentiment': market_sentiment.dropna().tail(30).mean()
    }
    
    total_weight = sum(recent_performance.values())
    if total_weight == 0:
        total_weight = 1  # To avoid division by zero
    normalized_weights = {k: v/total_weight for k, v in recent_performance.items()}
    
    combined_factors = (
        normalized_weights['momentum'] * momentum +
        normalized_weights['volatility'] * (-volatility) +
        normalized_weights['volume_ratio'] * volume_ratio +
        normalized_weights['mfi'] * mfi +
        normalized_weights['relative_strength'] * relative_strength +
        normalized_weights['market_sentiment'] * market_sentiment
    )
    
    # Apply logistic function to the weighted sum
    bounded_output = 1 / (1 + np.exp(-combined_factors))
    
    return bounded_output
```
