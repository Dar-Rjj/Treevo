```python
import pandas as pd
import numpy as np

def heuristics_v2(df):
    # Calculate 5-day and 20-day SMA of Close Price
    df['SMA_5_close'] = df['close'].rolling(window=5).mean()
    df['SMA_20_close'] = df['close'].rolling(window=20).mean()
    
    # Determine the relationship between 5-day and 20-day SMA of Close Price to indicate trend direction
    df['SMA_trend'] = df['SMA_5_close'] - df['SMA_20_close']
    
    # Calculate 5-day SMA of Volume
    df['SMA_5_volume'] = df['volume'].rolling(window=5).mean()
    
    # Evaluate the change in 5-day SMA of Volume as a potential indicator of liquidity and interest
    df['SMA_volume_change'] = df['SMA_5_volume'].pct_change()
    
    # Calculate Daily Price Range (High - Low)
    df['price_range'] = df['high'] - df['low']
    
    # Compute the Average Daily Price Range over the past 20 days
    df['avg_price_range_20'] = df['price_range'].rolling(window=20).mean()
    
    # Calculate the ratio of today's Daily Price Range to the 20-day Average Daily Price Range
    df['price_range_ratio'] = df['price_range'] / df['avg_price_range_20']
    
    # Assess the gap between Open and Close Prices
    df['gap'] = df['open'] - df['close']
    
    # Analyze the distribution and frequency of positive versus negative gaps
    df['gap_sign'] = np.sign(df['gap'])
    
    # Calculate the Volume-Weighted Average Price (VWAP) for each day
    df['VWAP'] = (df['amount'] / df['volume']).cumsum() / (df['volume']).cumsum()
    
    # Use VWAP to identify significant deviations from the average price
    df['VWAP_deviation'] = df['close'] - df['VWAP']
    
    # Compare VWAP trends with simple moving averages to highlight divergences
    df['VWAP_SMA_diff'] = df['VWAP'] - df['SMA_20_close']
    
    # Compute the 14-day Relative Strength Index (RSI) based on close prices
    delta = df['close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
    RS = gain / loss
    df['RSI'] = 100 - (100 / (1 + RS))
    
    # Evaluate overbought and oversold conditions using RSI
    df['RSI_signal'] = np.where(df['RSI'] > 70, 1, np.where(df['RSI'] < 30, -1, 0))
    
    # Integrate RSI with SMA signals to filter out potential false breakout signals
    df['combined_signal'] = (df['SMA_trend'] > 0) & (df['RSI_signal'] != 1)
    
    # Calculate the standard deviation of high, low, and close prices over the last 30 days
    df['std_30'] = df[['high', 'low', 'close']].rolling(window=30).std().mean(axis=1)
    
    # Examine the ratio of the 30-day standard deviation to the daily return
    df['daily_return'] = df['close'].pct_change()
    df['volatility_ratio'] = df['std_30'] / abs(df['daily_return'])
    
    # Use the volatility factor to adjust risk exposure in the trading strategy
    df['risk_adjustment'] = df['volatility_ratio'].rank(pct=True)
    
    # Track the net amount traded at the bid versus the ask
    # Measure the imbalance ratio over a specific period
    # Relate the imbalance ratio to subsequent price movements
    # Analyze the impact of large trades on the order book dynamics
    
    # Final alpha factor
    df['alpha_factor'] = df['combined_signal'] * df['risk_adjustment']
    
    return df['alpha_factor']
```
