```python
import pandas as pd
import numpy as np

def heuristics_v2(df):
    # Momentum and Trend Analysis
    df['weighted_close'] = df['close'].rolling(window=15).apply(lambda x: np.average(x, weights=np.arange(1, 16)), raw=True)
    df['volume_adjusted_momentum'] = (df['close'].pct_change(7) * (df['volume'] / df['volume'].rolling(window=7).mean()))
    
    # Volume Anomaly and Surge Detection
    df['volume_20d_ma'] = df['volume'].rolling(window=20).mean()
    df['volume_surge'] = (df['volume'] - df['volume_20d_ma']) / df['volume_20d_ma']
    df['volume_max_30_ratio'] = df['volume'] / df['volume'].rolling(window=30).max()
    
    # Price Volatility and Stability
    df['recent_volatility'] = df['close'].rolling(window=8).std()
    def calculate_atr(high, low, close, period):
        high_low = high - low
        high_close = np.abs(high - close.shift())
        low_close = np.abs(low - close.shift())
        ranges = pd.concat([high_low, high_close, low_close], axis=1)
        true_range = np.max(ranges, axis=1)
        return true_range.rolling(window=period).mean()
    df['atr_10'] = calculate_atr(df['high'], df['low'], df['close'], 10)
    df['atr_10_lag'] = df['atr_10'].shift(10)
    
    # Reversal and Continuation Patterns
    def engulfing_pattern(row):
        if row['open'] < row['close']:
            prev_row = df.loc[df.index.get_loc(row.name) - 1]
            if prev_row['open'] > prev_row['close'] and prev_row['close'] <= row['open'] and prev_row['open'] >= row['close']:
                next_row = df.loc[df.index.get_loc(row.name) + 1] if df.index.get_loc(row.name) + 1 < len(df) else None
                if next_row is not None and next_row['open'] > row['close']:
                    return 1  # Bullish Engulfing
        elif row['open'] > row['close']:
            prev_row = df.loc[df.index.get_loc(row.name) - 1]
            if prev_row['open'] < prev_row['close'] and prev_row['close'] >= row['open'] and prev_row['open'] <= row['close']:
                next_row = df.loc[df.index.get_loc(row.name) + 1] if df.index.get_loc(row.name) + 1 < len(df) else None
                if next_row is not None and next_row['open'] < row['close']:
                    return -1  # Bearish Engulfing
        return 0
    df['engulfing_pattern'] = df.apply(engulfing_pattern, axis=1)
    
    def doji_pattern(row):
        body_size = abs(row['close'] - row['open'])
        if body_size <= (row['high'] - row['low']) * 0.1:
            next_row = df.loc[df.index.get_loc(row.name) + 1] if df.index.get_loc(row.name) + 1 < len(df) else None
            if next_row is not None:
                if next_row['close'] > row['close']:
                    return 1  # Bullish Doji
                elif next_row['close'] < row['close']:
                    return -1  # Bearish Doji
        return 0
    df['doji_pattern'] = df.apply(doji_pattern, axis=1)
    
    # Liquidity and Trading Activity
    df['volume_to_amount_ratio'] = df['volume'] / df['amount']
    df['volume_to_amount_ratio_15d_ma'] = df['volume_to_amount_ratio'].rolling(window=15).mean()
    df['up_down_volume_ratio'] = df['volume'].where(df['close'] > df['open']).fillna(0).rolling(window=15).sum() / df['volume'].where(df['close'] < df['open']).fillna(0).rolling(window=15).sum()
    df['up_down_volume_ratio_15d_ma'] = df['up_down_volume_ratio'].rolling(window=15).mean()
    
    # Combine all factors into a single alpha factor
    alpha_factor = (
        df['weighted_close'] +
        df['volume_adjusted_momentum'] +
        df['volume_surge'] +
        df['volume_max_30_ratio'] +
        df['recent
