[
     {
          "algorithm": "The new algorithm evaluates the predictive power of future stock returns by incorporating the rate of change in the adjusted closing price, the ratio of today's volume to the average volume over the past 30 days, and a custom indicator that measures the divergence between the closing price and its 50-day exponential moving average.",
          "code": "def heuristics_v2(df):\n    # Rate of change in adjusted close price over the last 10 days\n    roc_close = (df['close'] - df['close'].shift(10)) / df['close'].shift(10)\n    \n    # Volume relative to the 30-day average volume\n    avg_vol_30d = df['volume'].rolling(window=30).mean()\n    rel_vol = df['volume'] / avg_vol_30d\n    \n    # Divergence: Difference between closing price and 50D EMA\n    ema_50d = df['close'].ewm(span=50, adjust=False).mean()\n    divergence = df['close'] - ema_50d\n    \n    # Combine factors\n    heuristics_matrix = roc_close + 0.4 * rel_vol + 0.6 * divergence\n    \n    return heuristics_matrix",
          "objective": -0.05062,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a heuristic factor based on the weighted combination of price momentum, trading volume relative change, and money flow index to predict future stock returns.",
          "code": "def heuristics_v2(df):\n    def momentum(column):\n        return (column - column.shift(5)) / column.shift(5)\n    \n    def rel_change(column):\n        return (column - column.shift(1)) / column.shift(1)\n        \n    close_momentum = momentum(df['close'])\n    volume_rel_change = rel_change(df['volume'])\n    typical_price = (df['high'] + df['low'] + df['close']) / 3\n    raw_money_flow = typical_price * df['volume']\n    money_flow_ratio = raw_money_flow / raw_money_flow.rolling(window=14).sum()\n    \n    heuristics_matrix = 0.5*close_momentum + 0.3*volume_rel_change + 0.2*money_flow_ratio\n    return heuristics_matrix",
          "objective": -0.02212,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm incorporates the rate of change in price, a measure of relative strength compared to its historical average, and the ratio of current volume to a longer-term moving average volume as factors.",
          "code": "def heuristics_v2(df):\n    # Rate of change in price over the last 20 days\n    roc_price = df['close'].pct_change(20)\n    \n    # Relative Strength: The ratio of the current close price to the 50-day simple moving average\n    sma_50 = df['close'].rolling(window=50).mean()\n    rel_strength = df['close'] / sma_50\n    \n    # Volume Ratio: Current volume divided by the 100-day moving average volume\n    ma_volume_100 = df['volume'].rolling(window=100).mean()\n    volume_ratio = df['volume'] / ma_volume_100\n    \n    # Heuristic matrix combining the factors\n    heuristics_matrix = 0.4 * roc_price + 0.4 * rel_strength + 0.2 * volume_ratio\n    \n    return heuristics_matrix",
          "objective": -0.02203,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a weighted combination of momentum, volatility, and liquidity factors to generate a novel alpha factor, where the weights are determined through historical performance optimization.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Momentum: 1-month return\n    momentum = df['close'].pct_change(21)\n    \n    # Volatility: Standard deviation of daily returns over the last month\n    volatility = df['close'].pct_change().rolling(window=21).std()\n    \n    # Liquidity: Average trading volume over the last month\n    liquidity = df['volume'].rolling(window=21).mean()\n    \n    # Combine factors using fixed weights (for simplicity, in practice, these should be optimized based on backtesting results)\n    heuristics_matrix = 0.5 * momentum - 0.3 * volatility + 0.2 * (liquidity / df['volume'].median())\n    \n    return heuristics_matrix",
          "objective": -0.01714,
          "other_inf": null
     }
]