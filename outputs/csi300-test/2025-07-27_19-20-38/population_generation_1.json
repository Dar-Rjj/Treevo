[
     {
          "algorithm": "The algorithm calculates a heuristic factor based on the weighted combination of price momentum, trading volume relative change, and money flow index to predict future stock returns.",
          "code": "def heuristics_v2(df):\n    def momentum(column):\n        return (column - column.shift(5)) / column.shift(5)\n    \n    def rel_change(column):\n        return (column - column.shift(1)) / column.shift(1)\n        \n    close_momentum = momentum(df['close'])\n    volume_rel_change = rel_change(df['volume'])\n    typical_price = (df['high'] + df['low'] + df['close']) / 3\n    raw_money_flow = typical_price * df['volume']\n    money_flow_ratio = raw_money_flow / raw_money_flow.rolling(window=14).sum()\n    \n    heuristics_matrix = 0.5*close_momentum + 0.3*volume_rel_change + 0.2*money_flow_ratio\n    return heuristics_matrix",
          "objective": -0.02212,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm incorporates the rate of change in price, a measure of relative strength compared to its historical average, and the ratio of current volume to a longer-term moving average volume as factors.",
          "code": "def heuristics_v2(df):\n    # Rate of change in price over the last 20 days\n    roc_price = df['close'].pct_change(20)\n    \n    # Relative Strength: The ratio of the current close price to the 50-day simple moving average\n    sma_50 = df['close'].rolling(window=50).mean()\n    rel_strength = df['close'] / sma_50\n    \n    # Volume Ratio: Current volume divided by the 100-day moving average volume\n    ma_volume_100 = df['volume'].rolling(window=100).mean()\n    volume_ratio = df['volume'] / ma_volume_100\n    \n    # Heuristic matrix combining the factors\n    heuristics_matrix = 0.4 * roc_price + 0.4 * rel_strength + 0.2 * volume_ratio\n    \n    return heuristics_matrix",
          "objective": -0.02203,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a weighted combination of momentum, volatility, and liquidity factors to generate a novel alpha factor, where the weights are determined through historical performance optimization.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Momentum: 1-month return\n    momentum = df['close'].pct_change(21)\n    \n    # Volatility: Standard deviation of daily returns over the last month\n    volatility = df['close'].pct_change().rolling(window=21).std()\n    \n    # Liquidity: Average trading volume over the last month\n    liquidity = df['volume'].rolling(window=21).mean()\n    \n    # Combine factors using fixed weights (for simplicity, in practice, these should be optimized based on backtesting results)\n    heuristics_matrix = 0.5 * momentum - 0.3 * volatility + 0.2 * (liquidity / df['volume'].median())\n    \n    return heuristics_matrix",
          "objective": -0.01714,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm leverages the relative strength of the closing price to its historical highs and lows, combined with the volatility and trading volume changes, to predict future stock returns.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Relative Strength: (Close - 20D Low) / (20D High - 20D Low)\n    high_20d = df['high'].rolling(window=20).max()\n    low_20d = df['low'].rolling(window=20).min()\n    relative_strength = (df['close'] - low_20d) / (high_20d - low_20d)\n    \n    # Volatility: Standard deviation of daily returns over the last 20 days\n    volatility = df['close'].pct_change().rolling(window=20).std()\n    \n    # Volume Change: Percentage change in volume\n    vol_change = df['volume'].pct_change()\n    \n    # Combine factors\n    heuristics_matrix = relative_strength - 0.5 * volatility + 0.3 * vol_change\n    \n    return heuristics_matrix",
          "objective": -0.01292,
          "other_inf": null
     }
]