[
     {
          "algorithm": "The algorithm calculates a heuristic factor based on the weighted combination of price momentum, trading volume relative change, and money flow index to predict future stock returns.",
          "code": "def heuristics_v2(df):\n    def momentum(column):\n        return (column - column.shift(5)) / column.shift(5)\n    \n    def rel_change(column):\n        return (column - column.shift(1)) / column.shift(1)\n        \n    close_momentum = momentum(df['close'])\n    volume_rel_change = rel_change(df['volume'])\n    typical_price = (df['high'] + df['low'] + df['close']) / 3\n    raw_money_flow = typical_price * df['volume']\n    money_flow_ratio = raw_money_flow / raw_money_flow.rolling(window=14).sum()\n    \n    heuristics_matrix = 0.5*close_momentum + 0.3*volume_rel_change + 0.2*money_flow_ratio\n    return heuristics_matrix",
          "objective": -0.02212,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a weighted combination of momentum, volatility, and liquidity factors to generate a novel alpha factor, where the weights are determined through historical performance optimization.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    # Momentum: 1-month return\n    momentum = df['close'].pct_change(21)\n    \n    # Volatility: Standard deviation of daily returns over the last month\n    volatility = df['close'].pct_change().rolling(window=21).std()\n    \n    # Liquidity: Average trading volume over the last month\n    liquidity = df['volume'].rolling(window=21).mean()\n    \n    # Combine factors using fixed weights (for simplicity, in practice, these should be optimized based on backtesting results)\n    heuristics_matrix = 0.5 * momentum - 0.3 * volatility + 0.2 * (liquidity / df['volume'].median())\n    \n    return heuristics_matrix",
          "objective": -0.01714,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a set of heuristic factors based on the relationship between closing price, volume, and moving averages over different time periods to predict future stock returns.",
          "code": "import pandas as pd\n    close = df['close']\n    volume = df['volume']\n    ma_short = close.rolling(window=5).mean()\n    ma_long = close.rolling(window=20).mean()\n    diff_ma = ma_short - ma_long\n    change = close.pct_change()\n    vol_change = volume.pct_change()\n    heuristics_matrix = (diff_ma + change * vol_change) / 2\n    return heuristics_matrix",
          "objective": -0.00828,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates the weighted moving average of price momentum and volume changes over different time horizons to generate a novel alpha factor.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def calculate_weighted_moving_average(series, weights):\n        return (series * weights).sum() / weights.sum()\n    \n    heuristics_matrix = pd.Series(index=df.index)\n    for i in range(len(df)):\n        if i < 10:\n            heuristics_matrix.iloc[i] = 0\n            continue\n        price_changes = df['close'].iloc[i-10:i] - df['close'].iloc[i-11:i-1]\n        volume_changes = df['volume'].iloc[i-10:i] - df['volume'].iloc[i-11:i-1]\n        weights = pd.Series([1/(j+1) for j in range(10)], index=price_changes.index)\n        wma_price = calculate_weighted_moving_average(price_changes, weights)\n        wma_volume = calculate_weighted_moving_average(volume_changes, weights)\n        heuristics_matrix.iloc[i] = wma_price + wma_volume\n    return heuristics_matrix",
          "objective": -0.00529,
          "other_inf": null
     }
]