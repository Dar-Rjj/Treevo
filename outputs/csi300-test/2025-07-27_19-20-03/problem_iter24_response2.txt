```python
def heuristics_v2(df: pd.DataFrame) -> pd.Series:
    # Calculate adaptive moving average window based on volatility
    vol_10d = df['close'].rolling(window=10).std()
    ma_window = (vol_10d / vol_10d.mean() * 5).round().astype(int).clip(lower=3, upper=7)
    ma = df['close'].rolling(window=ma_window, min_periods=1).mean()

    # Calculate the adaptive high-low range
    high_low_diff = (df['high'] - df['low']).rolling(window=ma_window, min_periods=1).mean()

    # Calculate the adaptive volume change
    volume_change = df['volume'].pct_change(periods=ma_window)

    # Calculate the adaptive RSI
    delta = df['close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=ma_window*2, min_periods=1).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=ma_window*2, min_periods=1).mean()
    rs = gain / loss.replace(0, 1e-7)
    rsi = 100 - (100 / (1 + rs))

    # Calculate price deviation and normalize it with volatility and range
    price_deviation = df['close'] - ma
    normalized_price_deviation = price_deviation / (high_low_diff + vol_10d + 1e-7)

    # Calculate the sentiment factor using the ratio of close to open price
    sentiment_factor = df['close'] / df['open']

    # Calculate the market trend factor using the slope of a linear regression over the last 20 days
    from scipy.stats import linregress
    def calculate_trend_slope(data):
        x = np.arange(len(data))
        y = data.values
        slope, _, _, _, _ = linregress(x, y)
        return slope
    trend_slope = df['close'].rolling(window=20, min_periods=1).apply(calculate_trend_slope, raw=False)

    # Calculate the money flow index (MFI)
    typical_price = (df['high'] + df['low'] + df['close']) / 3
    money_flow = typical_price * df['volume']
    positive_money_flow = money_flow.where(typical_price > typical_price.shift(1), 0)
    negative_money_flow = money_flow.where(typical_price < typical_price.shift(1), 0)
    mfi_ratio = positive_money_flow.rolling(window=14, min_periods=1).sum() / \
                (negative_money_flow.rolling(window=14, min_periods=1).sum() + positive_money_flow.rolling(window=14, min_periods=1).sum())
    mfi = 100 - (100 / (1 + mfi_ratio))

    # Dynamic weighting based on recent performance
    def dynamic_weighting(factor, window=10):
        return (factor.rolling(window=window, min_periods=1).mean() / factor.rolling(window=window, min_periods=1).std()).fillna(0)

    weight_price_deviation = dynamic_weighting(normalized_price_deviation)
    weight_volume_change = dynamic_weighting(volume_change)
    weight_rsi = dynamic_weighting(rsi)
    weight_sentiment = dynamic_weighting(sentiment_factor)
    weight_trend = dynamic_weighting(trend_slope)
    weight_mfi = dynamic_weighting(mfi)

    # Combine the factors with dynamic weighting
    total_weight = (weight_price_deviation + weight_volume_change + weight_rsi + weight_sentiment + weight_trend + weight_mfi)
    factor = (normalized_price_deviation * weight_price_deviation + 
              volume_change * weight_volume_change + 
              rsi * weight_rsi + 
              sentiment_factor * weight_sentiment + 
              trend_slope * weight_trend + 
              mfi * weight_mfi) / total_weight

    return factor
```
