[
     {
          "algorithm": "The algorithm computes a novel alpha factor by calculating the weighted sum of daily price changes with weights derived from the volume, aiming to capture the momentum influenced by trading activity.",
          "code": "def heuristics_v2(df):\n    # Calculate daily price change\n    df['price_change'] = df['close'] - df['open']\n    # Compute the weight as the ratio of the day's volume to the rolling sum of the last 5 days' volumes\n    df['volume_weight'] = df['volume'] / df['volume'].rolling(window=5).sum()\n    # The heuristic is the product of the price change and the volume weight\n    heuristics_matrix = (df['price_change'] * df['volume_weight']).dropna()\n    return heuristics_matrix",
          "objective": -0.00511,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm involves constructing a novel alpha factor through a weighted combination of momentum, volatility, and trading volume changes, then applying a rolling window to generate a heuristics matrix.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    momentum = df['close'].pct_change()\n    volatility = df['close'].pct_change().rolling(window=5).std()\n    volume_change = df['volume'].pct_change()\n    combined_factor = (momentum * 0.4) + (volatility * 0.3) + (volume_change * 0.3)\n    heuristics_matrix = combined_factor\n    return heuristics_matrix",
          "objective": -0.00498,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a weighted combination of momentum, volatility, and trading volume indicators to generate a novel alpha factor, where the weights are determined by the historical performance of each indicator.}\n\n```python\nimport pandas as pd\n\ndef heuristics_v2(df):\n    def calculate_momentum(df, window=20):\n        return df['close'].pct_change(window)\n    \n    def calculate_volatility(df, window=20):\n        return df['close'].pct_change().rolling(window=window).std()\n    \n    def calculate_volume_trend(df, window=20):\n        return df['volume'].rolling(window=window).mean().pct_change()\n    \n    momentum = calculate_momentum(df)\n    volatility = calculate_volatility(df)\n    volume_trend = calculate_volume_trend(df)\n\n    # Hypothetical historical performance weights; in practice, these would be derived from backtesting\n    weights = {'momentum': 0.5, 'volatility': -0.3, 'volume_trend': 0.2",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    def calculate_momentum(df, window=20):\n        return df['close'].pct_change(window)\n    \n    def calculate_volatility(df, window=20):\n        return df['close'].pct_change().rolling(window=window).std()\n    \n    def calculate_volume_trend(df, window=20):\n        return df['volume'].rolling(window=window).mean().pct_change()\n    \n    momentum = calculate_momentum(df)\n    volatility = calculate_volatility(df)\n    volume_trend = calculate_volume_trend(df)\n\n    # Hypothetical historical performance weights; in practice, these would be derived from backtesting\n    weights = {'momentum': 0.5, 'volatility': -0.3, 'volume_trend': 0.2}\n    \n    # Calculate the heuristic score\n    heuristic_score = (momentum * weights['momentum'] + \n                       volatility * weights['volatility'] +\n                       volume_trend * weights['volume_trend'])\n    \n    heuristics_matrix = pd.Series(heuristic_score, index=df.index, name='Alpha Factor')\n    return heuristics_matrix",
          "objective": -0.00239,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a unique heuristic factor for each date based on the weighted sum of price momentum, volume change, and trade amount patterns, where weights are dynamically adjusted according to the recent volatility.",
          "code": "def heuristics_v2(df):\n    # Calculate simple moving averages for closing prices over 5 and 20 days to assess short-term and long-term trends\n    sma_5 = df['close'].rolling(window=5).mean()\n    sma_20 = df['close'].rolling(window=20).mean()\n    \n    # Price Momentum: difference between the current close and the 20-day SMA\n    price_momentum = df['close'] - sma_20\n    \n    # Volume Change: daily percentage change in volume\n    volume_change = df['volume'].pct_change()\n    \n    # Amount Pattern: difference between current amount and 5-day SMA of amount\n    sma_amount_5 = df['amount'].rolling(window=5).mean()\n    amount_pattern = df['amount'] - sma_amount_5\n    \n    # Volatility as standard deviation of log returns\n    log_returns = np.log(df['close'] / df['close'].shift(1))\n    volatility = log_returns.rolling(window=20).std()\n    \n    # Weights (inverse of volatility, high volatility reduces weight) with a small constant to avoid division by zero\n    weights = 1 / (volatility + 1e-6)\n    \n    # Normalize weights to sum to 1 within their respective time frame\n    weights = weights / weights.sum()\n    \n    # Calculate the heuristic factor\n    heuristics_matrix = weights * (price_momentum + volume_change.fillna(0) + amount_pattern)\n    \n    return heuristics_matrix",
          "objective": -0.00193,
          "other_inf": null
     }
]