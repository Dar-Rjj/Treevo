[
     {
          "algorithm": "The new algorithm incorporates a momentum factor based on the high and low prices, combined with changes in trading amount and volume, using a fixed set of weights.",
          "code": "def heuristics_v2(df):\n    lookback_period = 20\n    price_momentum = (df['close'] - df['open'].shift(lookback_period)) / df['open'].shift(lookback_period)\n    high_low_ratio = df['high'] / df['low']\n    amount_change = df['amount'].pct_change(lookback_period)\n    volume_change = df['volume'].pct_change(lookback_period)\n    \n    # Fixed weights\n    w_price = 0.5\n    w_amount = 0.3\n    w_volume = 0.2\n    \n    # Calculate the heuristic factor\n    heuristics_matrix = (w_price * price_momentum) + (w_amount * amount_change) + (w_volume * volume_change)\n    return heuristics_matrix",
          "objective": -0.03585,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm constructs a set of alpha factors by combining market features using logical and arithmetic operations, then aggregates them into a heuristics matrix that reflects potential predictive signals for future returns.",
          "code": "def heuristics_v2(df):\n    heuristics_matrix = (df['close'] - df['open']) / df['volume'] + \\\n                        (df['high'] - df['low']) / (df['high'] + df['low']) - \\\n                        (df['amount'].shift(1) - df['amount'].shift(2)) / df['amount']\n    return heuristics_matrix",
          "objective": -0.03253,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm computes a novel alpha factor by calculating the weighted sum of price momentum, volume change, and trading amount over a specific lookback period, where weights are dynamically adjusted based on the recent volatility of each feature.",
          "code": "import pandas as pd\n\ndef heuristics_v2(df):\n    lookback_period = 20\n    price_change = df['close'].pct_change(lookback_period)\n    volume_change = df['volume'].pct_change(lookback_period)\n    amount_change = df['amount'].pct_change(lookback_period)\n    \n    # Calculate recent volatility to use as dynamic weights\n    price_volatility = df['close'].rolling(window=lookback_period).std()\n    volume_volatility = df['volume'].rolling(window=lookback_period).std()\n    amount_volatility = df['amount'].rolling(window=lookback_period).std()\n    \n    # Inverting the volatility for weight calculation, adding 1e-6 to avoid division by zero\n    w_price = 1 / (price_volatility + 1e-6)\n    w_volume = 1 / (volume_volatility + 1e-6)\n    w_amount = 1 / (amount_volatility + 1e-6)\n    \n    # Normalize the weights\n    total_weight = w_price + w_volume + w_amount\n    w_price /= total_weight\n    w_volume /= total_weight\n    w_amount /= total_weight\n    \n    # Calculate the heuristic factor\n    heuristics_matrix = w_price * price_change + w_volume * volume_change + w_amount * amount_change\n    return heuristics_matrix",
          "objective": -0.02159,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm constructs an interpretable alpha factor by calculating the ratio of today's trading volume to the average trading volume over the past 30 days, then subtracting the 30-day moving average of the closing price.",
          "code": "def heuristics_v2(df):\n    # Calculate the 30-day moving average of the 'volume' and 'close' columns\n    volume_ma = df['volume'].rolling(window=30).mean()\n    close_ma = df['close'].rolling(window=30).mean()\n\n    # Compute the heuristic: (today's volume / 30-day average volume) - 30-day average close\n    heuristics_matrix = (df['volume'] / volume_ma) - close_ma\n\n    return heuristics_matrix",
          "objective": -0.01782,
          "other_inf": null
     }
]